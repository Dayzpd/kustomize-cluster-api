apiVersion: cert-manager.io/v1
kind: Issuer
metadata:
  labels:
    app.kubernetes.io/instance: cluster-api-runtime-extensions-nutanix
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: cluster-api-runtime-extensions-nutanix
    app.kubernetes.io/version: v0.33.1
    cluster.x-k8s.io/provider: runtime-extension-caren
    clusterctl.cluster.x-k8s.io: ''
    helm.sh/chart: cluster-api-runtime-extensions-nutanix-v0.33.1
  name: cluster-api-runtime-extensions-nutanix-issuer
  namespace: cluster-api
spec:
  selfSigned: {}
---
apiVersion: cert-manager.io/v1
kind: Issuer
metadata:
  labels:
    cluster.x-k8s.io/provider: runtime-extension-caren
    clusterctl.cluster.x-k8s.io: ''
  name: helm-repository-selfsigned
  namespace: cluster-api
spec:
  selfSigned: {}
---
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  labels:
    cluster.x-k8s.io/provider: runtime-extension-caren
    clusterctl.cluster.x-k8s.io: ''
  name: helm-repository-tls
  namespace: cluster-api
spec:
  dnsNames:
    - helm-repository.cluster-api.svc
    - helm-repository.cluster-api.svc.cluster.local
  issuerRef:
    kind: Issuer
    name: helm-repository-selfsigned
  secretName: helm-repository-tls
---
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  labels:
    app.kubernetes.io/instance: cluster-api-runtime-extensions-nutanix
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: cluster-api-runtime-extensions-nutanix
    app.kubernetes.io/version: v0.33.1
    cluster.x-k8s.io/provider: runtime-extension-caren
    clusterctl.cluster.x-k8s.io: ''
    helm.sh/chart: cluster-api-runtime-extensions-nutanix-v0.33.1
  name: cluster-api-runtime-extensions-nutanix-admission-tls
  namespace: cluster-api
spec:
  dnsNames:
    - cluster-api-runtime-extensions-nutanix-admission.cluster-api.svc
    - cluster-api-runtime-extensions-nutanix-admission.cluster-api.svc.cluster.local
  issuerRef:
    kind: Issuer
    name: cluster-api-runtime-extensions-nutanix-issuer
  secretName: cluster-api-runtime-extensions-nutanix-admission-tls
---
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  labels:
    app.kubernetes.io/instance: cluster-api-runtime-extensions-nutanix
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: cluster-api-runtime-extensions-nutanix
    app.kubernetes.io/version: v0.33.1
    cluster.x-k8s.io/provider: runtime-extension-caren
    clusterctl.cluster.x-k8s.io: ''
    helm.sh/chart: cluster-api-runtime-extensions-nutanix-v0.33.1
  name: cluster-api-runtime-extensions-nutanix-runtimehooks-tls
  namespace: cluster-api
spec:
  dnsNames:
    - cluster-api-runtime-extensions-nutanix-runtimehooks.cluster-api.svc
    - cluster-api-runtime-extensions-nutanix-runtimehooks.cluster-api.svc.cluster.local
  issuerRef:
    kind: Issuer
    name: cluster-api-runtime-extensions-nutanix-issuer
  secretName: cluster-api-runtime-extensions-nutanix-runtimehooks-tls
---
apiVersion: v1
kind: ServiceAccount
metadata:
  labels:
    app.kubernetes.io/instance: cluster-api-runtime-extensions-nutanix
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: cluster-api-runtime-extensions-nutanix
    app.kubernetes.io/version: v0.33.1
    cluster.x-k8s.io/provider: runtime-extension-caren
    clusterctl.cluster.x-k8s.io: ''
    helm.sh/chart: cluster-api-runtime-extensions-nutanix-v0.33.1
  name: cluster-api-runtime-extensions-nutanix
  namespace: cluster-api
---
apiVersion: v1
data:
  aws-ccm-v1.30.8.yaml: "apiVersion: v1\nkind: ServiceAccount\nmetadata:\n  labels:\n\
    \    helm.sh/chart: aws-cloud-controller-manager-0.0.8\n  name: cloud-controller-manager\n\
    \  namespace: kube-system\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind:\
    \ ClusterRole\nmetadata:\n  labels:\n    helm.sh/chart: aws-cloud-controller-manager-0.0.8\n\
    \  name: system:cloud-controller-manager\nrules:\n- apiGroups:\n  - \"\"\n  resources:\n\
    \  - events\n  verbs:\n  - create\n  - patch\n  - update\n- apiGroups:\n  - \"\
    \"\n  resources:\n  - nodes\n  verbs:\n  - '*'\n- apiGroups:\n  - \"\"\n  resources:\n\
    \  - nodes/status\n  verbs:\n  - patch\n- apiGroups:\n  - \"\"\n  resources:\n\
    \  - services\n  verbs:\n  - list\n  - patch\n  - update\n  - watch\n- apiGroups:\n\
    \  - \"\"\n  resources:\n  - services/status\n  verbs:\n  - list\n  - patch\n\
    \  - update\n  - watch\n- apiGroups:\n  - \"\"\n  resources:\n  - serviceaccounts\n\
    \  verbs:\n  - create\n- apiGroups:\n  - \"\"\n  resources:\n  - persistentvolumes\n\
    \  verbs:\n  - get\n  - list\n  - update\n  - watch\n- apiGroups:\n  - \"\"\n\
    \  resources:\n  - endpoints\n  verbs:\n  - create\n  - get\n  - list\n  - watch\n\
    \  - update\n- apiGroups:\n  - coordination.k8s.io\n  resources:\n  - leases\n\
    \  verbs:\n  - create\n  - get\n  - list\n  - watch\n  - update\n- apiGroups:\n\
    \  - \"\"\n  resources:\n  - serviceaccounts/token\n  verbs:\n  - create\n---\n\
    apiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  labels:\n\
    \    helm.sh/chart: aws-cloud-controller-manager-0.0.8\n  name: cloud-controller-manager:apiserver-authentication-reader\n\
    \  namespace: kube-system\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n \
    \ kind: Role\n  name: extension-apiserver-authentication-reader\nsubjects:\n-\
    \ apiGroup: \"\"\n  kind: ServiceAccount\n  name: cloud-controller-manager\n \
    \ namespace: kube-system\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind:\
    \ ClusterRoleBinding\nmetadata:\n  labels:\n    helm.sh/chart: aws-cloud-controller-manager-0.0.8\n\
    \  name: system:cloud-controller-manager\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n\
    \  kind: ClusterRole\n  name: system:cloud-controller-manager\nsubjects:\n- apiGroup:\
    \ \"\"\n  kind: ServiceAccount\n  name: cloud-controller-manager\n  namespace:\
    \ kube-system\n---\napiVersion: apps/v1\nkind: DaemonSet\nmetadata:\n  labels:\n\
    \    helm.sh/chart: aws-cloud-controller-manager-0.0.8\n    k8s-app: aws-cloud-controller-manager\n\
    \  name: aws-cloud-controller-manager\n  namespace: kube-system\nspec:\n  selector:\n\
    \    matchLabels:\n      k8s-app: aws-cloud-controller-manager\n  template:\n\
    \    metadata:\n      labels:\n        k8s-app: aws-cloud-controller-manager\n\
    \      name: aws-cloud-controller-manager\n    spec:\n      containers:\n    \
    \  - args:\n        - --v=2\n        - --cloud-provider=aws\n        - --configure-cloud-routes=false\n\
    \        env: []\n        image: registry.k8s.io/provider-aws/cloud-controller-manager:v1.30.8\n\
    \        name: aws-cloud-controller-manager\n        resources:\n          requests:\n\
    \            cpu: 200m\n        securityContext: {}\n      dnsPolicy: Default\n\
    \      hostNetwork: true\n      nodeSelector:\n        node-role.kubernetes.io/control-plane:\
    \ \"\"\n      priorityClassName: system-node-critical\n      securityContext:\
    \ {}\n      serviceAccountName: cloud-controller-manager\n      tolerations:\n\
    \      - effect: NoSchedule\n        key: node.cloudprovider.kubernetes.io/uninitialized\n\
    \        value: \"true\"\n      - effect: NoSchedule\n        key: node-role.kubernetes.io/control-plane\n\
    \  updateStrategy:\n    type: RollingUpdate\n"
kind: ConfigMap
metadata:
  creationTimestamp: null
  labels:
    cluster.x-k8s.io/provider: runtime-extension-caren
    clusterctl.cluster.x-k8s.io: ''
  name: aws-ccm-v1.30.8
  namespace: cluster-api
---
apiVersion: v1
data:
  aws-ccm-v1.31.5.yaml: "apiVersion: v1\nkind: ServiceAccount\nmetadata:\n  labels:\n\
    \    helm.sh/chart: aws-cloud-controller-manager-0.0.8\n  name: cloud-controller-manager\n\
    \  namespace: kube-system\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind:\
    \ ClusterRole\nmetadata:\n  labels:\n    helm.sh/chart: aws-cloud-controller-manager-0.0.8\n\
    \  name: system:cloud-controller-manager\nrules:\n- apiGroups:\n  - \"\"\n  resources:\n\
    \  - events\n  verbs:\n  - create\n  - patch\n  - update\n- apiGroups:\n  - \"\
    \"\n  resources:\n  - nodes\n  verbs:\n  - '*'\n- apiGroups:\n  - \"\"\n  resources:\n\
    \  - nodes/status\n  verbs:\n  - patch\n- apiGroups:\n  - \"\"\n  resources:\n\
    \  - services\n  verbs:\n  - list\n  - patch\n  - update\n  - watch\n- apiGroups:\n\
    \  - \"\"\n  resources:\n  - services/status\n  verbs:\n  - list\n  - patch\n\
    \  - update\n  - watch\n- apiGroups:\n  - \"\"\n  resources:\n  - serviceaccounts\n\
    \  verbs:\n  - create\n- apiGroups:\n  - \"\"\n  resources:\n  - persistentvolumes\n\
    \  verbs:\n  - get\n  - list\n  - update\n  - watch\n- apiGroups:\n  - \"\"\n\
    \  resources:\n  - endpoints\n  verbs:\n  - create\n  - get\n  - list\n  - watch\n\
    \  - update\n- apiGroups:\n  - coordination.k8s.io\n  resources:\n  - leases\n\
    \  verbs:\n  - create\n  - get\n  - list\n  - watch\n  - update\n- apiGroups:\n\
    \  - \"\"\n  resources:\n  - serviceaccounts/token\n  verbs:\n  - create\n---\n\
    apiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  labels:\n\
    \    helm.sh/chart: aws-cloud-controller-manager-0.0.8\n  name: cloud-controller-manager:apiserver-authentication-reader\n\
    \  namespace: kube-system\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n \
    \ kind: Role\n  name: extension-apiserver-authentication-reader\nsubjects:\n-\
    \ apiGroup: \"\"\n  kind: ServiceAccount\n  name: cloud-controller-manager\n \
    \ namespace: kube-system\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind:\
    \ ClusterRoleBinding\nmetadata:\n  labels:\n    helm.sh/chart: aws-cloud-controller-manager-0.0.8\n\
    \  name: system:cloud-controller-manager\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n\
    \  kind: ClusterRole\n  name: system:cloud-controller-manager\nsubjects:\n- apiGroup:\
    \ \"\"\n  kind: ServiceAccount\n  name: cloud-controller-manager\n  namespace:\
    \ kube-system\n---\napiVersion: apps/v1\nkind: DaemonSet\nmetadata:\n  labels:\n\
    \    helm.sh/chart: aws-cloud-controller-manager-0.0.8\n    k8s-app: aws-cloud-controller-manager\n\
    \  name: aws-cloud-controller-manager\n  namespace: kube-system\nspec:\n  selector:\n\
    \    matchLabels:\n      k8s-app: aws-cloud-controller-manager\n  template:\n\
    \    metadata:\n      labels:\n        k8s-app: aws-cloud-controller-manager\n\
    \      name: aws-cloud-controller-manager\n    spec:\n      containers:\n    \
    \  - args:\n        - --v=2\n        - --cloud-provider=aws\n        - --configure-cloud-routes=false\n\
    \        env: []\n        image: registry.k8s.io/provider-aws/cloud-controller-manager:v1.31.5\n\
    \        name: aws-cloud-controller-manager\n        resources:\n          requests:\n\
    \            cpu: 200m\n        securityContext: {}\n      dnsPolicy: Default\n\
    \      hostNetwork: true\n      nodeSelector:\n        node-role.kubernetes.io/control-plane:\
    \ \"\"\n      priorityClassName: system-node-critical\n      securityContext:\
    \ {}\n      serviceAccountName: cloud-controller-manager\n      tolerations:\n\
    \      - effect: NoSchedule\n        key: node.cloudprovider.kubernetes.io/uninitialized\n\
    \        value: \"true\"\n      - effect: NoSchedule\n        key: node-role.kubernetes.io/control-plane\n\
    \  updateStrategy:\n    type: RollingUpdate\n"
kind: ConfigMap
metadata:
  creationTimestamp: null
  labels:
    cluster.x-k8s.io/provider: runtime-extension-caren
    clusterctl.cluster.x-k8s.io: ''
  name: aws-ccm-v1.31.5
  namespace: cluster-api
---
apiVersion: v1
data:
  aws-ccm-v1.32.1.yaml: "apiVersion: v1\nkind: ServiceAccount\nmetadata:\n  labels:\n\
    \    helm.sh/chart: aws-cloud-controller-manager-0.0.8\n  name: cloud-controller-manager\n\
    \  namespace: kube-system\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind:\
    \ ClusterRole\nmetadata:\n  labels:\n    helm.sh/chart: aws-cloud-controller-manager-0.0.8\n\
    \  name: system:cloud-controller-manager\nrules:\n- apiGroups:\n  - \"\"\n  resources:\n\
    \  - events\n  verbs:\n  - create\n  - patch\n  - update\n- apiGroups:\n  - \"\
    \"\n  resources:\n  - nodes\n  verbs:\n  - '*'\n- apiGroups:\n  - \"\"\n  resources:\n\
    \  - nodes/status\n  verbs:\n  - patch\n- apiGroups:\n  - \"\"\n  resources:\n\
    \  - services\n  verbs:\n  - list\n  - patch\n  - update\n  - watch\n- apiGroups:\n\
    \  - \"\"\n  resources:\n  - services/status\n  verbs:\n  - list\n  - patch\n\
    \  - update\n  - watch\n- apiGroups:\n  - \"\"\n  resources:\n  - serviceaccounts\n\
    \  verbs:\n  - create\n- apiGroups:\n  - \"\"\n  resources:\n  - persistentvolumes\n\
    \  verbs:\n  - get\n  - list\n  - update\n  - watch\n- apiGroups:\n  - \"\"\n\
    \  resources:\n  - endpoints\n  verbs:\n  - create\n  - get\n  - list\n  - watch\n\
    \  - update\n- apiGroups:\n  - coordination.k8s.io\n  resources:\n  - leases\n\
    \  verbs:\n  - create\n  - get\n  - list\n  - watch\n  - update\n- apiGroups:\n\
    \  - \"\"\n  resources:\n  - serviceaccounts/token\n  verbs:\n  - create\n---\n\
    apiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  labels:\n\
    \    helm.sh/chart: aws-cloud-controller-manager-0.0.8\n  name: cloud-controller-manager:apiserver-authentication-reader\n\
    \  namespace: kube-system\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n \
    \ kind: Role\n  name: extension-apiserver-authentication-reader\nsubjects:\n-\
    \ apiGroup: \"\"\n  kind: ServiceAccount\n  name: cloud-controller-manager\n \
    \ namespace: kube-system\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind:\
    \ ClusterRoleBinding\nmetadata:\n  labels:\n    helm.sh/chart: aws-cloud-controller-manager-0.0.8\n\
    \  name: system:cloud-controller-manager\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n\
    \  kind: ClusterRole\n  name: system:cloud-controller-manager\nsubjects:\n- apiGroup:\
    \ \"\"\n  kind: ServiceAccount\n  name: cloud-controller-manager\n  namespace:\
    \ kube-system\n---\napiVersion: apps/v1\nkind: DaemonSet\nmetadata:\n  labels:\n\
    \    helm.sh/chart: aws-cloud-controller-manager-0.0.8\n    k8s-app: aws-cloud-controller-manager\n\
    \  name: aws-cloud-controller-manager\n  namespace: kube-system\nspec:\n  selector:\n\
    \    matchLabels:\n      k8s-app: aws-cloud-controller-manager\n  template:\n\
    \    metadata:\n      labels:\n        k8s-app: aws-cloud-controller-manager\n\
    \      name: aws-cloud-controller-manager\n    spec:\n      containers:\n    \
    \  - args:\n        - --v=2\n        - --cloud-provider=aws\n        - --configure-cloud-routes=false\n\
    \        env: []\n        image: registry.k8s.io/provider-aws/cloud-controller-manager:v1.32.1\n\
    \        name: aws-cloud-controller-manager\n        resources:\n          requests:\n\
    \            cpu: 200m\n        securityContext: {}\n      dnsPolicy: Default\n\
    \      hostNetwork: true\n      nodeSelector:\n        node-role.kubernetes.io/control-plane:\
    \ \"\"\n      priorityClassName: system-node-critical\n      securityContext:\
    \ {}\n      serviceAccountName: cloud-controller-manager\n      tolerations:\n\
    \      - effect: NoSchedule\n        key: node.cloudprovider.kubernetes.io/uninitialized\n\
    \        value: \"true\"\n      - effect: NoSchedule\n        key: node-role.kubernetes.io/control-plane\n\
    \  updateStrategy:\n    type: RollingUpdate\n"
kind: ConfigMap
metadata:
  creationTimestamp: null
  labels:
    cluster.x-k8s.io/provider: runtime-extension-caren
    clusterctl.cluster.x-k8s.io: ''
  name: aws-ccm-v1.32.1
  namespace: cluster-api
---
apiVersion: v1
data:
  aws-ccm-v1.33.0.yaml: "apiVersion: v1\nkind: ServiceAccount\nmetadata:\n  labels:\n\
    \    helm.sh/chart: aws-cloud-controller-manager-0.0.8\n  name: cloud-controller-manager\n\
    \  namespace: kube-system\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind:\
    \ ClusterRole\nmetadata:\n  labels:\n    helm.sh/chart: aws-cloud-controller-manager-0.0.8\n\
    \  name: system:cloud-controller-manager\nrules:\n- apiGroups:\n  - \"\"\n  resources:\n\
    \  - events\n  verbs:\n  - create\n  - patch\n  - update\n- apiGroups:\n  - \"\
    \"\n  resources:\n  - nodes\n  verbs:\n  - '*'\n- apiGroups:\n  - \"\"\n  resources:\n\
    \  - nodes/status\n  verbs:\n  - patch\n- apiGroups:\n  - \"\"\n  resources:\n\
    \  - services\n  verbs:\n  - list\n  - patch\n  - update\n  - watch\n- apiGroups:\n\
    \  - \"\"\n  resources:\n  - services/status\n  verbs:\n  - list\n  - patch\n\
    \  - update\n  - watch\n- apiGroups:\n  - \"\"\n  resources:\n  - serviceaccounts\n\
    \  verbs:\n  - create\n- apiGroups:\n  - \"\"\n  resources:\n  - persistentvolumes\n\
    \  verbs:\n  - get\n  - list\n  - update\n  - watch\n- apiGroups:\n  - \"\"\n\
    \  resources:\n  - endpoints\n  verbs:\n  - create\n  - get\n  - list\n  - watch\n\
    \  - update\n- apiGroups:\n  - coordination.k8s.io\n  resources:\n  - leases\n\
    \  verbs:\n  - create\n  - get\n  - list\n  - watch\n  - update\n- apiGroups:\n\
    \  - \"\"\n  resources:\n  - serviceaccounts/token\n  verbs:\n  - create\n---\n\
    apiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  labels:\n\
    \    helm.sh/chart: aws-cloud-controller-manager-0.0.8\n  name: cloud-controller-manager:apiserver-authentication-reader\n\
    \  namespace: kube-system\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n \
    \ kind: Role\n  name: extension-apiserver-authentication-reader\nsubjects:\n-\
    \ apiGroup: \"\"\n  kind: ServiceAccount\n  name: cloud-controller-manager\n \
    \ namespace: kube-system\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind:\
    \ ClusterRoleBinding\nmetadata:\n  labels:\n    helm.sh/chart: aws-cloud-controller-manager-0.0.8\n\
    \  name: system:cloud-controller-manager\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n\
    \  kind: ClusterRole\n  name: system:cloud-controller-manager\nsubjects:\n- apiGroup:\
    \ \"\"\n  kind: ServiceAccount\n  name: cloud-controller-manager\n  namespace:\
    \ kube-system\n---\napiVersion: apps/v1\nkind: DaemonSet\nmetadata:\n  labels:\n\
    \    helm.sh/chart: aws-cloud-controller-manager-0.0.8\n    k8s-app: aws-cloud-controller-manager\n\
    \  name: aws-cloud-controller-manager\n  namespace: kube-system\nspec:\n  selector:\n\
    \    matchLabels:\n      k8s-app: aws-cloud-controller-manager\n  template:\n\
    \    metadata:\n      labels:\n        k8s-app: aws-cloud-controller-manager\n\
    \      name: aws-cloud-controller-manager\n    spec:\n      containers:\n    \
    \  - args:\n        - --v=2\n        - --cloud-provider=aws\n        - --configure-cloud-routes=false\n\
    \        env: []\n        image: registry.k8s.io/provider-aws/cloud-controller-manager:v1.33.0\n\
    \        name: aws-cloud-controller-manager\n        resources:\n          requests:\n\
    \            cpu: 200m\n        securityContext: {}\n      dnsPolicy: Default\n\
    \      hostNetwork: true\n      nodeSelector:\n        node-role.kubernetes.io/control-plane:\
    \ \"\"\n      priorityClassName: system-node-critical\n      securityContext:\
    \ {}\n      serviceAccountName: cloud-controller-manager\n      tolerations:\n\
    \      - effect: NoSchedule\n        key: node.cloudprovider.kubernetes.io/uninitialized\n\
    \        value: \"true\"\n      - effect: NoSchedule\n        key: node-role.kubernetes.io/control-plane\n\
    \  updateStrategy:\n    type: RollingUpdate\n"
kind: ConfigMap
metadata:
  creationTimestamp: null
  labels:
    cluster.x-k8s.io/provider: runtime-extension-caren
    clusterctl.cluster.x-k8s.io: ''
  name: aws-ccm-v1.33.0
  namespace: cluster-api
---
apiVersion: v1
data:
  values.yaml: "{{\n$k8sMinorVersionToCCMVersion := dict\n\"1.30\" \"v1.30.8\"\n\"\
    1.31\" \"v1.31.5\"\n\"1.32\" \"v1.32.1\"\n\"1.33\" \"v1.33.0\"\n}}\n{{ $clusterSemver\
    \ := semver .Cluster.spec.topology.version }}\n{{ $ccmVersion := get $k8sMinorVersionToCCMVersion\
    \ ( print $clusterSemver.Major \".\" $clusterSemver.Minor ) }}\nimage:\n  tag:\
    \ \"{{ $ccmVersion }}\"\n\n# Starting in Kubernetes v1.29 the Kubelet no longer\
    \ adds temporary addresses to the Node.\n# See https://github.com/kubernetes/kubernetes/pull/121028\n\
    # This causes a deadlock with the AWS CCM and some CNI providers including Calico.\n\
    # The Calico Pods won't start until some addresses are assigned,\n# but the AWS\
    \ CCM that adds the addresses can't start until the Calico Pods are running.\n\
    # Using hostNetworking allows the AWS CCM to start before the Calico Pods.\n#\
    \ The upstream CAPA templates are also already using hostNetworking for the CCM\
    \ Pods.\nhostNetworking: true\n\nargs:\n  - --v=2\n  - --cloud-provider=aws\n\
    \  - --configure-cloud-routes=false\n\ntolerations:\n  - key: node.cloudprovider.kubernetes.io/uninitialized\n\
    \    value: \"true\"\n    effect: NoSchedule\n  - key: node-role.kubernetes.io/control-plane\n\
    \    effect: NoSchedule"
kind: ConfigMap
metadata:
  labels:
    cluster.x-k8s.io/provider: runtime-extension-caren
    clusterctl.cluster.x-k8s.io: ''
  name: default-aws-ccm-helm-values-template
  namespace: cluster-api
---
apiVersion: v1
data:
  values.yaml: 'prismCentralEndPoint: {{ .PrismCentralHost }}

    prismCentralPort: {{ .PrismCentralPort }}

    prismCentralInsecure: {{ .PrismCentralInsecure }}

    {{- with .PrismCentralAdditionalTrustBundle }}

    prismCentralAdditionalTrustBundle: "{{ . }}"

    {{- end }}

    {{- with .IPsToIgnore }}

    ignoredNodeIPs: [ {{ joinQuoted . }} ]

    {{- end }}


    # The Secret containing the credentials will be created by the handler.

    createSecret: false

    secretName: nutanix-ccm-credentials'
kind: ConfigMap
metadata:
  labels:
    cluster.x-k8s.io/provider: runtime-extension-caren
    clusterctl.cluster.x-k8s.io: ''
  name: default-nutanix-ccm-helm-values-template
  namespace: cluster-api
---
apiVersion: v1
data:
  cluster-autoscaler.yaml: "apiVersion: policy/v1\nkind: PodDisruptionBudget\nmetadata:\n\
    \  labels:\n    app.kubernetes.io/instance: ca-{{ index .Cluster.Annotations \"\
    caren.nutanix.com/cluster-uuid\" }}\n    app.kubernetes.io/managed-by: Helm\n\
    \    app.kubernetes.io/name: clusterapi-cluster-autoscaler\n    helm.sh/chart:\
    \ cluster-autoscaler-9.48.0\n  name: cluster-autoscaler-{{ index .Cluster.Annotations\
    \ \"caren.nutanix.com/cluster-uuid\" }}\n  namespace: {{ .Cluster.Namespace }}\n\
    spec:\n  maxUnavailable: 1\n  selector:\n    matchLabels:\n      app.kubernetes.io/instance:\
    \ ca-{{ index .Cluster.Annotations \"caren.nutanix.com/cluster-uuid\" }}\n   \
    \   app.kubernetes.io/name: clusterapi-cluster-autoscaler\n---\napiVersion: v1\n\
    automountServiceAccountToken: true\nkind: ServiceAccount\nmetadata:\n  labels:\n\
    \    app.kubernetes.io/instance: ca-{{ index .Cluster.Annotations \"caren.nutanix.com/cluster-uuid\"\
    \ }}\n    app.kubernetes.io/managed-by: Helm\n    app.kubernetes.io/name: clusterapi-cluster-autoscaler\n\
    \    helm.sh/chart: cluster-autoscaler-9.48.0\n  name: cluster-autoscaler-{{ index\
    \ .Cluster.Annotations \"caren.nutanix.com/cluster-uuid\" }}\n  namespace: {{\
    \ .Cluster.Namespace }}\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind:\
    \ Role\nmetadata:\n  labels:\n    app.kubernetes.io/instance: ca-{{ index .Cluster.Annotations\
    \ \"caren.nutanix.com/cluster-uuid\" }}\n    app.kubernetes.io/managed-by: Helm\n\
    \    app.kubernetes.io/name: clusterapi-cluster-autoscaler\n    helm.sh/chart:\
    \ cluster-autoscaler-9.48.0\n  name: cluster-autoscaler-{{ index .Cluster.Annotations\
    \ \"caren.nutanix.com/cluster-uuid\" }}\n  namespace: {{ .Cluster.Namespace }}\n\
    rules:\n- apiGroups:\n  - \"\"\n  resources:\n  - configmaps\n  verbs:\n  - create\n\
    - apiGroups:\n  - \"\"\n  resourceNames:\n  - cluster-autoscaler-status\n  resources:\n\
    \  - configmaps\n  verbs:\n  - delete\n  - get\n  - update\n- apiGroups:\n  -\
    \ cluster.x-k8s.io\n  resources:\n  - machinedeployments\n  - machinepools\n \
    \ - machines\n  - machinesets\n  verbs:\n  - get\n  - list\n  - update\n  - watch\n\
    - apiGroups:\n  - cluster.x-k8s.io\n  resources:\n  - machinedeployments/scale\n\
    \  - machinepools/scale\n  verbs:\n  - get\n  - patch\n  - update\n- apiGroups:\n\
    \  - coordination.k8s.io\n  resources:\n  - leases\n  verbs:\n  - create\n- apiGroups:\n\
    \  - coordination.k8s.io\n  resourceNames:\n  - cluster-autoscaler\n  resources:\n\
    \  - leases\n  verbs:\n  - get\n  - update\n---\napiVersion: rbac.authorization.k8s.io/v1\n\
    kind: RoleBinding\nmetadata:\n  labels:\n    app.kubernetes.io/instance: ca-{{\
    \ index .Cluster.Annotations \"caren.nutanix.com/cluster-uuid\" }}\n    app.kubernetes.io/managed-by:\
    \ Helm\n    app.kubernetes.io/name: clusterapi-cluster-autoscaler\n    helm.sh/chart:\
    \ cluster-autoscaler-9.48.0\n  name: cluster-autoscaler-{{ index .Cluster.Annotations\
    \ \"caren.nutanix.com/cluster-uuid\" }}\n  namespace: {{ .Cluster.Namespace }}\n\
    roleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: Role\n  name: cluster-autoscaler-{{\
    \ index .Cluster.Annotations \"caren.nutanix.com/cluster-uuid\" }}\nsubjects:\n\
    - kind: ServiceAccount\n  name: cluster-autoscaler-{{ index .Cluster.Annotations\
    \ \"caren.nutanix.com/cluster-uuid\" }}\n  namespace: {{ .Cluster.Namespace }}\n\
    ---\napiVersion: v1\nkind: Service\nmetadata:\n  labels:\n    app.kubernetes.io/instance:\
    \ ca-{{ index .Cluster.Annotations \"caren.nutanix.com/cluster-uuid\" }}\n   \
    \ app.kubernetes.io/managed-by: Helm\n    app.kubernetes.io/name: clusterapi-cluster-autoscaler\n\
    \    helm.sh/chart: cluster-autoscaler-9.48.0\n  name: cluster-autoscaler-{{ index\
    \ .Cluster.Annotations \"caren.nutanix.com/cluster-uuid\" }}\n  namespace: {{\
    \ .Cluster.Namespace }}\nspec:\n  ports:\n  - name: http\n    port: 8085\n   \
    \ protocol: TCP\n    targetPort: 8085\n  selector:\n    app.kubernetes.io/instance:\
    \ ca-{{ index .Cluster.Annotations \"caren.nutanix.com/cluster-uuid\" }}\n   \
    \ app.kubernetes.io/name: clusterapi-cluster-autoscaler\n  type: ClusterIP\n---\n\
    apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  labels:\n    app.kubernetes.io/instance:\
    \ ca-{{ index .Cluster.Annotations \"caren.nutanix.com/cluster-uuid\" }}\n   \
    \ app.kubernetes.io/managed-by: Helm\n    app.kubernetes.io/name: clusterapi-cluster-autoscaler\n\
    \    helm.sh/chart: cluster-autoscaler-9.48.0\n  name: cluster-autoscaler-{{ index\
    \ .Cluster.Annotations \"caren.nutanix.com/cluster-uuid\" }}\n  namespace: {{\
    \ .Cluster.Namespace }}\nspec:\n  replicas: 1\n  revisionHistoryLimit: 10\n  selector:\n\
    \    matchLabels:\n      app.kubernetes.io/instance: ca-{{ index .Cluster.Annotations\
    \ \"caren.nutanix.com/cluster-uuid\" }}\n      app.kubernetes.io/name: clusterapi-cluster-autoscaler\n\
    \  template:\n    metadata:\n      labels:\n        app.kubernetes.io/instance:\
    \ ca-{{ index .Cluster.Annotations \"caren.nutanix.com/cluster-uuid\" }}\n   \
    \     app.kubernetes.io/name: clusterapi-cluster-autoscaler\n    spec:\n     \
    \ containers:\n      - command:\n        - ./cluster-autoscaler\n        - --cloud-provider=clusterapi\n\
    \        - --namespace=kube-system\n        - --node-group-auto-discovery=clusterapi:clusterName={{\
    \ .Cluster.Name }},namespace={{ .Cluster.Namespace }}\n        - --kubeconfig=/cluster/kubeconfig\n\
    \        - --clusterapi-cloud-config-authoritative\n        - --enforce-node-group-min-size=true\n\
    \        - --logtostderr=true\n        - --stderrthreshold=info\n        - --v=4\n\
    \        env:\n        - name: POD_NAMESPACE\n          valueFrom:\n         \
    \   fieldRef:\n              fieldPath: metadata.namespace\n        - name: SERVICE_ACCOUNT\n\
    \          valueFrom:\n            fieldRef:\n              fieldPath: spec.serviceAccountName\n\
    \        image: registry.k8s.io/autoscaling/cluster-autoscaler:v1.33.0\n     \
    \   imagePullPolicy: IfNotPresent\n        livenessProbe:\n          httpGet:\n\
    \            path: /health-check\n            port: 8085\n        name: clusterapi-cluster-autoscaler\n\
    \        ports:\n        - containerPort: 8085\n        resources: {}\n      \
    \  volumeMounts:\n        - mountPath: /cluster\n          name: kubeconfig\n\
    \          readOnly: true\n      dnsPolicy: ClusterFirst\n      priorityClassName:\
    \ system-cluster-critical\n      serviceAccountName: cluster-autoscaler-{{ index\
    \ .Cluster.Annotations \"caren.nutanix.com/cluster-uuid\" }}\n      tolerations:\n\
    \      - effect: NoSchedule\n        key: node-role.kubernetes.io/control-plane\n\
    \      volumes:\n      - name: kubeconfig\n        secret:\n          items:\n\
    \          - key: value\n            path: kubeconfig\n          secretName: {{\
    \ .Cluster.Name }}-kubeconfig\n"
kind: ConfigMap
metadata:
  creationTimestamp: null
  labels:
    cluster.x-k8s.io/provider: runtime-extension-caren
    clusterctl.cluster.x-k8s.io: ''
  name: cluster-autoscaler
  namespace: cluster-api
---
apiVersion: v1
data:
  values.yaml: "fullnameOverride: \"cluster-autoscaler-{{ index .Cluster.Annotations\
    \ \"caren.nutanix.com/cluster-uuid\" }}\"\n\ncloudProvider: clusterapi\n\n# Always\
    \ trigger a scale-out if replicas are less than the min.\nextraArgs:\n  enforce-node-group-min-size:\
    \ true\n\n# Enable it to run in a 1 Node cluster.\ntolerations:\n  - effect: NoSchedule\n\
    \    key: node-role.kubernetes.io/control-plane\n\n# Limit a single cluster-autoscaler\
    \ Deployment to a single Cluster.\nautoDiscovery:\n  clusterName: \"{{ .Cluster.Name\
    \ }}\"\n  # The controller failed with an RBAC error trying to watch CAPI objects\
    \ at the cluster scope without this.\n  labels:\n    - namespace: \"{{ .Cluster.Namespace\
    \ }}\"\n\n# For workload clusters it is not possible to use the in-cluster client.\n\
    # To simplify the configuration, use the admin kubeconfig generated by CAPI for\
    \ all clusters.\nclusterAPIMode: kubeconfig-incluster\nclusterAPIWorkloadKubeconfigPath:\
    \ /cluster/kubeconfig\nextraVolumeSecrets:\n  kubeconfig:\n    name: \"{{ .Cluster.Name\
    \ }}-kubeconfig\"\n    mountPath: /cluster\n    readOnly: true\n    items:\n \
    \     - key: value\n        path: kubeconfig\nrbac:\n  # Create a Role instead\
    \ of a ClusterRoles to update cluster-api objects\n  clusterScoped: false\n{{-\
    \ $capiProvider := index .Cluster.Labels \"cluster.x-k8s.io/provider\" }}\n{{-\
    \ if eq $capiProvider \"aws\" }}\n  additionalRules:\n    - apiGroups:\n     \
    \ - infrastructure.cluster.x-k8s.io\n      resources:\n      - awsmachinetemplates\n\
    \      verbs:\n      - get\n      - list\n      - watch\n{{- else if eq $capiProvider\
    \ \"docker\" }}\n  additionalRules:\n    - apiGroups:\n      - infrastructure.cluster.x-k8s.io\n\
    \      resources:\n      - dockermachinetemplates\n      verbs:\n      - get\n\
    \      - list\n      - watch\n{{- else if eq $capiProvider \"nutanix\" }}\n  additionalRules:\n\
    \    - apiGroups:\n      - infrastructure.cluster.x-k8s.io\n      resources:\n\
    \      - nutanixmachinetemplates\n      verbs:\n      - get\n      - list\n  \
    \    - watch\n{{- end }}"
kind: ConfigMap
metadata:
  labels:
    cluster.x-k8s.io/provider: runtime-extension-caren
    clusterctl.cluster.x-k8s.io: ''
  name: default-cluster-autoscaler-helm-values-template
  namespace: cluster-api
---
apiVersion: v1
data:
  calico-installation: "# For more information, see: https://docs.projectcalico.org/reference/installation/api\n\
    apiVersion: operator.tigera.io/v1\nkind: Installation\nmetadata:\n  name: default\n\
    spec:\n  cni:\n    type: Calico\n  # Configures Calico networking.\n  calicoNetwork:\n\
    \    # Note: The ipPools section cannot be modified post-install.\n    ipPools:\n\
    \    - blockSize: 26\n      cidr: 192.168.0.0/16\n      encapsulation: IPIP\n\
    \      natOutgoing: Enabled\n      nodeSelector: all()\n    bgp: Enabled\n  nodeMetricsPort:\
    \ 9091\n  typhaMetricsPort: 9093\n  registry: quay.io/\n"
kind: ConfigMap
metadata:
  labels:
    cluster.x-k8s.io/provider: runtime-extension-caren
    clusterctl.cluster.x-k8s.io: ''
  name: calico-cni-crs-installation-awscluster
  namespace: cluster-api
---
apiVersion: v1
data:
  values.yaml: "installation:\n  cni:\n    type: Calico\n  calicoNetwork:\n    bgp:\
    \ Enabled\n    ipPools: {{ range $cidr := .Cluster.spec.clusterNetwork.pods.cidrBlocks\
    \ }}\n    - cidr: \"{{ $cidr }}\"\n      encapsulation: None\n      natOutgoing:\
    \ Enabled\n      nodeSelector: all(){{ end }}\n  nodeMetricsPort: 9091\n  typhaMetricsPort:\
    \ 9093\n  registry: quay.io/"
kind: ConfigMap
metadata:
  labels:
    cluster.x-k8s.io/provider: runtime-extension-caren
    clusterctl.cluster.x-k8s.io: ''
  name: calico-cni-helm-values-template-awscluster
  namespace: cluster-api
---
apiVersion: v1
data:
  calico-installation: "# For more information, see: https://docs.projectcalico.org/reference/installation/api\n\
    apiVersion: operator.tigera.io/v1\nkind: Installation\nmetadata:\n  name: default\n\
    spec:\n  cni:\n    type: Calico\n  # Configures Calico networking.\n  calicoNetwork:\n\
    \    # Note: The ipPools section cannot be modified post-install.\n    ipPools:\n\
    \    - blockSize: 26\n      cidr: 192.168.0.0/16\n      encapsulation: VXLANCrossSubnet\n\
    \      natOutgoing: Enabled\n      nodeSelector: all()\n  nodeMetricsPort: 9091\n\
    \  typhaMetricsPort: 9093\n  registry: quay.io/\n"
kind: ConfigMap
metadata:
  labels:
    cluster.x-k8s.io/provider: runtime-extension-caren
    clusterctl.cluster.x-k8s.io: ''
  name: calico-cni-crs-installation-dockercluster
  namespace: cluster-api
---
apiVersion: v1
data:
  values.yaml: "installation:\n  cni:\n    type: Calico\n  calicoNetwork:\n    ipPools:{{\
    \ range $cidr := .Cluster.spec.clusterNetwork.pods.cidrBlocks }}\n    - cidr:\
    \ \"{{ $cidr }}\"\n      encapsulation: None\n      natOutgoing: Enabled\n   \
    \   nodeSelector: all(){{ end }}\n  nodeMetricsPort: 9091\n  typhaMetricsPort:\
    \ 9093\n  registry: quay.io/"
kind: ConfigMap
metadata:
  labels:
    cluster.x-k8s.io/provider: runtime-extension-caren
    clusterctl.cluster.x-k8s.io: ''
  name: calico-cni-helm-values-template-dockercluster
  namespace: cluster-api
---
apiVersion: v1
data:
  calico-installation: "# For more information, see: https://docs.projectcalico.org/reference/installation/api\n\
    apiVersion: operator.tigera.io/v1\nkind: Installation\nmetadata:\n  name: default\n\
    spec:\n  cni:\n    type: Calico\n  # Configures Calico networking.\n  calicoNetwork:\n\
    \    # Note: The ipPools section cannot be modified post-install.\n    ipPools:\n\
    \    - blockSize: 26\n      cidr: 192.168.0.0/16\n      encapsulation: IPIP\n\
    \      natOutgoing: Enabled\n      nodeSelector: all()\n    bgp: Enabled\n  nodeMetricsPort:\
    \ 9091\n  typhaMetricsPort: 9093\n  registry: quay.io/\n"
kind: ConfigMap
metadata:
  labels:
    cluster.x-k8s.io/provider: runtime-extension-caren
    clusterctl.cluster.x-k8s.io: ''
  name: calico-cni-crs-installation-nutanixcluster
  namespace: cluster-api
---
apiVersion: v1
data:
  values.yaml: "installation:\n  cni:\n    type: Calico\n  calicoNetwork:\n    bgp:\
    \ Enabled\n    ipPools:{{ range $cidr := .Cluster.spec.clusterNetwork.pods.cidrBlocks\
    \ }}\n    - cidr: \"{{ $cidr }}\"\n      encapsulation: None\n      natOutgoing:\
    \ Enabled\n      nodeSelector: all(){{ end }}\n  nodeMetricsPort: 9091\n  typhaMetricsPort:\
    \ 9093\n  registry: quay.io/"
kind: ConfigMap
metadata:
  labels:
    cluster.x-k8s.io/provider: runtime-extension-caren
    clusterctl.cluster.x-k8s.io: ''
  name: calico-cni-helm-values-template-nutanixcluster
  namespace: cluster-api
---
apiVersion: v1
data:
  tigera-operator.json: '[{"apiVersion":"v1","kind":"Namespace","metadata":{"labels":{"pod-security.kubernetes.io/enforce":"privileged","pod-security.kubernetes.io/enforce-version":"latest"},"name":"tigera-operator"}},{"apiVersion":"apiextensions.k8s.io/v1","kind":"CustomResourceDefinition","metadata":{"name":"bgpconfigurations.crd.projectcalico.org"},"spec":{"group":"crd.projectcalico.org","names":{"kind":"BGPConfiguration","listKind":"BGPConfigurationList","plural":"bgpconfigurations","singular":"bgpconfiguration"},"preserveUnknownFields":false,"scope":"Cluster","versions":[{"name":"v1","schema":{"openAPIV3Schema":{"description":"BGPConfiguration
    contains the configuration for any BGP routing.","properties":{"apiVersion":{"description":"APIVersion
    defines the versioned schema of this representation of an object. Servers should
    convert recognized schemas to the latest internal value, and may reject unrecognized
    values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","type":"string"},"kind":{"description":"Kind
    is a string value representing the REST resource this object represents. Servers
    may infer this from the endpoint the client submits requests to. Cannot be updated.
    In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","type":"string"},"metadata":{"type":"object"},"spec":{"description":"BGPConfigurationSpec
    contains the values of the BGP configuration.","properties":{"asNumber":{"description":"ASNumber
    is the default AS number used by a node. [Default: 64512]","format":"int32","type":"integer"},"bindMode":{"description":"BindMode
    indicates whether to listen for BGP connections on all addresses (None) or only
    on the node''s canonical IP address Node.Spec.BGP.IPvXAddress (NodeIP). Default
    behaviour is to listen for BGP connections on all addresses.","type":"string"},"communities":{"description":"Communities
    is a list of BGP community values and their arbitrary names for tagging routes.","items":{"description":"Community
    contains standard or large community value and its name.","properties":{"name":{"description":"Name
    given to community value.","type":"string"},"value":{"description":"Value must
    be of format `aa:nn` or `aa:nn:mm`. For standard community use `aa:nn` format,
    where `aa` and `nn` are 16 bit number. For large community use `aa:nn:mm` format,
    where `aa`, `nn` and `mm` are 32 bit number. Where, `aa` is an AS Number, `nn`
    and `mm` are per-AS identifier.","pattern":"^(\\d+):(\\d+)$|^(\\d+):(\\d+):(\\d+)$","type":"string"}},"type":"object"},"type":"array"},"ignoredInterfaces":{"description":"IgnoredInterfaces
    indicates the network interfaces that needs to be excluded when reading device
    routes.","items":{"type":"string"},"type":"array"},"listenPort":{"description":"ListenPort
    is the port where BGP protocol should listen. Defaults to 179","maximum":65535,"minimum":1,"type":"integer"},"logSeverityScreen":{"description":"LogSeverityScreen
    is the log severity above which logs are sent to the stdout. [Default: INFO]","type":"string"},"nodeMeshMaxRestartTime":{"description":"Time
    to allow for software restart for node-to-mesh peerings.  When specified, this
    is configured as the graceful restart timeout.  When not specified, the BIRD default
    of 120s is used. This field can only be set on the default BGPConfiguration instance
    and requires that NodeMesh is enabled","type":"string"},"nodeMeshPassword":{"description":"Optional
    BGP password for full node-to-mesh peerings. This field can only be set on the
    default BGPConfiguration instance and requires that NodeMesh is enabled","properties":{"secretKeyRef":{"description":"Selects
    a key of a secret in the node pod''s namespace.","properties":{"key":{"description":"The
    key of the secret to select from.  Must be a valid secret key.","type":"string"},"name":{"default":"","description":"Name
    of the referent. This field is effectively required, but due to backwards compatibility
    is allowed to be empty. Instances of this type with an empty value here are almost
    certainly wrong. TODO: Add other useful fields. apiVersion, kind, uid? More info:
    https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    TODO: Drop `kubebuilder:default` when controller-gen doesn''t need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.","type":"string"},"optional":{"description":"Specify
    whether the Secret or its key must be defined","type":"boolean"}},"required":["key"],"type":"object"}},"type":"object"},"nodeToNodeMeshEnabled":{"description":"NodeToNodeMeshEnabled
    sets whether full node to node BGP mesh is enabled. [Default: true]","type":"boolean"},"prefixAdvertisements":{"description":"PrefixAdvertisements
    contains per-prefix advertisement configuration.","items":{"description":"PrefixAdvertisement
    configures advertisement properties for the specified CIDR.","properties":{"cidr":{"description":"CIDR
    for which properties should be advertised.","type":"string"},"communities":{"description":"Communities
    can be list of either community names already defined in `Specs.Communities` or
    community value of format `aa:nn` or `aa:nn:mm`. For standard community use `aa:nn`
    format, where `aa` and `nn` are 16 bit number. For large community use `aa:nn:mm`
    format, where `aa`, `nn` and `mm` are 32 bit number. Where,`aa` is an AS Number,
    `nn` and `mm` are per-AS identifier.","items":{"type":"string"},"type":"array"}},"type":"object"},"type":"array"},"serviceClusterIPs":{"description":"ServiceClusterIPs
    are the CIDR blocks from which service cluster IPs are allocated. If specified,
    Calico will advertise these blocks, as well as any cluster IPs within them.","items":{"description":"ServiceClusterIPBlock
    represents a single allowed ClusterIP CIDR block.","properties":{"cidr":{"type":"string"}},"type":"object"},"type":"array"},"serviceExternalIPs":{"description":"ServiceExternalIPs
    are the CIDR blocks for Kubernetes Service External IPs. Kubernetes Service ExternalIPs
    will only be advertised if they are within one of these blocks.","items":{"description":"ServiceExternalIPBlock
    represents a single allowed External IP CIDR block.","properties":{"cidr":{"type":"string"}},"type":"object"},"type":"array"},"serviceLoadBalancerIPs":{"description":"ServiceLoadBalancerIPs
    are the CIDR blocks for Kubernetes Service LoadBalancer IPs. Kubernetes Service
    status.LoadBalancer.Ingress IPs will only be advertised if they are within one
    of these blocks.","items":{"description":"ServiceLoadBalancerIPBlock represents
    a single allowed LoadBalancer IP CIDR block.","properties":{"cidr":{"type":"string"}},"type":"object"},"type":"array"}},"type":"object"}},"type":"object"}},"served":true,"storage":true}]},"status":{"acceptedNames":{"kind":"","plural":""},"conditions":[],"storedVersions":[]}},{"apiVersion":"apiextensions.k8s.io/v1","kind":"CustomResourceDefinition","metadata":{"annotations":{"controller-gen.kubebuilder.io/version":"(devel)"},"creationTimestamp":null,"name":"bgpfilters.crd.projectcalico.org"},"spec":{"group":"crd.projectcalico.org","names":{"kind":"BGPFilter","listKind":"BGPFilterList","plural":"bgpfilters","singular":"bgpfilter"},"scope":"Cluster","versions":[{"name":"v1","schema":{"openAPIV3Schema":{"properties":{"apiVersion":{"description":"APIVersion
    defines the versioned schema of this representation of an object. Servers should
    convert recognized schemas to the latest internal value, and may reject unrecognized
    values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","type":"string"},"kind":{"description":"Kind
    is a string value representing the REST resource this object represents. Servers
    may infer this from the endpoint the client submits requests to. Cannot be updated.
    In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","type":"string"},"metadata":{"type":"object"},"spec":{"description":"BGPFilterSpec
    contains the IPv4 and IPv6 filter rules of the BGP Filter.","properties":{"exportV4":{"description":"The
    ordered set of IPv4 BGPFilter rules acting on exporting routes to a peer.","items":{"description":"BGPFilterRuleV4
    defines a BGP filter rule consisting a single IPv4 CIDR block and a filter action
    for this CIDR.","properties":{"action":{"type":"string"},"cidr":{"type":"string"},"interface":{"type":"string"},"matchOperator":{"type":"string"},"prefixLength":{"properties":{"max":{"format":"int32","maximum":32,"minimum":0,"type":"integer"},"min":{"format":"int32","maximum":32,"minimum":0,"type":"integer"}},"type":"object"},"source":{"type":"string"}},"required":["action"],"type":"object"},"type":"array"},"exportV6":{"description":"The
    ordered set of IPv6 BGPFilter rules acting on exporting routes to a peer.","items":{"description":"BGPFilterRuleV6
    defines a BGP filter rule consisting a single IPv6 CIDR block and a filter action
    for this CIDR.","properties":{"action":{"type":"string"},"cidr":{"type":"string"},"interface":{"type":"string"},"matchOperator":{"type":"string"},"prefixLength":{"properties":{"max":{"format":"int32","maximum":128,"minimum":0,"type":"integer"},"min":{"format":"int32","maximum":128,"minimum":0,"type":"integer"}},"type":"object"},"source":{"type":"string"}},"required":["action"],"type":"object"},"type":"array"},"importV4":{"description":"The
    ordered set of IPv4 BGPFilter rules acting on importing routes from a peer.","items":{"description":"BGPFilterRuleV4
    defines a BGP filter rule consisting a single IPv4 CIDR block and a filter action
    for this CIDR.","properties":{"action":{"type":"string"},"cidr":{"type":"string"},"interface":{"type":"string"},"matchOperator":{"type":"string"},"prefixLength":{"properties":{"max":{"format":"int32","maximum":32,"minimum":0,"type":"integer"},"min":{"format":"int32","maximum":32,"minimum":0,"type":"integer"}},"type":"object"},"source":{"type":"string"}},"required":["action"],"type":"object"},"type":"array"},"importV6":{"description":"The
    ordered set of IPv6 BGPFilter rules acting on importing routes from a peer.","items":{"description":"BGPFilterRuleV6
    defines a BGP filter rule consisting a single IPv6 CIDR block and a filter action
    for this CIDR.","properties":{"action":{"type":"string"},"cidr":{"type":"string"},"interface":{"type":"string"},"matchOperator":{"type":"string"},"prefixLength":{"properties":{"max":{"format":"int32","maximum":128,"minimum":0,"type":"integer"},"min":{"format":"int32","maximum":128,"minimum":0,"type":"integer"}},"type":"object"},"source":{"type":"string"}},"required":["action"],"type":"object"},"type":"array"}},"type":"object"}},"type":"object"}},"served":true,"storage":true}]},"status":{"acceptedNames":{"kind":"","plural":""},"conditions":[],"storedVersions":[]}},{"apiVersion":"apiextensions.k8s.io/v1","kind":"CustomResourceDefinition","metadata":{"name":"bgppeers.crd.projectcalico.org"},"spec":{"group":"crd.projectcalico.org","names":{"kind":"BGPPeer","listKind":"BGPPeerList","plural":"bgppeers","singular":"bgppeer"},"preserveUnknownFields":false,"scope":"Cluster","versions":[{"name":"v1","schema":{"openAPIV3Schema":{"properties":{"apiVersion":{"description":"APIVersion
    defines the versioned schema of this representation of an object. Servers should
    convert recognized schemas to the latest internal value, and may reject unrecognized
    values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","type":"string"},"kind":{"description":"Kind
    is a string value representing the REST resource this object represents. Servers
    may infer this from the endpoint the client submits requests to. Cannot be updated.
    In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","type":"string"},"metadata":{"type":"object"},"spec":{"description":"BGPPeerSpec
    contains the specification for a BGPPeer resource.","properties":{"asNumber":{"description":"The
    AS Number of the peer.","format":"int32","type":"integer"},"filters":{"description":"The
    ordered set of BGPFilters applied on this BGP peer.","items":{"type":"string"},"type":"array"},"keepOriginalNextHop":{"description":"Option
    to keep the original nexthop field when routes are sent to a BGP Peer. Setting
    \"true\" configures the selected BGP Peers node to use the \"next hop keep;\"
    instead of \"next hop self;\"(default) in the specific branch of the Node on \"bird.cfg\".","type":"boolean"},"maxRestartTime":{"description":"Time
    to allow for software restart.  When specified, this is configured as the graceful
    restart timeout.  When not specified, the BIRD default of 120s is used.","type":"string"},"node":{"description":"The
    node name identifying the Calico node instance that is targeted by this peer.
    If this is not set, and no nodeSelector is specified, then this BGP peer selects
    all nodes in the cluster.","type":"string"},"nodeSelector":{"description":"Selector
    for the nodes that should have this peering.  When this is set, the Node field
    must be empty.","type":"string"},"numAllowedLocalASNumbers":{"description":"Maximum
    number of local AS numbers that are allowed in the AS path for received routes.
    This removes BGP loop prevention and should only be used if absolutely necessary.","format":"int32","type":"integer"},"password":{"description":"Optional
    BGP password for the peerings generated by this BGPPeer resource.","properties":{"secretKeyRef":{"description":"Selects
    a key of a secret in the node pod''s namespace.","properties":{"key":{"description":"The
    key of the secret to select from.  Must be a valid secret key.","type":"string"},"name":{"default":"","description":"Name
    of the referent. This field is effectively required, but due to backwards compatibility
    is allowed to be empty. Instances of this type with an empty value here are almost
    certainly wrong. TODO: Add other useful fields. apiVersion, kind, uid? More info:
    https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    TODO: Drop `kubebuilder:default` when controller-gen doesn''t need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.","type":"string"},"optional":{"description":"Specify
    whether the Secret or its key must be defined","type":"boolean"}},"required":["key"],"type":"object"}},"type":"object"},"peerIP":{"description":"The
    IP address of the peer followed by an optional port number to peer with. If port
    number is given, format should be `[<IPv6>]:port` or `<IPv4>:<port>` for IPv4.
    If optional port number is not set, and this peer IP and ASNumber belongs to a
    calico/node with ListenPort set in BGPConfiguration, then we use that port to
    peer.","type":"string"},"peerSelector":{"description":"Selector for the remote
    nodes to peer with.  When this is set, the PeerIP and ASNumber fields must be
    empty.  For each peering between the local node and selected remote nodes, we
    configure an IPv4 peering if both ends have NodeBGPSpec.IPv4Address specified,
    and an IPv6 peering if both ends have NodeBGPSpec.IPv6Address specified.  The
    remote AS number comes from the remote node''s NodeBGPSpec.ASNumber, or the global
    default if that is not set.","type":"string"},"reachableBy":{"description":"Add
    an exact, i.e. /32, static route toward peer IP in order to prevent route flapping.
    ReachableBy contains the address of the gateway which peer can be reached by.","type":"string"},"sourceAddress":{"description":"Specifies
    whether and how to configure a source address for the peerings generated by this
    BGPPeer resource.  Default value \"UseNodeIP\" means to configure the node IP
    as the source address.  \"None\" means not to configure a source address.","type":"string"},"ttlSecurity":{"description":"TTLSecurity
    enables the generalized TTL security mechanism (GTSM) which protects against spoofed
    packets by ignoring received packets with a smaller than expected TTL value. The
    provided value is the number of hops (edges) between the peers.","type":"integer"}},"type":"object"}},"type":"object"}},"served":true,"storage":true}]},"status":{"acceptedNames":{"kind":"","plural":""},"conditions":[],"storedVersions":[]}},{"apiVersion":"apiextensions.k8s.io/v1","kind":"CustomResourceDefinition","metadata":{"name":"blockaffinities.crd.projectcalico.org"},"spec":{"group":"crd.projectcalico.org","names":{"kind":"BlockAffinity","listKind":"BlockAffinityList","plural":"blockaffinities","singular":"blockaffinity"},"preserveUnknownFields":false,"scope":"Cluster","versions":[{"name":"v1","schema":{"openAPIV3Schema":{"properties":{"apiVersion":{"description":"APIVersion
    defines the versioned schema of this representation of an object. Servers should
    convert recognized schemas to the latest internal value, and may reject unrecognized
    values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","type":"string"},"kind":{"description":"Kind
    is a string value representing the REST resource this object represents. Servers
    may infer this from the endpoint the client submits requests to. Cannot be updated.
    In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","type":"string"},"metadata":{"type":"object"},"spec":{"description":"BlockAffinitySpec
    contains the specification for a BlockAffinity resource.","properties":{"cidr":{"type":"string"},"deleted":{"description":"Deleted
    indicates that this block affinity is being deleted. This field is a string for
    compatibility with older releases that mistakenly treat this field as a string.","type":"string"},"node":{"type":"string"},"state":{"type":"string"}},"required":["cidr","deleted","node","state"],"type":"object"}},"type":"object"}},"served":true,"storage":true}]},"status":{"acceptedNames":{"kind":"","plural":""},"conditions":[],"storedVersions":[]}},{"apiVersion":"apiextensions.k8s.io/v1","kind":"CustomResourceDefinition","metadata":{"annotations":{"controller-gen.kubebuilder.io/version":"(devel)"},"creationTimestamp":null,"name":"caliconodestatuses.crd.projectcalico.org"},"spec":{"group":"crd.projectcalico.org","names":{"kind":"CalicoNodeStatus","listKind":"CalicoNodeStatusList","plural":"caliconodestatuses","singular":"caliconodestatus"},"preserveUnknownFields":false,"scope":"Cluster","versions":[{"name":"v1","schema":{"openAPIV3Schema":{"properties":{"apiVersion":{"description":"APIVersion
    defines the versioned schema of this representation of an object. Servers should
    convert recognized schemas to the latest internal value, and may reject unrecognized
    values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","type":"string"},"kind":{"description":"Kind
    is a string value representing the REST resource this object represents. Servers
    may infer this from the endpoint the client submits requests to. Cannot be updated.
    In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","type":"string"},"metadata":{"type":"object"},"spec":{"description":"CalicoNodeStatusSpec
    contains the specification for a CalicoNodeStatus resource.","properties":{"classes":{"description":"Classes
    declares the types of information to monitor for this calico/node, and allows
    for selective status reporting about certain subsets of information.","items":{"type":"string"},"type":"array"},"node":{"description":"The
    node name identifies the Calico node instance for node status.","type":"string"},"updatePeriodSeconds":{"description":"UpdatePeriodSeconds
    is the period at which CalicoNodeStatus should be updated. Set to 0 to disable
    CalicoNodeStatus refresh. Maximum update period is one day.","format":"int32","type":"integer"}},"type":"object"},"status":{"description":"CalicoNodeStatusStatus
    defines the observed state of CalicoNodeStatus. No validation needed for status
    since it is updated by Calico.","properties":{"agent":{"description":"Agent holds
    agent status on the node.","properties":{"birdV4":{"description":"BIRDV4 represents
    the latest observed status of bird4.","properties":{"lastBootTime":{"description":"LastBootTime
    holds the value of lastBootTime from bird.ctl output.","type":"string"},"lastReconfigurationTime":{"description":"LastReconfigurationTime
    holds the value of lastReconfigTime from bird.ctl output.","type":"string"},"routerID":{"description":"Router
    ID used by bird.","type":"string"},"state":{"description":"The state of the BGP
    Daemon.","type":"string"},"version":{"description":"Version of the BGP daemon","type":"string"}},"type":"object"},"birdV6":{"description":"BIRDV6
    represents the latest observed status of bird6.","properties":{"lastBootTime":{"description":"LastBootTime
    holds the value of lastBootTime from bird.ctl output.","type":"string"},"lastReconfigurationTime":{"description":"LastReconfigurationTime
    holds the value of lastReconfigTime from bird.ctl output.","type":"string"},"routerID":{"description":"Router
    ID used by bird.","type":"string"},"state":{"description":"The state of the BGP
    Daemon.","type":"string"},"version":{"description":"Version of the BGP daemon","type":"string"}},"type":"object"}},"type":"object"},"bgp":{"description":"BGP
    holds node BGP status.","properties":{"numberEstablishedV4":{"description":"The
    total number of IPv4 established bgp sessions.","type":"integer"},"numberEstablishedV6":{"description":"The
    total number of IPv6 established bgp sessions.","type":"integer"},"numberNotEstablishedV4":{"description":"The
    total number of IPv4 non-established bgp sessions.","type":"integer"},"numberNotEstablishedV6":{"description":"The
    total number of IPv6 non-established bgp sessions.","type":"integer"},"peersV4":{"description":"PeersV4
    represents IPv4 BGP peers status on the node.","items":{"description":"CalicoNodePeer
    contains the status of BGP peers on the node.","properties":{"peerIP":{"description":"IP
    address of the peer whose condition we are reporting.","type":"string"},"since":{"description":"Since
    the state or reason last changed.","type":"string"},"state":{"description":"State
    is the BGP session state.","type":"string"},"type":{"description":"Type indicates
    whether this peer is configured via the node-to-node mesh, or via en explicit
    global or per-node BGPPeer object.","type":"string"}},"type":"object"},"type":"array"},"peersV6":{"description":"PeersV6
    represents IPv6 BGP peers status on the node.","items":{"description":"CalicoNodePeer
    contains the status of BGP peers on the node.","properties":{"peerIP":{"description":"IP
    address of the peer whose condition we are reporting.","type":"string"},"since":{"description":"Since
    the state or reason last changed.","type":"string"},"state":{"description":"State
    is the BGP session state.","type":"string"},"type":{"description":"Type indicates
    whether this peer is configured via the node-to-node mesh, or via en explicit
    global or per-node BGPPeer object.","type":"string"}},"type":"object"},"type":"array"}},"required":["numberEstablishedV4","numberEstablishedV6","numberNotEstablishedV4","numberNotEstablishedV6"],"type":"object"},"lastUpdated":{"description":"LastUpdated
    is a timestamp representing the server time when CalicoNodeStatus object last
    updated. It is represented in RFC3339 form and is in UTC.","format":"date-time","nullable":true,"type":"string"},"routes":{"description":"Routes
    reports routes known to the Calico BGP daemon on the node.","properties":{"routesV4":{"description":"RoutesV4
    represents IPv4 routes on the node.","items":{"description":"CalicoNodeRoute contains
    the status of BGP routes on the node.","properties":{"destination":{"description":"Destination
    of the route.","type":"string"},"gateway":{"description":"Gateway for the destination.","type":"string"},"interface":{"description":"Interface
    for the destination","type":"string"},"learnedFrom":{"description":"LearnedFrom
    contains information regarding where this route originated.","properties":{"peerIP":{"description":"If
    sourceType is NodeMesh or BGPPeer, IP address of the router that sent us this
    route.","type":"string"},"sourceType":{"description":"Type of the source where
    a route is learned from.","type":"string"}},"type":"object"},"type":{"description":"Type
    indicates if the route is being used for forwarding or not.","type":"string"}},"type":"object"},"type":"array"},"routesV6":{"description":"RoutesV6
    represents IPv6 routes on the node.","items":{"description":"CalicoNodeRoute contains
    the status of BGP routes on the node.","properties":{"destination":{"description":"Destination
    of the route.","type":"string"},"gateway":{"description":"Gateway for the destination.","type":"string"},"interface":{"description":"Interface
    for the destination","type":"string"},"learnedFrom":{"description":"LearnedFrom
    contains information regarding where this route originated.","properties":{"peerIP":{"description":"If
    sourceType is NodeMesh or BGPPeer, IP address of the router that sent us this
    route.","type":"string"},"sourceType":{"description":"Type of the source where
    a route is learned from.","type":"string"}},"type":"object"},"type":{"description":"Type
    indicates if the route is being used for forwarding or not.","type":"string"}},"type":"object"},"type":"array"}},"type":"object"}},"type":"object"}},"type":"object"}},"served":true,"storage":true}]},"status":{"acceptedNames":{"kind":"","plural":""},"conditions":[],"storedVersions":[]}},{"apiVersion":"apiextensions.k8s.io/v1","kind":"CustomResourceDefinition","metadata":{"name":"clusterinformations.crd.projectcalico.org"},"spec":{"group":"crd.projectcalico.org","names":{"kind":"ClusterInformation","listKind":"ClusterInformationList","plural":"clusterinformations","singular":"clusterinformation"},"preserveUnknownFields":false,"scope":"Cluster","versions":[{"name":"v1","schema":{"openAPIV3Schema":{"description":"ClusterInformation
    contains the cluster specific information.","properties":{"apiVersion":{"description":"APIVersion
    defines the versioned schema of this representation of an object. Servers should
    convert recognized schemas to the latest internal value, and may reject unrecognized
    values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","type":"string"},"kind":{"description":"Kind
    is a string value representing the REST resource this object represents. Servers
    may infer this from the endpoint the client submits requests to. Cannot be updated.
    In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","type":"string"},"metadata":{"type":"object"},"spec":{"description":"ClusterInformationSpec
    contains the values of describing the cluster.","properties":{"calicoVersion":{"description":"CalicoVersion
    is the version of Calico that the cluster is running","type":"string"},"clusterGUID":{"description":"ClusterGUID
    is the GUID of the cluster","type":"string"},"clusterType":{"description":"ClusterType
    describes the type of the cluster","type":"string"},"datastoreReady":{"description":"DatastoreReady
    is used during significant datastore migrations to signal to components such as
    Felix that it should wait before accessing the datastore.","type":"boolean"},"variant":{"description":"Variant
    declares which variant of Calico should be active.","type":"string"}},"type":"object"}},"type":"object"}},"served":true,"storage":true}]},"status":{"acceptedNames":{"kind":"","plural":""},"conditions":[],"storedVersions":[]}},{"apiVersion":"apiextensions.k8s.io/v1","kind":"CustomResourceDefinition","metadata":{"name":"felixconfigurations.crd.projectcalico.org"},"spec":{"group":"crd.projectcalico.org","names":{"kind":"FelixConfiguration","listKind":"FelixConfigurationList","plural":"felixconfigurations","singular":"felixconfiguration"},"preserveUnknownFields":false,"scope":"Cluster","versions":[{"name":"v1","schema":{"openAPIV3Schema":{"description":"Felix
    Configuration contains the configuration for Felix.","properties":{"apiVersion":{"description":"APIVersion
    defines the versioned schema of this representation of an object. Servers should
    convert recognized schemas to the latest internal value, and may reject unrecognized
    values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","type":"string"},"kind":{"description":"Kind
    is a string value representing the REST resource this object represents. Servers
    may infer this from the endpoint the client submits requests to. Cannot be updated.
    In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","type":"string"},"metadata":{"type":"object"},"spec":{"description":"FelixConfigurationSpec
    contains the values of the Felix configuration.","properties":{"allowIPIPPacketsFromWorkloads":{"description":"AllowIPIPPacketsFromWorkloads
    controls whether Felix will add a rule to drop IPIP encapsulated traffic from
    workloads [Default: false]","type":"boolean"},"allowVXLANPacketsFromWorkloads":{"description":"AllowVXLANPacketsFromWorkloads
    controls whether Felix will add a rule to drop VXLAN encapsulated traffic from
    workloads [Default: false]","type":"boolean"},"awsSrcDstCheck":{"description":"Set
    source-destination-check on AWS EC2 instances. Accepted value must be one of \"DoNothing\",
    \"Enable\" or \"Disable\". [Default: DoNothing]","enum":["DoNothing","Enable","Disable"],"type":"string"},"bpfCTLBLogFilter":{"description":"BPFCTLBLogFilter
    specifies, what is logged by connect time load balancer when BPFLogLevel is debug.
    Currently has to be specified as ''all'' when BPFLogFilters is set to see CTLB
    logs. [Default: unset - means logs are emitted when BPFLogLevel id debug and BPFLogFilters
    not set.]","type":"string"},"bpfConnectTimeLoadBalancing":{"description":"BPFConnectTimeLoadBalancing
    when in BPF mode, controls whether Felix installs the connect-time load balancer.
    The connect-time load balancer is required for the host to be able to reach Kubernetes
    services and it improves the performance of pod-to-service connections.When set
    to TCP, connect time load balancing is available only for services with TCP ports.
    [Default: TCP]","enum":["TCP","Enabled","Disabled"],"type":"string"},"bpfConnectTimeLoadBalancingEnabled":{"description":"BPFConnectTimeLoadBalancingEnabled
    when in BPF mode, controls whether Felix installs the connection-time load balancer.  The
    connect-time load balancer is required for the host to be able to reach Kubernetes
    services and it improves the performance of pod-to-service connections.  The only
    reason to disable it is for debugging purposes. This will be deprecated. Use BPFConnectTimeLoadBalancing
    [Default: true]","type":"boolean"},"bpfDSROptoutCIDRs":{"description":"BPFDSROptoutCIDRs
    is a list of CIDRs which are excluded from DSR. That is, clients in those CIDRs
    will accesses nodeports as if BPFExternalServiceMode was set to Tunnel.","items":{"type":"string"},"type":"array"},"bpfDataIfacePattern":{"description":"BPFDataIfacePattern
    is a regular expression that controls which interfaces Felix should attach BPF
    programs to in order to catch traffic to/from the network.  This needs to match
    the interfaces that Calico workload traffic flows over as well as any interfaces
    that handle incoming traffic to nodeports and services from outside the cluster.  It
    should not match the workload interfaces (usually named cali...).","type":"string"},"bpfDisableGROForIfaces":{"description":"BPFDisableGROForIfaces
    is a regular expression that controls which interfaces Felix should disable the
    Generic Receive Offload [GRO] option.  It should not match the workload interfaces
    (usually named cali...).","type":"string"},"bpfDisableUnprivileged":{"description":"BPFDisableUnprivileged,
    if enabled, Felix sets the kernel.unprivileged_bpf_disabled sysctl to disable
    unprivileged use of BPF.  This ensures that unprivileged users cannot access Calico''s
    BPF maps and cannot insert their own BPF programs to interfere with Calico''s.
    [Default: true]","type":"boolean"},"bpfEnabled":{"description":"BPFEnabled, if
    enabled Felix will use the BPF dataplane. [Default: false]","type":"boolean"},"bpfEnforceRPF":{"description":"BPFEnforceRPF
    enforce strict RPF on all host interfaces with BPF programs regardless of what
    is the per-interfaces or global setting. Possible values are Disabled, Strict
    or Loose. [Default: Loose]","pattern":"^(?i)(Disabled|Strict|Loose)?$","type":"string"},"bpfExcludeCIDRsFromNAT":{"description":"BPFExcludeCIDRsFromNAT
    is a list of CIDRs that are to be excluded from NAT resolution so that host can
    handle them. A typical usecase is node local DNS cache.","items":{"type":"string"},"type":"array"},"bpfExtToServiceConnmark":{"description":"BPFExtToServiceConnmark
    in BPF mode, control a 32bit mark that is set on connections from an external
    client to a local service. This mark allows us to control how packets of that
    connection are routed within the host and how is routing interpreted by RPF check.
    [Default: 0]","type":"integer"},"bpfExternalServiceMode":{"description":"BPFExternalServiceMode
    in BPF mode, controls how connections from outside the cluster to services (node
    ports and cluster IPs) are forwarded to remote workloads.  If set to \"Tunnel\"
    then both request and response traffic is tunneled to the remote node.  If set
    to \"DSR\", the request traffic is tunneled but the response traffic is sent directly
    from the remote node.  In \"DSR\" mode, the remote node appears to use the IP
    of the ingress node; this requires a permissive L2 network.  [Default: Tunnel]","pattern":"^(?i)(Tunnel|DSR)?$","type":"string"},"bpfForceTrackPacketsFromIfaces":{"description":"BPFForceTrackPacketsFromIfaces
    in BPF mode, forces traffic from these interfaces to skip Calico''s iptables NOTRACK
    rule, allowing traffic from those interfaces to be tracked by Linux conntrack.  Should
    only be used for interfaces that are not used for the Calico fabric.  For example,
    a docker bridge device for non-Calico-networked containers. [Default: docker+]","items":{"type":"string"},"type":"array"},"bpfHostConntrackBypass":{"description":"BPFHostConntrackBypass
    Controls whether to bypass Linux conntrack in BPF mode for workloads and services.
    [Default: true - bypass Linux conntrack]","type":"boolean"},"bpfHostNetworkedNATWithoutCTLB":{"description":"BPFHostNetworkedNATWithoutCTLB
    when in BPF mode, controls whether Felix does a NAT without CTLB. This along with
    BPFConnectTimeLoadBalancing determines the CTLB behavior. [Default: Enabled]","enum":["Enabled","Disabled"],"type":"string"},"bpfKubeProxyEndpointSlicesEnabled":{"description":"BPFKubeProxyEndpointSlicesEnabled
    is deprecated and has no effect. BPF kube-proxy always accepts endpoint slices.
    This option will be removed in the next release.","type":"boolean"},"bpfKubeProxyIptablesCleanupEnabled":{"description":"BPFKubeProxyIptablesCleanupEnabled,
    if enabled in BPF mode, Felix will proactively clean up the upstream Kubernetes
    kube-proxy''s iptables chains.  Should only be enabled if kube-proxy is not running.  [Default:
    true]","type":"boolean"},"bpfKubeProxyMinSyncPeriod":{"description":"BPFKubeProxyMinSyncPeriod,
    in BPF mode, controls the minimum time between updates to the dataplane for Felix''s
    embedded kube-proxy.  Lower values give reduced set-up latency.  Higher values
    reduce Felix CPU usage by batching up more work.  [Default: 1s]","pattern":"^([0-9]+(\\\\.[0-9]+)?(ms|s|m|h))*$","type":"string"},"bpfL3IfacePattern":{"description":"BPFL3IfacePattern
    is a regular expression that allows to list tunnel devices like wireguard or vxlan
    (i.e., L3 devices) in addition to BPFDataIfacePattern. That is, tunnel interfaces
    not created by Calico, that Calico workload traffic flows over as well as any
    interfaces that handle incoming traffic to nodeports and services from outside
    the cluster.","type":"string"},"bpfLogFilters":{"additionalProperties":{"type":"string"},"description":"BPFLogFilters
    is a map of key=values where the value is a pcap filter expression and the key
    is an interface name with ''all'' denoting all interfaces, ''weps'' all workload
    endpoints and ''heps'' all host endpoints. \n When specified as an env var, it
    accepts a comma-separated list of key=values. [Default: unset - means all debug
    logs are emitted]","type":"object"},"bpfLogLevel":{"description":"BPFLogLevel
    controls the log level of the BPF programs when in BPF dataplane mode.  One of
    \"Off\", \"Info\", or \"Debug\".  The logs are emitted to the BPF trace pipe,
    accessible with the command `tc exec bpf debug`. [Default: Off].","pattern":"^(?i)(Off|Info|Debug)?$","type":"string"},"bpfMapSizeConntrack":{"description":"BPFMapSizeConntrack
    sets the size for the conntrack map.  This map must be large enough to hold an
    entry for each active connection.  Warning: changing the size of the conntrack
    map can cause disruption.","type":"integer"},"bpfMapSizeIPSets":{"description":"BPFMapSizeIPSets
    sets the size for ipsets map.  The IP sets map must be large enough to hold an
    entry for each endpoint matched by every selector in the source/destination matches
    in network policy.  Selectors such as \"all()\" can result in large numbers of
    entries (one entry per endpoint in that case).","type":"integer"},"bpfMapSizeIfState":{"description":"BPFMapSizeIfState
    sets the size for ifstate map.  The ifstate map must be large enough to hold an
    entry for each device (host + workloads) on a host.","type":"integer"},"bpfMapSizeNATAffinity":{"type":"integer"},"bpfMapSizeNATBackend":{"description":"BPFMapSizeNATBackend
    sets the size for nat back end map. This is the total number of endpoints. This
    is mostly more than the size of the number of services.","type":"integer"},"bpfMapSizeNATFrontend":{"description":"BPFMapSizeNATFrontend
    sets the size for nat front end map. FrontendMap should be large enough to hold
    an entry for each nodeport, external IP and each port in each service.","type":"integer"},"bpfMapSizeRoute":{"description":"BPFMapSizeRoute
    sets the size for the routes map.  The routes map should be large enough to hold
    one entry per workload and a handful of entries per host (enough to cover its
    own IPs and tunnel IPs).","type":"integer"},"bpfPSNATPorts":{"anyOf":[{"type":"integer"},{"type":"string"}],"description":"BPFPSNATPorts
    sets the range from which we randomly pick a port if there is a source port collision.
    This should be within the ephemeral range as defined by RFC 6056 (102465535)
    and preferably outside the  ephemeral ranges used by common operating systems.
    Linux uses 3276860999, while others mostly use the IANA defined range 4915265535.
    It is not necessarily a problem if this range overlaps with the operating systems.
    Both ends of the range are inclusive. [Default: 20000:29999]","pattern":"^.*","x-kubernetes-int-or-string":true},"bpfPolicyDebugEnabled":{"description":"BPFPolicyDebugEnabled
    when true, Felix records detailed information about the BPF policy programs, which
    can be examined with the calico-bpf command-line tool.","type":"boolean"},"bpfRedirectToPeer":{"description":"BPFRedirectToPeer
    controls which whether it is allowed to forward straight to the peer side of the
    workload devices. It is allowed for any host L2 devices by default (L2Only), but
    it breaks TCP dump on the host side of workload device as it bypasses it on ingress.
    Value of Enabled also allows redirection from L3 host devices like IPIP tunnel
    or Wireguard directly to the peer side of the workload''s device. This makes redirection
    faster, however, it breaks tools like tcpdump on the peer side. Use Enabled with
    caution. [Default: L2Only]","type":"string"},"chainInsertMode":{"description":"ChainInsertMode
    controls whether Felix hooks the kernel''s top-level iptables chains by inserting
    a rule at the top of the chain or by appending a rule at the bottom. insert is
    the safe default since it prevents Calico''s rules from being bypassed. If you
    switch to append mode, be sure that the other rules in the chains signal acceptance
    by falling through to the Calico rules, otherwise the Calico policy will be bypassed.
    [Default: insert]","pattern":"^(?i)(insert|append)?$","type":"string"},"dataplaneDriver":{"description":"DataplaneDriver
    filename of the external dataplane driver to use.  Only used if UseInternalDataplaneDriver
    is set to false.","type":"string"},"dataplaneWatchdogTimeout":{"description":"DataplaneWatchdogTimeout
    is the readiness/liveness timeout used for Felix''s (internal) dataplane driver.
    Increase this value if you experience spurious non-ready or non-live events when
    Felix is under heavy load. Decrease the value to get felix to report non-live
    or non-ready more quickly. [Default: 90s] \n Deprecated: replaced by the generic
    HealthTimeoutOverrides.","type":"string"},"debugDisableLogDropping":{"type":"boolean"},"debugHost":{"description":"DebugHost
    is the host IP or hostname to bind the debug port to.  Only used if DebugPort
    is set. [Default:localhost]","type":"string"},"debugMemoryProfilePath":{"type":"string"},"debugPort":{"description":"DebugPort
    if set, enables Felix''s debug HTTP port, which allows memory and CPU profiles
    to be retrieved.  The debug port is not secure, it should not be exposed to the
    internet.","type":"integer"},"debugSimulateCalcGraphHangAfter":{"pattern":"^([0-9]+(\\\\.[0-9]+)?(ms|s|m|h))*$","type":"string"},"debugSimulateDataplaneApplyDelay":{"pattern":"^([0-9]+(\\\\.[0-9]+)?(ms|s|m|h))*$","type":"string"},"debugSimulateDataplaneHangAfter":{"pattern":"^([0-9]+(\\\\.[0-9]+)?(ms|s|m|h))*$","type":"string"},"defaultEndpointToHostAction":{"description":"DefaultEndpointToHostAction
    controls what happens to traffic that goes from a workload endpoint to the host
    itself (after the traffic hits the endpoint egress policy). By default Calico
    blocks traffic from workload endpoints to the host itself with an iptables \"DROP\"
    action. If you want to allow some or all traffic from endpoint to host, set this
    parameter to RETURN or ACCEPT. Use RETURN if you have your own rules in the iptables
    \"INPUT\" chain; Calico will insert its rules at the top of that chain, then \"RETURN\"
    packets to the \"INPUT\" chain once it has completed processing workload endpoint
    egress policy. Use ACCEPT to unconditionally accept packets from workloads after
    processing workload endpoint egress policy. [Default: Drop]","pattern":"^(?i)(Drop|Accept|Return)?$","type":"string"},"deviceRouteProtocol":{"description":"This
    defines the route protocol added to programmed device routes, by default this
    will be RTPROT_BOOT when left blank.","type":"integer"},"deviceRouteSourceAddress":{"description":"This
    is the IPv4 source address to use on programmed device routes. By default the
    source address is left blank, leaving the kernel to choose the source address
    used.","type":"string"},"deviceRouteSourceAddressIPv6":{"description":"This is
    the IPv6 source address to use on programmed device routes. By default the source
    address is left blank, leaving the kernel to choose the source address used.","type":"string"},"disableConntrackInvalidCheck":{"type":"boolean"},"endpointReportingDelay":{"pattern":"^([0-9]+(\\\\.[0-9]+)?(ms|s|m|h))*$","type":"string"},"endpointReportingEnabled":{"type":"boolean"},"endpointStatusPathPrefix":{"description":"EndpointStatusPathPrefix
    is the path to the directory where endpoint status will be written. Endpoint status
    file reporting is disabled if field is left empty. \n Chosen directory should
    match the directory used by the CNI for PodStartupDelay. [Default: \"\"]","type":"string"},"externalNodesList":{"description":"ExternalNodesCIDRList
    is a list of CIDR''s of external-non-calico-nodes which may source tunnel traffic
    and have the tunneled traffic be accepted at calico nodes.","items":{"type":"string"},"type":"array"},"failsafeInboundHostPorts":{"description":"FailsafeInboundHostPorts
    is a list of PortProto struct objects including UDP/TCP/SCTP ports and CIDRs that
    Felix will allow incoming traffic to host endpoints on irrespective of the security
    policy. This is useful to avoid accidentally cutting off a host with incorrect
    configuration. For backwards compatibility, if the protocol is not specified,
    it defaults to \"tcp\". If a CIDR is not specified, it will allow traffic from
    all addresses. To disable all inbound host ports, use the value \"[]\". The default
    value allows ssh access, DHCP, BGP, etcd and the Kubernetes API. [Default: tcp:22,
    udp:68, tcp:179, tcp:2379, tcp:2380, tcp:5473, tcp:6443, tcp:6666, tcp:6667 ]","items":{"description":"ProtoPort
    is combination of protocol, port, and CIDR. Protocol and port must be specified.","properties":{"net":{"type":"string"},"port":{"type":"integer"},"protocol":{"type":"string"}},"required":["port","protocol"],"type":"object"},"type":"array"},"failsafeOutboundHostPorts":{"description":"FailsafeOutboundHostPorts
    is a list of List of PortProto struct objects including UDP/TCP/SCTP ports and
    CIDRs that Felix will allow outgoing traffic from host endpoints to irrespective
    of the security policy. This is useful to avoid accidentally cutting off a host
    with incorrect configuration. For backwards compatibility, if the protocol is
    not specified, it defaults to \"tcp\". If a CIDR is not specified, it will allow
    traffic from all addresses. To disable all outbound host ports, use the value
    \"[]\". The default value opens etcd''s standard ports to ensure that Felix does
    not get cut off from etcd as well as allowing DHCP, DNS, BGP and the Kubernetes
    API. [Default: udp:53, udp:67, tcp:179, tcp:2379, tcp:2380, tcp:5473, tcp:6443,
    tcp:6666, tcp:6667 ]","items":{"description":"ProtoPort is combination of protocol,
    port, and CIDR. Protocol and port must be specified.","properties":{"net":{"type":"string"},"port":{"type":"integer"},"protocol":{"type":"string"}},"required":["port","protocol"],"type":"object"},"type":"array"},"featureDetectOverride":{"description":"FeatureDetectOverride
    is used to override feature detection based on auto-detected platform capabilities.  Values
    are specified in a comma separated list with no spaces, example; \"SNATFullyRandom=true,MASQFullyRandom=false,RestoreSupportsLock=\".  \"true\"
    or \"false\" will force the feature, empty or omitted values are auto-detected.","pattern":"^([a-zA-Z0-9-_]+=(true|false|),)*([a-zA-Z0-9-_]+=(true|false|))?$","type":"string"},"featureGates":{"description":"FeatureGates
    is used to enable or disable tech-preview Calico features. Values are specified
    in a comma separated list with no spaces, example; \"BPFConnectTimeLoadBalancingWorkaround=enabled,XyZ=false\".
    This is used to enable features that are not fully production ready.","pattern":"^([a-zA-Z0-9-_]+=([^=]+),)*([a-zA-Z0-9-_]+=([^=]+))?$","type":"string"},"floatingIPs":{"description":"FloatingIPs
    configures whether or not Felix will program non-OpenStack floating IP addresses.  (OpenStack-derived
    floating IPs are always programmed, regardless of this setting.)","enum":["Enabled","Disabled"],"type":"string"},"genericXDPEnabled":{"description":"GenericXDPEnabled
    enables Generic XDP so network cards that don''t support XDP offload or driver
    modes can use XDP. This is not recommended since it doesn''t provide better performance
    than iptables. [Default: false]","type":"boolean"},"goGCThreshold":{"description":"GoGCThreshold
    Sets the Go runtime''s garbage collection threshold.  I.e. the percentage that
    the heap is allowed to grow before garbage collection is triggered.  In general,
    doubling the value halves the CPU time spent doing GC, but it also doubles peak
    GC memory overhead.  A special value of -1 can be used to disable GC entirely;
    this should only be used in conjunction with the GoMemoryLimitMB setting. \n This
    setting is overridden by the GOGC environment variable. \n [Default: 40]","type":"integer"},"goMaxProcs":{"description":"GoMaxProcs
    sets the maximum number of CPUs that the Go runtime will use concurrently.  A
    value of -1 means \"use the system default\"; typically the number of real CPUs
    on the system. \n this setting is overridden by the GOMAXPROCS environment variable.
    \n [Default: -1]","type":"integer"},"goMemoryLimitMB":{"description":"GoMemoryLimitMB
    sets a (soft) memory limit for the Go runtime in MB.  The Go runtime will try
    to keep its memory usage under the limit by triggering GC as needed.  To avoid
    thrashing, it will exceed the limit if GC starts to take more than 50% of the
    process''s CPU time.  A value of -1 disables the memory limit. \n Note that the
    memory limit, if used, must be considerably less than any hard resource limit
    set at the container or pod level.  This is because felix is not the only process
    that must run in the container or pod. \n This setting is overridden by the GOMEMLIMIT
    environment variable. \n [Default: -1]","type":"integer"},"healthEnabled":{"type":"boolean"},"healthHost":{"type":"string"},"healthPort":{"type":"integer"},"healthTimeoutOverrides":{"description":"HealthTimeoutOverrides
    allows the internal watchdog timeouts of individual subcomponents to be overridden.  This
    is useful for working around \"false positive\" liveness timeouts that can occur
    in particularly stressful workloads or if CPU is constrained.  For a list of active
    subcomponents, see Felix''s logs.","items":{"properties":{"name":{"type":"string"},"timeout":{"type":"string"}},"required":["name","timeout"],"type":"object"},"type":"array"},"interfaceExclude":{"description":"InterfaceExclude
    is a comma-separated list of interfaces that Felix should exclude when monitoring
    for host endpoints. The default value ensures that Felix ignores Kubernetes''
    IPVS dummy interface, which is used internally by kube-proxy. If you want to exclude
    multiple interface names using a single value, the list supports regular expressions.
    For regular expressions you must wrap the value with ''/''. For example having
    values ''/^kube/,veth1'' will exclude all interfaces that begin with ''kube''
    and also the interface ''veth1''. [Default: kube-ipvs0]","type":"string"},"interfacePrefix":{"description":"InterfacePrefix
    is the interface name prefix that identifies workload endpoints and so distinguishes
    them from host endpoint interfaces. Note: in environments other than bare metal,
    the orchestrators configure this appropriately. For example our Kubernetes and
    Docker integrations set the ''cali'' value, and our OpenStack integration sets
    the ''tap'' value. [Default: cali]","type":"string"},"interfaceRefreshInterval":{"description":"InterfaceRefreshInterval
    is the period at which Felix rescans local interfaces to verify their state. The
    rescan can be disabled by setting the interval to 0.","pattern":"^([0-9]+(\\\\.[0-9]+)?(ms|s|m|h))*$","type":"string"},"ipForwarding":{"description":"IPForwarding
    controls whether Felix sets the host sysctls to enable IP forwarding.  IP forwarding
    is required when using Calico for workload networking.  This should only be disabled
    on hosts where Calico is used for host protection.  [Default: Enabled]","enum":["Enabled","Disabled"],"type":"string"},"ipipEnabled":{"description":"IPIPEnabled
    overrides whether Felix should configure an IPIP interface on the host. Optional
    as Felix determines this based on the existing IP pools. [Default: nil (unset)]","type":"boolean"},"ipipMTU":{"description":"IPIPMTU
    is the MTU to set on the tunnel device. See Configuring MTU [Default: 1440]","type":"integer"},"ipsetsRefreshInterval":{"description":"IpsetsRefreshInterval
    is the period at which Felix re-checks all iptables state to ensure that no other
    process has accidentally broken Calico''s rules. Set to 0 to disable iptables
    refresh. [Default: 90s]","pattern":"^([0-9]+(\\\\.[0-9]+)?(ms|s|m|h))*$","type":"string"},"iptablesBackend":{"description":"IptablesBackend
    specifies which backend of iptables will be used. The default is Auto.","pattern":"^(?i)(Auto|FelixConfiguration|FelixConfigurationList|Legacy|NFT)?$","type":"string"},"iptablesFilterAllowAction":{"pattern":"^(?i)(Accept|Return)?$","type":"string"},"iptablesFilterDenyAction":{"description":"IptablesFilterDenyAction
    controls what happens to traffic that is denied by network policy. By default
    Calico blocks traffic with an iptables \"DROP\" action. If you want to use \"REJECT\"
    action instead you can configure it in here.","pattern":"^(?i)(Drop|Reject)?$","type":"string"},"iptablesLockFilePath":{"description":"IptablesLockFilePath
    is the location of the iptables lock file. You may need to change this if the
    lock file is not in its standard location (for example if you have mapped it into
    Felix''s container at a different path). [Default: /run/xtables.lock]","type":"string"},"iptablesLockProbeInterval":{"description":"IptablesLockProbeInterval
    is the time that Felix will wait between attempts to acquire the iptables lock
    if it is not available. Lower values make Felix more responsive when the lock
    is contended, but use more CPU. [Default: 50ms]","pattern":"^([0-9]+(\\\\.[0-9]+)?(ms|s|m|h))*$","type":"string"},"iptablesLockTimeout":{"description":"IptablesLockTimeout
    is the time that Felix will wait for the iptables lock, or 0, to disable. To use
    this feature, Felix must share the iptables lock file with all other processes
    that also take the lock. When running Felix inside a container, this requires
    the /run directory of the host to be mounted into the calico/node or calico/felix
    container. [Default: 0s disabled]","pattern":"^([0-9]+(\\\\.[0-9]+)?(ms|s|m|h))*$","type":"string"},"iptablesMangleAllowAction":{"pattern":"^(?i)(Accept|Return)?$","type":"string"},"iptablesMarkMask":{"description":"IptablesMarkMask
    is the mask that Felix selects its IPTables Mark bits from. Should be a 32 bit
    hexadecimal number with at least 8 bits set, none of which clash with any other
    mark bits in use on the system. [Default: 0xff000000]","format":"int32","type":"integer"},"iptablesNATOutgoingInterfaceFilter":{"type":"string"},"iptablesPostWriteCheckInterval":{"description":"IptablesPostWriteCheckInterval
    is the period after Felix has done a write to the dataplane that it schedules
    an extra read back in order to check the write was not clobbered by another process.
    This should only occur if another application on the system doesn''t respect the
    iptables lock. [Default: 1s]","pattern":"^([0-9]+(\\\\.[0-9]+)?(ms|s|m|h))*$","type":"string"},"iptablesRefreshInterval":{"description":"IptablesRefreshInterval
    is the period at which Felix re-checks the IP sets in the dataplane to ensure
    that no other process has accidentally broken Calico''s rules. Set to 0 to disable
    IP sets refresh. Note: the default for this value is lower than the other refresh
    intervals as a workaround for a Linux kernel bug that was fixed in kernel version
    4.11. If you are using v4.11 or greater you may want to set this to, a higher
    value to reduce Felix CPU usage. [Default: 10s]","pattern":"^([0-9]+(\\\\.[0-9]+)?(ms|s|m|h))*$","type":"string"},"ipv6Support":{"description":"IPv6Support
    controls whether Felix enables support for IPv6 (if supported by the in-use dataplane).","type":"boolean"},"kubeNodePortRanges":{"description":"KubeNodePortRanges
    holds list of port ranges used for service node ports. Only used if felix detects
    kube-proxy running in ipvs mode. Felix uses these ranges to separate host and
    workload traffic. [Default: 30000:32767].","items":{"anyOf":[{"type":"integer"},{"type":"string"}],"pattern":"^.*","x-kubernetes-int-or-string":true},"type":"array"},"logDebugFilenameRegex":{"description":"LogDebugFilenameRegex
    controls which source code files have their Debug log output included in the logs.
    Only logs from files with names that match the given regular expression are included.  The
    filter only applies to Debug level logs.","type":"string"},"logFilePath":{"description":"LogFilePath
    is the full path to the Felix log. Set to none to disable file logging. [Default:
    /var/log/calico/felix.log]","type":"string"},"logPrefix":{"description":"LogPrefix
    is the log prefix that Felix uses when rendering LOG rules. [Default: calico-packet]","type":"string"},"logSeverityFile":{"description":"LogSeverityFile
    is the log severity above which logs are sent to the log file. [Default: Info]","pattern":"^(?i)(Debug|Info|Warning|Error|Fatal)?$","type":"string"},"logSeverityScreen":{"description":"LogSeverityScreen
    is the log severity above which logs are sent to the stdout. [Default: Info]","pattern":"^(?i)(Debug|Info|Warning|Error|Fatal)?$","type":"string"},"logSeveritySys":{"description":"LogSeveritySys
    is the log severity above which logs are sent to the syslog. Set to None for no
    logging to syslog. [Default: Info]","pattern":"^(?i)(Debug|Info|Warning|Error|Fatal)?$","type":"string"},"maxIpsetSize":{"description":"MaxIpsetSize
    is the maximum number of IP addresses that can be stored in an IP set. Not applicable
    if using the nftables backend.","type":"integer"},"metadataAddr":{"description":"MetadataAddr
    is the IP address or domain name of the server that can answer VM queries for
    cloud-init metadata. In OpenStack, this corresponds to the machine running nova-api
    (or in Ubuntu, nova-api-metadata). A value of none (case-insensitive) means that
    Felix should not set up any NAT rule for the metadata path. [Default: 127.0.0.1]","type":"string"},"metadataPort":{"description":"MetadataPort
    is the port of the metadata server. This, combined with global.MetadataAddr (if
    not ''None''), is used to set up a NAT rule, from 169.254.169.254:80 to MetadataAddr:MetadataPort.
    In most cases this should not need to be changed [Default: 8775].","type":"integer"},"mtuIfacePattern":{"description":"MTUIfacePattern
    is a regular expression that controls which interfaces Felix should scan in order
    to calculate the host''s MTU. This should not match workload interfaces (usually
    named cali...).","type":"string"},"natOutgoingAddress":{"description":"NATOutgoingAddress
    specifies an address to use when performing source NAT for traffic in a natOutgoing
    pool that is leaving the network. By default the address used is an address on
    the interface the traffic is leaving on (ie it uses the iptables MASQUERADE target)","type":"string"},"natPortRange":{"anyOf":[{"type":"integer"},{"type":"string"}],"description":"NATPortRange
    specifies the range of ports that is used for port mapping when doing outgoing
    NAT. When unset the default behavior of the network stack is used.","pattern":"^.*","x-kubernetes-int-or-string":true},"netlinkTimeout":{"pattern":"^([0-9]+(\\\\.[0-9]+)?(ms|s|m|h))*$","type":"string"},"nftablesFilterAllowAction":{"pattern":"^(?i)(Accept|Return)?$","type":"string"},"nftablesFilterDenyAction":{"description":"FilterDenyAction
    controls what happens to traffic that is denied by network policy. By default
    Calico blocks traffic with a \"drop\" action. If you want to use a \"reject\"
    action instead you can configure it here.","pattern":"^(?i)(Drop|Reject)?$","type":"string"},"nftablesMangleAllowAction":{"pattern":"^(?i)(Accept|Return)?$","type":"string"},"nftablesMarkMask":{"description":"MarkMask
    is the mask that Felix selects its nftables Mark bits from. Should be a 32 bit
    hexadecimal number with at least 8 bits set, none of which clash with any other
    mark bits in use on the system. [Default: 0xffff0000]","format":"int32","type":"integer"},"nftablesMode":{"description":"NFTablesMode
    configures nftables support in Felix. [Default: Disabled]","type":"string"},"nftablesRefreshInterval":{"description":"NftablesRefreshInterval
    controls the interval at which Felix periodically refreshes the nftables rules.
    [Default: 90s]","type":"string"},"openstackRegion":{"description":"OpenstackRegion
    is the name of the region that a particular Felix belongs to. In a multi-region
    Calico/OpenStack deployment, this must be configured somehow for each Felix (here
    in the datamodel, or in felix.cfg or the environment on each compute node), and
    must match the [calico] openstack_region value configured in neutron.conf on each
    node. [Default: Empty]","type":"string"},"policySyncPathPrefix":{"description":"PolicySyncPathPrefix
    is used to by Felix to communicate policy changes to external services, like Application
    layer policy. [Default: Empty]","type":"string"},"prometheusGoMetricsEnabled":{"description":"PrometheusGoMetricsEnabled
    disables Go runtime metrics collection, which the Prometheus client does by default,
    when set to false. This reduces the number of metrics reported, reducing Prometheus
    load. [Default: true]","type":"boolean"},"prometheusMetricsEnabled":{"description":"PrometheusMetricsEnabled
    enables the Prometheus metrics server in Felix if set to true. [Default: false]","type":"boolean"},"prometheusMetricsHost":{"description":"PrometheusMetricsHost
    is the host that the Prometheus metrics server should bind to. [Default: empty]","type":"string"},"prometheusMetricsPort":{"description":"PrometheusMetricsPort
    is the TCP port that the Prometheus metrics server should bind to. [Default: 9091]","type":"integer"},"prometheusProcessMetricsEnabled":{"description":"PrometheusProcessMetricsEnabled
    disables process metrics collection, which the Prometheus client does by default,
    when set to false. This reduces the number of metrics reported, reducing Prometheus
    load. [Default: true]","type":"boolean"},"prometheusWireGuardMetricsEnabled":{"description":"PrometheusWireGuardMetricsEnabled
    disables wireguard metrics collection, which the Prometheus client does by default,
    when set to false. This reduces the number of metrics reported, reducing Prometheus
    load. [Default: true]","type":"boolean"},"removeExternalRoutes":{"description":"Whether
    or not to remove device routes that have not been programmed by Felix. Disabling
    this will allow external applications to also add device routes. This is enabled
    by default which means we will remove externally added routes.","type":"boolean"},"reportingInterval":{"description":"ReportingInterval
    is the interval at which Felix reports its status into the datastore or 0 to disable.
    Must be non-zero in OpenStack deployments. [Default: 30s]","pattern":"^([0-9]+(\\\\.[0-9]+)?(ms|s|m|h))*$","type":"string"},"reportingTTL":{"description":"ReportingTTL
    is the time-to-live setting for process-wide status reports. [Default: 90s]","pattern":"^([0-9]+(\\\\.[0-9]+)?(ms|s|m|h))*$","type":"string"},"routeRefreshInterval":{"description":"RouteRefreshInterval
    is the period at which Felix re-checks the routes in the dataplane to ensure that
    no other process has accidentally broken Calico''s rules. Set to 0 to disable
    route refresh. [Default: 90s]","pattern":"^([0-9]+(\\\\.[0-9]+)?(ms|s|m|h))*$","type":"string"},"routeSource":{"description":"RouteSource
    configures where Felix gets its routing information. - WorkloadIPs: use workload
    endpoints to construct routes. - CalicoIPAM: the default - use IPAM data to construct
    routes.","pattern":"^(?i)(WorkloadIPs|CalicoIPAM)?$","type":"string"},"routeSyncDisabled":{"description":"RouteSyncDisabled
    will disable all operations performed on the route table. Set to true to run in
    network-policy mode only.","type":"boolean"},"routeTableRange":{"description":"Deprecated
    in favor of RouteTableRanges. Calico programs additional Linux route tables for
    various purposes. RouteTableRange specifies the indices of the route tables that
    Calico should use.","properties":{"max":{"type":"integer"},"min":{"type":"integer"}},"required":["max","min"],"type":"object"},"routeTableRanges":{"description":"Calico
    programs additional Linux route tables for various purposes. RouteTableRanges
    specifies a set of table index ranges that Calico should use. Deprecates`RouteTableRange`,
    overrides `RouteTableRange`.","items":{"properties":{"max":{"type":"integer"},"min":{"type":"integer"}},"required":["max","min"],"type":"object"},"type":"array"},"serviceLoopPrevention":{"description":"When
    service IP advertisement is enabled, prevent routing loops to service IPs that
    are not in use, by dropping or rejecting packets that do not get DNAT''d by kube-proxy.
    Unless set to \"Disabled\", in which case such routing loops continue to be allowed.
    [Default: Drop]","pattern":"^(?i)(Drop|Reject|Disabled)?$","type":"string"},"sidecarAccelerationEnabled":{"description":"SidecarAccelerationEnabled
    enables experimental sidecar acceleration [Default: false]","type":"boolean"},"usageReportingEnabled":{"description":"UsageReportingEnabled
    reports anonymous Calico version number and cluster size to projectcalico.org.
    Logs warnings returned by the usage server. For example, if a significant security
    vulnerability has been discovered in the version of Calico being used. [Default:
    true]","type":"boolean"},"usageReportingInitialDelay":{"description":"UsageReportingInitialDelay
    controls the minimum delay before Felix makes a report. [Default: 300s]","pattern":"^([0-9]+(\\\\.[0-9]+)?(ms|s|m|h))*$","type":"string"},"usageReportingInterval":{"description":"UsageReportingInterval
    controls the interval at which Felix makes reports. [Default: 86400s]","pattern":"^([0-9]+(\\\\.[0-9]+)?(ms|s|m|h))*$","type":"string"},"useInternalDataplaneDriver":{"description":"UseInternalDataplaneDriver,
    if true, Felix will use its internal dataplane programming logic.  If false, it
    will launch an external dataplane driver and communicate with it over protobuf.","type":"boolean"},"vxlanEnabled":{"description":"VXLANEnabled
    overrides whether Felix should create the VXLAN tunnel device for IPv4 VXLAN networking.
    Optional as Felix determines this based on the existing IP pools. [Default: nil
    (unset)]","type":"boolean"},"vxlanMTU":{"description":"VXLANMTU is the MTU to
    set on the IPv4 VXLAN tunnel device. See Configuring MTU [Default: 1410]","type":"integer"},"vxlanMTUV6":{"description":"VXLANMTUV6
    is the MTU to set on the IPv6 VXLAN tunnel device. See Configuring MTU [Default:
    1390]","type":"integer"},"vxlanPort":{"type":"integer"},"vxlanVNI":{"type":"integer"},"windowsManageFirewallRules":{"description":"WindowsManageFirewallRules
    configures whether or not Felix will program Windows Firewall rules. (to allow
    inbound access to its own metrics ports) [Default: Disabled]","enum":["Enabled","Disabled"],"type":"string"},"wireguardEnabled":{"description":"WireguardEnabled
    controls whether Wireguard is enabled for IPv4 (encapsulating IPv4 traffic over
    an IPv4 underlay network). [Default: false]","type":"boolean"},"wireguardEnabledV6":{"description":"WireguardEnabledV6
    controls whether Wireguard is enabled for IPv6 (encapsulating IPv6 traffic over
    an IPv6 underlay network). [Default: false]","type":"boolean"},"wireguardHostEncryptionEnabled":{"description":"WireguardHostEncryptionEnabled
    controls whether Wireguard host-to-host encryption is enabled. [Default: false]","type":"boolean"},"wireguardInterfaceName":{"description":"WireguardInterfaceName
    specifies the name to use for the IPv4 Wireguard interface. [Default: wireguard.cali]","type":"string"},"wireguardInterfaceNameV6":{"description":"WireguardInterfaceNameV6
    specifies the name to use for the IPv6 Wireguard interface. [Default: wg-v6.cali]","type":"string"},"wireguardKeepAlive":{"description":"WireguardKeepAlive
    controls Wireguard PersistentKeepalive option. Set 0 to disable. [Default: 0]","pattern":"^([0-9]+(\\\\.[0-9]+)?(ms|s|m|h))*$","type":"string"},"wireguardListeningPort":{"description":"WireguardListeningPort
    controls the listening port used by IPv4 Wireguard. [Default: 51820]","type":"integer"},"wireguardListeningPortV6":{"description":"WireguardListeningPortV6
    controls the listening port used by IPv6 Wireguard. [Default: 51821]","type":"integer"},"wireguardMTU":{"description":"WireguardMTU
    controls the MTU on the IPv4 Wireguard interface. See Configuring MTU [Default:
    1440]","type":"integer"},"wireguardMTUV6":{"description":"WireguardMTUV6 controls
    the MTU on the IPv6 Wireguard interface. See Configuring MTU [Default: 1420]","type":"integer"},"wireguardRoutingRulePriority":{"description":"WireguardRoutingRulePriority
    controls the priority value to use for the Wireguard routing rule. [Default: 99]","type":"integer"},"wireguardThreadingEnabled":{"description":"WireguardThreadingEnabled
    controls whether Wireguard has NAPI threading enabled. [Default: false]","type":"boolean"},"workloadSourceSpoofing":{"description":"WorkloadSourceSpoofing
    controls whether pods can use the allowedSourcePrefixes annotation to send traffic
    with a source IP address that is not theirs. This is disabled by default. When
    set to \"Any\", pods can request any prefix.","pattern":"^(?i)(Disabled|Any)?$","type":"string"},"xdpEnabled":{"description":"XDPEnabled
    enables XDP acceleration for suitable untracked incoming deny rules. [Default:
    true]","type":"boolean"},"xdpRefreshInterval":{"description":"XDPRefreshInterval
    is the period at which Felix re-checks all XDP state to ensure that no other process
    has accidentally broken Calico''s BPF maps or attached programs. Set to 0 to disable
    XDP refresh. [Default: 90s]","pattern":"^([0-9]+(\\\\.[0-9]+)?(ms|s|m|h))*$","type":"string"}},"type":"object"}},"type":"object"}},"served":true,"storage":true}]},"status":{"acceptedNames":{"kind":"","plural":""},"conditions":[],"storedVersions":[]}},{"apiVersion":"apiextensions.k8s.io/v1","kind":"CustomResourceDefinition","metadata":{"name":"globalnetworkpolicies.crd.projectcalico.org"},"spec":{"group":"crd.projectcalico.org","names":{"kind":"GlobalNetworkPolicy","listKind":"GlobalNetworkPolicyList","plural":"globalnetworkpolicies","singular":"globalnetworkpolicy"},"preserveUnknownFields":false,"scope":"Cluster","versions":[{"name":"v1","schema":{"openAPIV3Schema":{"properties":{"apiVersion":{"description":"APIVersion
    defines the versioned schema of this representation of an object. Servers should
    convert recognized schemas to the latest internal value, and may reject unrecognized
    values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","type":"string"},"kind":{"description":"Kind
    is a string value representing the REST resource this object represents. Servers
    may infer this from the endpoint the client submits requests to. Cannot be updated.
    In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","type":"string"},"metadata":{"type":"object"},"spec":{"properties":{"applyOnForward":{"description":"ApplyOnForward
    indicates to apply the rules in this policy on forward traffic.","type":"boolean"},"doNotTrack":{"description":"DoNotTrack
    indicates whether packets matched by the rules in this policy should go through
    the data plane''s connection tracking, such as Linux conntrack.  If True, the
    rules in this policy are applied before any data plane connection tracking, and
    packets allowed by this policy are marked as not to be tracked.","type":"boolean"},"egress":{"description":"The
    ordered set of egress rules.  Each rule contains a set of packet match criteria
    and a corresponding action to apply.","items":{"description":"A Rule encapsulates
    a set of match criteria and an action.  Both selector-based security Policy and
    security Profiles reference rules - separated out as a list of rules for both
    ingress and egress packet matching. \n Each positive match criteria has a negated
    version, prefixed with \"Not\". All the match criteria within a rule must be satisfied
    for a packet to match. A single rule can contain the positive and negative version
    of a match and both must be satisfied for the rule to match.","properties":{"action":{"type":"string"},"destination":{"description":"Destination
    contains the match criteria that apply to destination entity.","properties":{"namespaceSelector":{"description":"NamespaceSelector
    is an optional field that contains a selector expression. Only traffic that originates
    from (or terminates at) endpoints within the selected namespaces will be matched.
    When both NamespaceSelector and another selector are defined on the same rule,
    then only workload endpoints that are matched by both selectors will be selected
    by the rule. \n For NetworkPolicy, an empty NamespaceSelector implies that the
    Selector is limited to selecting only workload endpoints in the same namespace
    as the NetworkPolicy. \n For NetworkPolicy, `global()` NamespaceSelector implies
    that the Selector is limited to selecting only GlobalNetworkSet or HostEndpoint.
    \n For GlobalNetworkPolicy, an empty NamespaceSelector implies the Selector applies
    to workload endpoints across all namespaces.","type":"string"},"nets":{"description":"Nets
    is an optional field that restricts the rule to only apply to traffic that originates
    from (or terminates at) IP addresses in any of the given subnets.","items":{"type":"string"},"type":"array"},"notNets":{"description":"NotNets
    is the negated version of the Nets field.","items":{"type":"string"},"type":"array"},"notPorts":{"description":"NotPorts
    is the negated version of the Ports field. Since only some protocols have ports,
    if any ports are specified it requires the Protocol match in the Rule to be set
    to \"TCP\" or \"UDP\".","items":{"anyOf":[{"type":"integer"},{"type":"string"}],"pattern":"^.*","x-kubernetes-int-or-string":true},"type":"array"},"notSelector":{"description":"NotSelector
    is the negated version of the Selector field.  See Selector field for subtleties
    with negated selectors.","type":"string"},"ports":{"description":"Ports is an
    optional field that restricts the rule to only apply to traffic that has a source
    (destination) port that matches one of these ranges/values. This value is a list
    of integers or strings that represent ranges of ports. \n Since only some protocols
    have ports, if any ports are specified it requires the Protocol match in the Rule
    to be set to \"TCP\" or \"UDP\".","items":{"anyOf":[{"type":"integer"},{"type":"string"}],"pattern":"^.*","x-kubernetes-int-or-string":true},"type":"array"},"selector":{"description":"Selector
    is an optional field that contains a selector expression (see Policy for sample
    syntax).  Only traffic that originates from (terminates at) endpoints matching
    the selector will be matched. \n Note that: in addition to the negated version
    of the Selector (see NotSelector below), the selector expression syntax itself
    supports negation.  The two types of negation are subtly different. One negates
    the set of matched endpoints, the other negates the whole match: \n \tSelector
    = \"!has(my_label)\" matches packets that are from other Calico-controlled \tendpoints
    that do not have the label \"my_label\". \n \tNotSelector = \"has(my_label)\"
    matches packets that are not from Calico-controlled \tendpoints that do have the
    label \"my_label\". \n The effect is that the latter will accept packets from
    non-Calico sources whereas the former is limited to packets from Calico-controlled
    endpoints.","type":"string"},"serviceAccounts":{"description":"ServiceAccounts
    is an optional field that restricts the rule to only apply to traffic that originates
    from (or terminates at) a pod running as a matching service account.","properties":{"names":{"description":"Names
    is an optional field that restricts the rule to only apply to traffic that originates
    from (or terminates at) a pod running as a service account whose name is in the
    list.","items":{"type":"string"},"type":"array"},"selector":{"description":"Selector
    is an optional field that restricts the rule to only apply to traffic that originates
    from (or terminates at) a pod running as a service account that matches the given
    label selector. If both Names and Selector are specified then they are AND''ed.","type":"string"}},"type":"object"},"services":{"description":"Services
    is an optional field that contains options for matching Kubernetes Services. If
    specified, only traffic that originates from or terminates at endpoints within
    the selected service(s) will be matched, and only to/from each endpoint''s port.
    \n Services cannot be specified on the same rule as Selector, NotSelector, NamespaceSelector,
    Nets, NotNets or ServiceAccounts. \n Ports and NotPorts can only be specified
    with Services on ingress rules.","properties":{"name":{"description":"Name specifies
    the name of a Kubernetes Service to match.","type":"string"},"namespace":{"description":"Namespace
    specifies the namespace of the given Service. If left empty, the rule will match
    within this policy''s namespace.","type":"string"}},"type":"object"}},"type":"object"},"http":{"description":"HTTP
    contains match criteria that apply to HTTP requests.","properties":{"methods":{"description":"Methods
    is an optional field that restricts the rule to apply only to HTTP requests that
    use one of the listed HTTP Methods (e.g. GET, PUT, etc.) Multiple methods are
    OR''d together.","items":{"type":"string"},"type":"array"},"paths":{"description":"Paths
    is an optional field that restricts the rule to apply to HTTP requests that use
    one of the listed HTTP Paths. Multiple paths are OR''d together. e.g: - exact:
    /foo - prefix: /bar NOTE: Each entry may ONLY specify either a `exact` or a `prefix`
    match. The validator will check for it.","items":{"description":"HTTPPath specifies
    an HTTP path to match. It may be either of the form: exact: <path>: which matches
    the path exactly or prefix: <path-prefix>: which matches the path prefix","properties":{"exact":{"type":"string"},"prefix":{"type":"string"}},"type":"object"},"type":"array"}},"type":"object"},"icmp":{"description":"ICMP
    is an optional field that restricts the rule to apply to a specific type and code
    of ICMP traffic.  This should only be specified if the Protocol field is set to
    \"ICMP\" or \"ICMPv6\".","properties":{"code":{"description":"Match on a specific
    ICMP code.  If specified, the Type value must also be specified. This is a technical
    limitation imposed by the kernel''s iptables firewall, which Calico uses to enforce
    the rule.","type":"integer"},"type":{"description":"Match on a specific ICMP type.  For
    example a value of 8 refers to ICMP Echo Request (i.e. pings).","type":"integer"}},"type":"object"},"ipVersion":{"description":"IPVersion
    is an optional field that restricts the rule to only match a specific IP version.","type":"integer"},"metadata":{"description":"Metadata
    contains additional information for this rule","properties":{"annotations":{"additionalProperties":{"type":"string"},"description":"Annotations
    is a set of key value pairs that give extra information about the rule","type":"object"}},"type":"object"},"notICMP":{"description":"NotICMP
    is the negated version of the ICMP field.","properties":{"code":{"description":"Match
    on a specific ICMP code.  If specified, the Type value must also be specified.
    This is a technical limitation imposed by the kernel''s iptables firewall, which
    Calico uses to enforce the rule.","type":"integer"},"type":{"description":"Match
    on a specific ICMP type.  For example a value of 8 refers to ICMP Echo Request
    (i.e. pings).","type":"integer"}},"type":"object"},"notProtocol":{"anyOf":[{"type":"integer"},{"type":"string"}],"description":"NotProtocol
    is the negated version of the Protocol field.","pattern":"^.*","x-kubernetes-int-or-string":true},"protocol":{"anyOf":[{"type":"integer"},{"type":"string"}],"description":"Protocol
    is an optional field that restricts the rule to only apply to traffic of a specific
    IP protocol. Required if any of the EntityRules contain Ports (because ports only
    apply to certain protocols). \n Must be one of these string values: \"TCP\", \"UDP\",
    \"ICMP\", \"ICMPv6\", \"SCTP\", \"UDPLite\" or an integer in the range 1-255.","pattern":"^.*","x-kubernetes-int-or-string":true},"source":{"description":"Source
    contains the match criteria that apply to source entity.","properties":{"namespaceSelector":{"description":"NamespaceSelector
    is an optional field that contains a selector expression. Only traffic that originates
    from (or terminates at) endpoints within the selected namespaces will be matched.
    When both NamespaceSelector and another selector are defined on the same rule,
    then only workload endpoints that are matched by both selectors will be selected
    by the rule. \n For NetworkPolicy, an empty NamespaceSelector implies that the
    Selector is limited to selecting only workload endpoints in the same namespace
    as the NetworkPolicy. \n For NetworkPolicy, `global()` NamespaceSelector implies
    that the Selector is limited to selecting only GlobalNetworkSet or HostEndpoint.
    \n For GlobalNetworkPolicy, an empty NamespaceSelector implies the Selector applies
    to workload endpoints across all namespaces.","type":"string"},"nets":{"description":"Nets
    is an optional field that restricts the rule to only apply to traffic that originates
    from (or terminates at) IP addresses in any of the given subnets.","items":{"type":"string"},"type":"array"},"notNets":{"description":"NotNets
    is the negated version of the Nets field.","items":{"type":"string"},"type":"array"},"notPorts":{"description":"NotPorts
    is the negated version of the Ports field. Since only some protocols have ports,
    if any ports are specified it requires the Protocol match in the Rule to be set
    to \"TCP\" or \"UDP\".","items":{"anyOf":[{"type":"integer"},{"type":"string"}],"pattern":"^.*","x-kubernetes-int-or-string":true},"type":"array"},"notSelector":{"description":"NotSelector
    is the negated version of the Selector field.  See Selector field for subtleties
    with negated selectors.","type":"string"},"ports":{"description":"Ports is an
    optional field that restricts the rule to only apply to traffic that has a source
    (destination) port that matches one of these ranges/values. This value is a list
    of integers or strings that represent ranges of ports. \n Since only some protocols
    have ports, if any ports are specified it requires the Protocol match in the Rule
    to be set to \"TCP\" or \"UDP\".","items":{"anyOf":[{"type":"integer"},{"type":"string"}],"pattern":"^.*","x-kubernetes-int-or-string":true},"type":"array"},"selector":{"description":"Selector
    is an optional field that contains a selector expression (see Policy for sample
    syntax).  Only traffic that originates from (terminates at) endpoints matching
    the selector will be matched. \n Note that: in addition to the negated version
    of the Selector (see NotSelector below), the selector expression syntax itself
    supports negation.  The two types of negation are subtly different. One negates
    the set of matched endpoints, the other negates the whole match: \n \tSelector
    = \"!has(my_label)\" matches packets that are from other Calico-controlled \tendpoints
    that do not have the label \"my_label\". \n \tNotSelector = \"has(my_label)\"
    matches packets that are not from Calico-controlled \tendpoints that do have the
    label \"my_label\". \n The effect is that the latter will accept packets from
    non-Calico sources whereas the former is limited to packets from Calico-controlled
    endpoints.","type":"string"},"serviceAccounts":{"description":"ServiceAccounts
    is an optional field that restricts the rule to only apply to traffic that originates
    from (or terminates at) a pod running as a matching service account.","properties":{"names":{"description":"Names
    is an optional field that restricts the rule to only apply to traffic that originates
    from (or terminates at) a pod running as a service account whose name is in the
    list.","items":{"type":"string"},"type":"array"},"selector":{"description":"Selector
    is an optional field that restricts the rule to only apply to traffic that originates
    from (or terminates at) a pod running as a service account that matches the given
    label selector. If both Names and Selector are specified then they are AND''ed.","type":"string"}},"type":"object"},"services":{"description":"Services
    is an optional field that contains options for matching Kubernetes Services. If
    specified, only traffic that originates from or terminates at endpoints within
    the selected service(s) will be matched, and only to/from each endpoint''s port.
    \n Services cannot be specified on the same rule as Selector, NotSelector, NamespaceSelector,
    Nets, NotNets or ServiceAccounts. \n Ports and NotPorts can only be specified
    with Services on ingress rules.","properties":{"name":{"description":"Name specifies
    the name of a Kubernetes Service to match.","type":"string"},"namespace":{"description":"Namespace
    specifies the namespace of the given Service. If left empty, the rule will match
    within this policy''s namespace.","type":"string"}},"type":"object"}},"type":"object"}},"required":["action"],"type":"object"},"type":"array"},"ingress":{"description":"The
    ordered set of ingress rules.  Each rule contains a set of packet match criteria
    and a corresponding action to apply.","items":{"description":"A Rule encapsulates
    a set of match criteria and an action.  Both selector-based security Policy and
    security Profiles reference rules - separated out as a list of rules for both
    ingress and egress packet matching. \n Each positive match criteria has a negated
    version, prefixed with \"Not\". All the match criteria within a rule must be satisfied
    for a packet to match. A single rule can contain the positive and negative version
    of a match and both must be satisfied for the rule to match.","properties":{"action":{"type":"string"},"destination":{"description":"Destination
    contains the match criteria that apply to destination entity.","properties":{"namespaceSelector":{"description":"NamespaceSelector
    is an optional field that contains a selector expression. Only traffic that originates
    from (or terminates at) endpoints within the selected namespaces will be matched.
    When both NamespaceSelector and another selector are defined on the same rule,
    then only workload endpoints that are matched by both selectors will be selected
    by the rule. \n For NetworkPolicy, an empty NamespaceSelector implies that the
    Selector is limited to selecting only workload endpoints in the same namespace
    as the NetworkPolicy. \n For NetworkPolicy, `global()` NamespaceSelector implies
    that the Selector is limited to selecting only GlobalNetworkSet or HostEndpoint.
    \n For GlobalNetworkPolicy, an empty NamespaceSelector implies the Selector applies
    to workload endpoints across all namespaces.","type":"string"},"nets":{"description":"Nets
    is an optional field that restricts the rule to only apply to traffic that originates
    from (or terminates at) IP addresses in any of the given subnets.","items":{"type":"string"},"type":"array"},"notNets":{"description":"NotNets
    is the negated version of the Nets field.","items":{"type":"string"},"type":"array"},"notPorts":{"description":"NotPorts
    is the negated version of the Ports field. Since only some protocols have ports,
    if any ports are specified it requires the Protocol match in the Rule to be set
    to \"TCP\" or \"UDP\".","items":{"anyOf":[{"type":"integer"},{"type":"string"}],"pattern":"^.*","x-kubernetes-int-or-string":true},"type":"array"},"notSelector":{"description":"NotSelector
    is the negated version of the Selector field.  See Selector field for subtleties
    with negated selectors.","type":"string"},"ports":{"description":"Ports is an
    optional field that restricts the rule to only apply to traffic that has a source
    (destination) port that matches one of these ranges/values. This value is a list
    of integers or strings that represent ranges of ports. \n Since only some protocols
    have ports, if any ports are specified it requires the Protocol match in the Rule
    to be set to \"TCP\" or \"UDP\".","items":{"anyOf":[{"type":"integer"},{"type":"string"}],"pattern":"^.*","x-kubernetes-int-or-string":true},"type":"array"},"selector":{"description":"Selector
    is an optional field that contains a selector expression (see Policy for sample
    syntax).  Only traffic that originates from (terminates at) endpoints matching
    the selector will be matched. \n Note that: in addition to the negated version
    of the Selector (see NotSelector below), the selector expression syntax itself
    supports negation.  The two types of negation are subtly different. One negates
    the set of matched endpoints, the other negates the whole match: \n \tSelector
    = \"!has(my_label)\" matches packets that are from other Calico-controlled \tendpoints
    that do not have the label \"my_label\". \n \tNotSelector = \"has(my_label)\"
    matches packets that are not from Calico-controlled \tendpoints that do have the
    label \"my_label\". \n The effect is that the latter will accept packets from
    non-Calico sources whereas the former is limited to packets from Calico-controlled
    endpoints.","type":"string"},"serviceAccounts":{"description":"ServiceAccounts
    is an optional field that restricts the rule to only apply to traffic that originates
    from (or terminates at) a pod running as a matching service account.","properties":{"names":{"description":"Names
    is an optional field that restricts the rule to only apply to traffic that originates
    from (or terminates at) a pod running as a service account whose name is in the
    list.","items":{"type":"string"},"type":"array"},"selector":{"description":"Selector
    is an optional field that restricts the rule to only apply to traffic that originates
    from (or terminates at) a pod running as a service account that matches the given
    label selector. If both Names and Selector are specified then they are AND''ed.","type":"string"}},"type":"object"},"services":{"description":"Services
    is an optional field that contains options for matching Kubernetes Services. If
    specified, only traffic that originates from or terminates at endpoints within
    the selected service(s) will be matched, and only to/from each endpoint''s port.
    \n Services cannot be specified on the same rule as Selector, NotSelector, NamespaceSelector,
    Nets, NotNets or ServiceAccounts. \n Ports and NotPorts can only be specified
    with Services on ingress rules.","properties":{"name":{"description":"Name specifies
    the name of a Kubernetes Service to match.","type":"string"},"namespace":{"description":"Namespace
    specifies the namespace of the given Service. If left empty, the rule will match
    within this policy''s namespace.","type":"string"}},"type":"object"}},"type":"object"},"http":{"description":"HTTP
    contains match criteria that apply to HTTP requests.","properties":{"methods":{"description":"Methods
    is an optional field that restricts the rule to apply only to HTTP requests that
    use one of the listed HTTP Methods (e.g. GET, PUT, etc.) Multiple methods are
    OR''d together.","items":{"type":"string"},"type":"array"},"paths":{"description":"Paths
    is an optional field that restricts the rule to apply to HTTP requests that use
    one of the listed HTTP Paths. Multiple paths are OR''d together. e.g: - exact:
    /foo - prefix: /bar NOTE: Each entry may ONLY specify either a `exact` or a `prefix`
    match. The validator will check for it.","items":{"description":"HTTPPath specifies
    an HTTP path to match. It may be either of the form: exact: <path>: which matches
    the path exactly or prefix: <path-prefix>: which matches the path prefix","properties":{"exact":{"type":"string"},"prefix":{"type":"string"}},"type":"object"},"type":"array"}},"type":"object"},"icmp":{"description":"ICMP
    is an optional field that restricts the rule to apply to a specific type and code
    of ICMP traffic.  This should only be specified if the Protocol field is set to
    \"ICMP\" or \"ICMPv6\".","properties":{"code":{"description":"Match on a specific
    ICMP code.  If specified, the Type value must also be specified. This is a technical
    limitation imposed by the kernel''s iptables firewall, which Calico uses to enforce
    the rule.","type":"integer"},"type":{"description":"Match on a specific ICMP type.  For
    example a value of 8 refers to ICMP Echo Request (i.e. pings).","type":"integer"}},"type":"object"},"ipVersion":{"description":"IPVersion
    is an optional field that restricts the rule to only match a specific IP version.","type":"integer"},"metadata":{"description":"Metadata
    contains additional information for this rule","properties":{"annotations":{"additionalProperties":{"type":"string"},"description":"Annotations
    is a set of key value pairs that give extra information about the rule","type":"object"}},"type":"object"},"notICMP":{"description":"NotICMP
    is the negated version of the ICMP field.","properties":{"code":{"description":"Match
    on a specific ICMP code.  If specified, the Type value must also be specified.
    This is a technical limitation imposed by the kernel''s iptables firewall, which
    Calico uses to enforce the rule.","type":"integer"},"type":{"description":"Match
    on a specific ICMP type.  For example a value of 8 refers to ICMP Echo Request
    (i.e. pings).","type":"integer"}},"type":"object"},"notProtocol":{"anyOf":[{"type":"integer"},{"type":"string"}],"description":"NotProtocol
    is the negated version of the Protocol field.","pattern":"^.*","x-kubernetes-int-or-string":true},"protocol":{"anyOf":[{"type":"integer"},{"type":"string"}],"description":"Protocol
    is an optional field that restricts the rule to only apply to traffic of a specific
    IP protocol. Required if any of the EntityRules contain Ports (because ports only
    apply to certain protocols). \n Must be one of these string values: \"TCP\", \"UDP\",
    \"ICMP\", \"ICMPv6\", \"SCTP\", \"UDPLite\" or an integer in the range 1-255.","pattern":"^.*","x-kubernetes-int-or-string":true},"source":{"description":"Source
    contains the match criteria that apply to source entity.","properties":{"namespaceSelector":{"description":"NamespaceSelector
    is an optional field that contains a selector expression. Only traffic that originates
    from (or terminates at) endpoints within the selected namespaces will be matched.
    When both NamespaceSelector and another selector are defined on the same rule,
    then only workload endpoints that are matched by both selectors will be selected
    by the rule. \n For NetworkPolicy, an empty NamespaceSelector implies that the
    Selector is limited to selecting only workload endpoints in the same namespace
    as the NetworkPolicy. \n For NetworkPolicy, `global()` NamespaceSelector implies
    that the Selector is limited to selecting only GlobalNetworkSet or HostEndpoint.
    \n For GlobalNetworkPolicy, an empty NamespaceSelector implies the Selector applies
    to workload endpoints across all namespaces.","type":"string"},"nets":{"description":"Nets
    is an optional field that restricts the rule to only apply to traffic that originates
    from (or terminates at) IP addresses in any of the given subnets.","items":{"type":"string"},"type":"array"},"notNets":{"description":"NotNets
    is the negated version of the Nets field.","items":{"type":"string"},"type":"array"},"notPorts":{"description":"NotPorts
    is the negated version of the Ports field. Since only some protocols have ports,
    if any ports are specified it requires the Protocol match in the Rule to be set
    to \"TCP\" or \"UDP\".","items":{"anyOf":[{"type":"integer"},{"type":"string"}],"pattern":"^.*","x-kubernetes-int-or-string":true},"type":"array"},"notSelector":{"description":"NotSelector
    is the negated version of the Selector field.  See Selector field for subtleties
    with negated selectors.","type":"string"},"ports":{"description":"Ports is an
    optional field that restricts the rule to only apply to traffic that has a source
    (destination) port that matches one of these ranges/values. This value is a list
    of integers or strings that represent ranges of ports. \n Since only some protocols
    have ports, if any ports are specified it requires the Protocol match in the Rule
    to be set to \"TCP\" or \"UDP\".","items":{"anyOf":[{"type":"integer"},{"type":"string"}],"pattern":"^.*","x-kubernetes-int-or-string":true},"type":"array"},"selector":{"description":"Selector
    is an optional field that contains a selector expression (see Policy for sample
    syntax).  Only traffic that originates from (terminates at) endpoints matching
    the selector will be matched. \n Note that: in addition to the negated version
    of the Selector (see NotSelector below), the selector expression syntax itself
    supports negation.  The two types of negation are subtly different. One negates
    the set of matched endpoints, the other negates the whole match: \n \tSelector
    = \"!has(my_label)\" matches packets that are from other Calico-controlled \tendpoints
    that do not have the label \"my_label\". \n \tNotSelector = \"has(my_label)\"
    matches packets that are not from Calico-controlled \tendpoints that do have the
    label \"my_label\". \n The effect is that the latter will accept packets from
    non-Calico sources whereas the former is limited to packets from Calico-controlled
    endpoints.","type":"string"},"serviceAccounts":{"description":"ServiceAccounts
    is an optional field that restricts the rule to only apply to traffic that originates
    from (or terminates at) a pod running as a matching service account.","properties":{"names":{"description":"Names
    is an optional field that restricts the rule to only apply to traffic that originates
    from (or terminates at) a pod running as a service account whose name is in the
    list.","items":{"type":"string"},"type":"array"},"selector":{"description":"Selector
    is an optional field that restricts the rule to only apply to traffic that originates
    from (or terminates at) a pod running as a service account that matches the given
    label selector. If both Names and Selector are specified then they are AND''ed.","type":"string"}},"type":"object"},"services":{"description":"Services
    is an optional field that contains options for matching Kubernetes Services. If
    specified, only traffic that originates from or terminates at endpoints within
    the selected service(s) will be matched, and only to/from each endpoint''s port.
    \n Services cannot be specified on the same rule as Selector, NotSelector, NamespaceSelector,
    Nets, NotNets or ServiceAccounts. \n Ports and NotPorts can only be specified
    with Services on ingress rules.","properties":{"name":{"description":"Name specifies
    the name of a Kubernetes Service to match.","type":"string"},"namespace":{"description":"Namespace
    specifies the namespace of the given Service. If left empty, the rule will match
    within this policy''s namespace.","type":"string"}},"type":"object"}},"type":"object"}},"required":["action"],"type":"object"},"type":"array"},"namespaceSelector":{"description":"NamespaceSelector
    is an optional field for an expression used to select a pod based on namespaces.","type":"string"},"order":{"description":"Order
    is an optional field that specifies the order in which the policy is applied.
    Policies with higher \"order\" are applied after those with lower order within
    the same tier.  If the order is omitted, it may be considered to be \"infinite\"
    - i.e. the policy will be applied last.  Policies with identical order will be
    applied in alphanumerical order based on the Policy \"Name\" within the tier.","type":"number"},"performanceHints":{"description":"PerformanceHints
    contains a list of hints to Calico''s policy engine to help process the policy
    more efficiently.  Hints never change the enforcement behaviour of the policy.
    \n Currently, the only available hint is \"AssumeNeededOnEveryNode\".  When that
    hint is set on a policy, Felix will act as if the policy matches a local endpoint
    even if it does not. This is useful for \"preloading\" any large static policies
    that are known to be used on every node. If the policy is _not_ used on a particular
    node then the work done to preload the policy (and to maintain it) is wasted.","items":{"type":"string"},"type":"array"},"preDNAT":{"description":"PreDNAT
    indicates to apply the rules in this policy before any DNAT.","type":"boolean"},"selector":{"description":"The
    selector is an expression used to pick out the endpoints that the policy should
    be applied to. \n Selector expressions follow this syntax: \n \tlabel == \"string_literal\"  ->  comparison,
    e.g. my_label == \"foo bar\" \tlabel != \"string_literal\"   ->  not equal; also
    matches if label is not present \tlabel in { \"a\", \"b\", \"c\", ... }  ->  true
    if the value of label X is one of \"a\", \"b\", \"c\" \tlabel not in { \"a\",
    \"b\", \"c\", ... }  ->  true if the value of label X is not one of \"a\", \"b\",
    \"c\" \thas(label_name)  -> True if that label is present \t! expr -> negation
    of expr \texpr && expr  -> Short-circuit and \texpr || expr  -> Short-circuit
    or \t( expr ) -> parens for grouping \tall() or the empty selector -> matches
    all endpoints. \n Label names are allowed to contain alphanumerics, -, _ and /.
    String literals are more permissive but they do not support escape characters.
    \n Examples (with made-up labels): \n \ttype == \"webserver\" && deployment ==
    \"prod\" \ttype in {\"frontend\", \"backend\"} \tdeployment != \"dev\" \t! has(label_name)","type":"string"},"serviceAccountSelector":{"description":"ServiceAccountSelector
    is an optional field for an expression used to select a pod based on service accounts.","type":"string"},"tier":{"description":"The
    name of the tier that this policy belongs to.  If this is omitted, the default
    tier (name is \"default\") is assumed.  The specified tier must exist in order
    to create security policies within the tier, the \"default\" tier is created automatically
    if it does not exist, this means for deployments requiring only a single Tier,
    the tier name may be omitted on all policy management requests.","type":"string"},"types":{"description":"Types
    indicates whether this policy applies to ingress, or to egress, or to both.  When
    not explicitly specified (and so the value on creation is empty or nil), Calico
    defaults Types according to what Ingress and Egress rules are present in the policy.  The
    default is: \n - [ PolicyTypeIngress ], if there are no Egress rules (including
    the case where there are   also no Ingress rules) \n - [ PolicyTypeEgress ], if
    there are Egress rules but no Ingress rules \n - [ PolicyTypeIngress, PolicyTypeEgress
    ], if there are both Ingress and Egress rules. \n When the policy is read back
    again, Types will always be one of these values, never empty or nil.","items":{"description":"PolicyType
    enumerates the possible values of the PolicySpec Types field.","type":"string"},"type":"array"}},"type":"object"}},"type":"object"}},"served":true,"storage":true}]},"status":{"acceptedNames":{"kind":"","plural":""},"conditions":[],"storedVersions":[]}},{"apiVersion":"apiextensions.k8s.io/v1","kind":"CustomResourceDefinition","metadata":{"name":"globalnetworksets.crd.projectcalico.org"},"spec":{"group":"crd.projectcalico.org","names":{"kind":"GlobalNetworkSet","listKind":"GlobalNetworkSetList","plural":"globalnetworksets","singular":"globalnetworkset"},"preserveUnknownFields":false,"scope":"Cluster","versions":[{"name":"v1","schema":{"openAPIV3Schema":{"description":"GlobalNetworkSet
    contains a set of arbitrary IP sub-networks/CIDRs that share labels to allow rules
    to refer to them via selectors.  The labels of GlobalNetworkSet are not namespaced.","properties":{"apiVersion":{"description":"APIVersion
    defines the versioned schema of this representation of an object. Servers should
    convert recognized schemas to the latest internal value, and may reject unrecognized
    values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","type":"string"},"kind":{"description":"Kind
    is a string value representing the REST resource this object represents. Servers
    may infer this from the endpoint the client submits requests to. Cannot be updated.
    In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","type":"string"},"metadata":{"type":"object"},"spec":{"description":"GlobalNetworkSetSpec
    contains the specification for a NetworkSet resource.","properties":{"nets":{"description":"The
    list of IP networks that belong to this set.","items":{"type":"string"},"type":"array"}},"type":"object"}},"type":"object"}},"served":true,"storage":true}]},"status":{"acceptedNames":{"kind":"","plural":""},"conditions":[],"storedVersions":[]}},{"apiVersion":"apiextensions.k8s.io/v1","kind":"CustomResourceDefinition","metadata":{"name":"hostendpoints.crd.projectcalico.org"},"spec":{"group":"crd.projectcalico.org","names":{"kind":"HostEndpoint","listKind":"HostEndpointList","plural":"hostendpoints","singular":"hostendpoint"},"preserveUnknownFields":false,"scope":"Cluster","versions":[{"name":"v1","schema":{"openAPIV3Schema":{"properties":{"apiVersion":{"description":"APIVersion
    defines the versioned schema of this representation of an object. Servers should
    convert recognized schemas to the latest internal value, and may reject unrecognized
    values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","type":"string"},"kind":{"description":"Kind
    is a string value representing the REST resource this object represents. Servers
    may infer this from the endpoint the client submits requests to. Cannot be updated.
    In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","type":"string"},"metadata":{"type":"object"},"spec":{"description":"HostEndpointSpec
    contains the specification for a HostEndpoint resource.","properties":{"expectedIPs":{"description":"The
    expected IP addresses (IPv4 and IPv6) of the endpoint. If \"InterfaceName\" is
    not present, Calico will look for an interface matching any of the IPs in the
    list and apply policy to that. Note: \tWhen using the selector match criteria
    in an ingress or egress security Policy \tor Profile, Calico converts the selector
    into a set of IP addresses. For host \tendpoints, the ExpectedIPs field is used
    for that purpose. (If only the interface \tname is specified, Calico does not
    learn the IPs of the interface for use in match \tcriteria.)","items":{"type":"string"},"type":"array"},"interfaceName":{"description":"Either
    \"*\", or the name of a specific Linux interface to apply policy to; or empty.  \"*\"
    indicates that this HostEndpoint governs all traffic to, from or through the default
    network namespace of the host named by the \"Node\" field; entering and leaving
    that namespace via any interface, including those from/to non-host-networked local
    workloads. \n If InterfaceName is not \"*\", this HostEndpoint only governs traffic
    that enters or leaves the host through the specific interface named by InterfaceName,
    or - when InterfaceName is empty - through the specific interface that has one
    of the IPs in ExpectedIPs. Therefore, when InterfaceName is empty, at least one
    expected IP must be specified.  Only external interfaces (such as \"eth0\") are
    supported here; it isn''t possible for a HostEndpoint to protect traffic through
    a specific local workload interface. \n Note: Only some kinds of policy are implemented
    for \"*\" HostEndpoints; initially just pre-DNAT policy.  Please check Calico
    documentation for the latest position.","type":"string"},"node":{"description":"The
    node name identifying the Calico node instance.","type":"string"},"ports":{"description":"Ports
    contains the endpoint''s named ports, which may be referenced in security policy
    rules.","items":{"properties":{"name":{"type":"string"},"port":{"type":"integer"},"protocol":{"anyOf":[{"type":"integer"},{"type":"string"}],"pattern":"^.*","x-kubernetes-int-or-string":true}},"required":["name","port","protocol"],"type":"object"},"type":"array"},"profiles":{"description":"A
    list of identifiers of security Profile objects that apply to this endpoint. Each
    profile is applied in the order that they appear in this list.  Profile rules
    are applied after the selector-based security policy.","items":{"type":"string"},"type":"array"}},"type":"object"}},"type":"object"}},"served":true,"storage":true}]},"status":{"acceptedNames":{"kind":"","plural":""},"conditions":[],"storedVersions":[]}},{"apiVersion":"apiextensions.k8s.io/v1","kind":"CustomResourceDefinition","metadata":{"name":"ipamblocks.crd.projectcalico.org"},"spec":{"group":"crd.projectcalico.org","names":{"kind":"IPAMBlock","listKind":"IPAMBlockList","plural":"ipamblocks","singular":"ipamblock"},"preserveUnknownFields":false,"scope":"Cluster","versions":[{"name":"v1","schema":{"openAPIV3Schema":{"properties":{"apiVersion":{"description":"APIVersion
    defines the versioned schema of this representation of an object. Servers should
    convert recognized schemas to the latest internal value, and may reject unrecognized
    values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","type":"string"},"kind":{"description":"Kind
    is a string value representing the REST resource this object represents. Servers
    may infer this from the endpoint the client submits requests to. Cannot be updated.
    In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","type":"string"},"metadata":{"type":"object"},"spec":{"description":"IPAMBlockSpec
    contains the specification for an IPAMBlock resource.","properties":{"affinity":{"description":"Affinity
    of the block, if this block has one. If set, it will be of the form \"host:<hostname>\".
    If not set, this block is not affine to a host.","type":"string"},"allocations":{"description":"Array
    of allocations in-use within this block. nil entries mean the allocation is free.
    For non-nil entries at index i, the index is the ordinal of the allocation within
    this block and the value is the index of the associated attributes in the Attributes
    array.","items":{"nullable":true,"type":"integer"},"type":"array"},"attributes":{"description":"Attributes
    is an array of arbitrary metadata associated with allocations in the block. To
    find attributes for a given allocation, use the value of the allocation''s entry
    in the Allocations array as the index of the element in this array.","items":{"properties":{"handle_id":{"type":"string"},"secondary":{"additionalProperties":{"type":"string"},"type":"object"}},"type":"object"},"type":"array"},"cidr":{"description":"The
    block''s CIDR.","type":"string"},"deleted":{"description":"Deleted is an internal
    boolean used to workaround a limitation in the Kubernetes API whereby deletion
    will not return a conflict error if the block has been updated. It should not
    be set manually.","type":"boolean"},"sequenceNumber":{"default":0,"description":"We
    store a sequence number that is updated each time the block is written. Each allocation
    will also store the sequence number of the block at the time of its creation.
    When releasing an IP, passing the sequence number associated with the allocation
    allows us to protect against a race condition and ensure the IP hasn''t been released
    and re-allocated since the release request.","format":"int64","type":"integer"},"sequenceNumberForAllocation":{"additionalProperties":{"format":"int64","type":"integer"},"description":"Map
    of allocated ordinal within the block to sequence number of the block at the time
    of allocation. Kubernetes does not allow numerical keys for maps, so the key is
    cast to a string.","type":"object"},"strictAffinity":{"description":"StrictAffinity
    on the IPAMBlock is deprecated and no longer used by the code. Use IPAMConfig
    StrictAffinity instead.","type":"boolean"},"unallocated":{"description":"Unallocated
    is an ordered list of allocations which are free in the block.","items":{"type":"integer"},"type":"array"}},"required":["allocations","attributes","cidr","strictAffinity","unallocated"],"type":"object"}},"type":"object"}},"served":true,"storage":true}]},"status":{"acceptedNames":{"kind":"","plural":""},"conditions":[],"storedVersions":[]}},{"apiVersion":"apiextensions.k8s.io/v1","kind":"CustomResourceDefinition","metadata":{"name":"ipamconfigs.crd.projectcalico.org"},"spec":{"group":"crd.projectcalico.org","names":{"kind":"IPAMConfig","listKind":"IPAMConfigList","plural":"ipamconfigs","singular":"ipamconfig"},"preserveUnknownFields":false,"scope":"Cluster","versions":[{"name":"v1","schema":{"openAPIV3Schema":{"properties":{"apiVersion":{"description":"APIVersion
    defines the versioned schema of this representation of an object. Servers should
    convert recognized schemas to the latest internal value, and may reject unrecognized
    values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","type":"string"},"kind":{"description":"Kind
    is a string value representing the REST resource this object represents. Servers
    may infer this from the endpoint the client submits requests to. Cannot be updated.
    In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","type":"string"},"metadata":{"type":"object"},"spec":{"description":"IPAMConfigSpec
    contains the specification for an IPAMConfig resource.","properties":{"autoAllocateBlocks":{"type":"boolean"},"maxBlocksPerHost":{"description":"MaxBlocksPerHost,
    if non-zero, is the max number of blocks that can be affine to each host.","maximum":2147483647,"minimum":0,"type":"integer"},"strictAffinity":{"type":"boolean"}},"required":["autoAllocateBlocks","strictAffinity"],"type":"object"}},"type":"object"}},"served":true,"storage":true}]},"status":{"acceptedNames":{"kind":"","plural":""},"conditions":[],"storedVersions":[]}},{"apiVersion":"apiextensions.k8s.io/v1","kind":"CustomResourceDefinition","metadata":{"name":"ipamhandles.crd.projectcalico.org"},"spec":{"group":"crd.projectcalico.org","names":{"kind":"IPAMHandle","listKind":"IPAMHandleList","plural":"ipamhandles","singular":"ipamhandle"},"preserveUnknownFields":false,"scope":"Cluster","versions":[{"name":"v1","schema":{"openAPIV3Schema":{"properties":{"apiVersion":{"description":"APIVersion
    defines the versioned schema of this representation of an object. Servers should
    convert recognized schemas to the latest internal value, and may reject unrecognized
    values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","type":"string"},"kind":{"description":"Kind
    is a string value representing the REST resource this object represents. Servers
    may infer this from the endpoint the client submits requests to. Cannot be updated.
    In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","type":"string"},"metadata":{"type":"object"},"spec":{"description":"IPAMHandleSpec
    contains the specification for an IPAMHandle resource.","properties":{"block":{"additionalProperties":{"type":"integer"},"type":"object"},"deleted":{"type":"boolean"},"handleID":{"type":"string"}},"required":["block","handleID"],"type":"object"}},"type":"object"}},"served":true,"storage":true}]},"status":{"acceptedNames":{"kind":"","plural":""},"conditions":[],"storedVersions":[]}},{"apiVersion":"apiextensions.k8s.io/v1","kind":"CustomResourceDefinition","metadata":{"name":"ippools.crd.projectcalico.org"},"spec":{"group":"crd.projectcalico.org","names":{"kind":"IPPool","listKind":"IPPoolList","plural":"ippools","singular":"ippool"},"preserveUnknownFields":false,"scope":"Cluster","versions":[{"name":"v1","schema":{"openAPIV3Schema":{"properties":{"apiVersion":{"description":"APIVersion
    defines the versioned schema of this representation of an object. Servers should
    convert recognized schemas to the latest internal value, and may reject unrecognized
    values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","type":"string"},"kind":{"description":"Kind
    is a string value representing the REST resource this object represents. Servers
    may infer this from the endpoint the client submits requests to. Cannot be updated.
    In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","type":"string"},"metadata":{"type":"object"},"spec":{"description":"IPPoolSpec
    contains the specification for an IPPool resource.","properties":{"allowedUses":{"description":"AllowedUse
    controls what the IP pool will be used for.  If not specified or empty, defaults
    to [\"Tunnel\", \"Workload\"] for back-compatibility","items":{"type":"string"},"type":"array"},"blockSize":{"description":"The
    block size to use for IP address assignments from this pool. Defaults to 26 for
    IPv4 and 122 for IPv6.","type":"integer"},"cidr":{"description":"The pool CIDR.","type":"string"},"disableBGPExport":{"description":"Disable
    exporting routes from this IP Pool''s CIDR over BGP. [Default: false]","type":"boolean"},"disabled":{"description":"When
    disabled is true, Calico IPAM will not assign addresses from this pool.","type":"boolean"},"ipip":{"description":"Deprecated:
    this field is only used for APIv1 backwards compatibility. Setting this field
    is not allowed, this field is for internal use only.","properties":{"enabled":{"description":"When
    enabled is true, ipip tunneling will be used to deliver packets to destinations
    within this pool.","type":"boolean"},"mode":{"description":"The IPIP mode.  This
    can be one of \"always\" or \"cross-subnet\".  A mode of \"always\" will also
    use IPIP tunneling for routing to destination IP addresses within this pool.  A
    mode of \"cross-subnet\" will only use IPIP tunneling when the destination node
    is on a different subnet to the originating node.  The default value (if not specified)
    is \"always\".","type":"string"}},"type":"object"},"ipipMode":{"description":"Contains
    configuration for IPIP tunneling for this pool. If not specified, then this is
    defaulted to \"Never\" (i.e. IPIP tunneling is disabled).","type":"string"},"nat-outgoing":{"description":"Deprecated:
    this field is only used for APIv1 backwards compatibility. Setting this field
    is not allowed, this field is for internal use only.","type":"boolean"},"natOutgoing":{"description":"When
    natOutgoing is true, packets sent from Calico networked containers in this pool
    to destinations outside of this pool will be masqueraded.","type":"boolean"},"nodeSelector":{"description":"Allows
    IPPool to allocate for a specific node by label selector.","type":"string"},"vxlanMode":{"description":"Contains
    configuration for VXLAN tunneling for this pool. If not specified, then this is
    defaulted to \"Never\" (i.e. VXLAN tunneling is disabled).","type":"string"}},"required":["cidr"],"type":"object"}},"type":"object"}},"served":true,"storage":true}]},"status":{"acceptedNames":{"kind":"","plural":""},"conditions":[],"storedVersions":[]}},{"apiVersion":"apiextensions.k8s.io/v1","kind":"CustomResourceDefinition","metadata":{"annotations":{"controller-gen.kubebuilder.io/version":"(devel)"},"creationTimestamp":null,"name":"ipreservations.crd.projectcalico.org"},"spec":{"group":"crd.projectcalico.org","names":{"kind":"IPReservation","listKind":"IPReservationList","plural":"ipreservations","singular":"ipreservation"},"preserveUnknownFields":false,"scope":"Cluster","versions":[{"name":"v1","schema":{"openAPIV3Schema":{"properties":{"apiVersion":{"description":"APIVersion
    defines the versioned schema of this representation of an object. Servers should
    convert recognized schemas to the latest internal value, and may reject unrecognized
    values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","type":"string"},"kind":{"description":"Kind
    is a string value representing the REST resource this object represents. Servers
    may infer this from the endpoint the client submits requests to. Cannot be updated.
    In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","type":"string"},"metadata":{"type":"object"},"spec":{"description":"IPReservationSpec
    contains the specification for an IPReservation resource.","properties":{"reservedCIDRs":{"description":"ReservedCIDRs
    is a list of CIDRs and/or IP addresses that Calico IPAM will exclude from new
    allocations.","items":{"type":"string"},"type":"array"}},"type":"object"}},"type":"object"}},"served":true,"storage":true}]},"status":{"acceptedNames":{"kind":"","plural":""},"conditions":[],"storedVersions":[]}},{"apiVersion":"apiextensions.k8s.io/v1","kind":"CustomResourceDefinition","metadata":{"name":"kubecontrollersconfigurations.crd.projectcalico.org"},"spec":{"group":"crd.projectcalico.org","names":{"kind":"KubeControllersConfiguration","listKind":"KubeControllersConfigurationList","plural":"kubecontrollersconfigurations","singular":"kubecontrollersconfiguration"},"preserveUnknownFields":false,"scope":"Cluster","versions":[{"name":"v1","schema":{"openAPIV3Schema":{"properties":{"apiVersion":{"description":"APIVersion
    defines the versioned schema of this representation of an object. Servers should
    convert recognized schemas to the latest internal value, and may reject unrecognized
    values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","type":"string"},"kind":{"description":"Kind
    is a string value representing the REST resource this object represents. Servers
    may infer this from the endpoint the client submits requests to. Cannot be updated.
    In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","type":"string"},"metadata":{"type":"object"},"spec":{"description":"KubeControllersConfigurationSpec
    contains the values of the Kubernetes controllers configuration.","properties":{"controllers":{"description":"Controllers
    enables and configures individual Kubernetes controllers","properties":{"namespace":{"description":"Namespace
    enables and configures the namespace controller. Enabled by default, set to nil
    to disable.","properties":{"reconcilerPeriod":{"description":"ReconcilerPeriod
    is the period to perform reconciliation with the Calico datastore. [Default: 5m]","type":"string"}},"type":"object"},"node":{"description":"Node
    enables and configures the node controller. Enabled by default, set to nil to
    disable.","properties":{"hostEndpoint":{"description":"HostEndpoint controls syncing
    nodes to host endpoints. Disabled by default, set to nil to disable.","properties":{"autoCreate":{"description":"AutoCreate
    enables automatic creation of host endpoints for every node. [Default: Disabled]","type":"string"}},"type":"object"},"leakGracePeriod":{"description":"LeakGracePeriod
    is the period used by the controller to determine if an IP address has been leaked.
    Set to 0 to disable IP garbage collection. [Default: 15m]","type":"string"},"reconcilerPeriod":{"description":"ReconcilerPeriod
    is the period to perform reconciliation with the Calico datastore. [Default: 5m]","type":"string"},"syncLabels":{"description":"SyncLabels
    controls whether to copy Kubernetes node labels to Calico nodes. [Default: Enabled]","type":"string"}},"type":"object"},"policy":{"description":"Policy
    enables and configures the policy controller. Enabled by default, set to nil to
    disable.","properties":{"reconcilerPeriod":{"description":"ReconcilerPeriod is
    the period to perform reconciliation with the Calico datastore. [Default: 5m]","type":"string"}},"type":"object"},"serviceAccount":{"description":"ServiceAccount
    enables and configures the service account controller. Enabled by default, set
    to nil to disable.","properties":{"reconcilerPeriod":{"description":"ReconcilerPeriod
    is the period to perform reconciliation with the Calico datastore. [Default: 5m]","type":"string"}},"type":"object"},"workloadEndpoint":{"description":"WorkloadEndpoint
    enables and configures the workload endpoint controller. Enabled by default, set
    to nil to disable.","properties":{"reconcilerPeriod":{"description":"ReconcilerPeriod
    is the period to perform reconciliation with the Calico datastore. [Default: 5m]","type":"string"}},"type":"object"}},"type":"object"},"debugProfilePort":{"description":"DebugProfilePort
    configures the port to serve memory and cpu profiles on. If not specified, profiling
    is disabled.","format":"int32","type":"integer"},"etcdV3CompactionPeriod":{"description":"EtcdV3CompactionPeriod
    is the period between etcdv3 compaction requests. Set to 0 to disable. [Default:
    10m]","type":"string"},"healthChecks":{"description":"HealthChecks enables or
    disables support for health checks [Default: Enabled]","type":"string"},"logSeverityScreen":{"description":"LogSeverityScreen
    is the log severity above which logs are sent to the stdout. [Default: Info]","type":"string"},"prometheusMetricsPort":{"description":"PrometheusMetricsPort
    is the TCP port that the Prometheus metrics server should bind to. Set to 0 to
    disable. [Default: 9094]","type":"integer"}},"required":["controllers"],"type":"object"},"status":{"description":"KubeControllersConfigurationStatus
    represents the status of the configuration. It''s useful for admins to be able
    to see the actual config that was applied, which can be modified by environment
    variables on the kube-controllers process.","properties":{"environmentVars":{"additionalProperties":{"type":"string"},"description":"EnvironmentVars
    contains the environment variables on the kube-controllers that influenced the
    RunningConfig.","type":"object"},"runningConfig":{"description":"RunningConfig
    contains the effective config that is running in the kube-controllers pod, after
    merging the API resource with any environment variables.","properties":{"controllers":{"description":"Controllers
    enables and configures individual Kubernetes controllers","properties":{"namespace":{"description":"Namespace
    enables and configures the namespace controller. Enabled by default, set to nil
    to disable.","properties":{"reconcilerPeriod":{"description":"ReconcilerPeriod
    is the period to perform reconciliation with the Calico datastore. [Default: 5m]","type":"string"}},"type":"object"},"node":{"description":"Node
    enables and configures the node controller. Enabled by default, set to nil to
    disable.","properties":{"hostEndpoint":{"description":"HostEndpoint controls syncing
    nodes to host endpoints. Disabled by default, set to nil to disable.","properties":{"autoCreate":{"description":"AutoCreate
    enables automatic creation of host endpoints for every node. [Default: Disabled]","type":"string"}},"type":"object"},"leakGracePeriod":{"description":"LeakGracePeriod
    is the period used by the controller to determine if an IP address has been leaked.
    Set to 0 to disable IP garbage collection. [Default: 15m]","type":"string"},"reconcilerPeriod":{"description":"ReconcilerPeriod
    is the period to perform reconciliation with the Calico datastore. [Default: 5m]","type":"string"},"syncLabels":{"description":"SyncLabels
    controls whether to copy Kubernetes node labels to Calico nodes. [Default: Enabled]","type":"string"}},"type":"object"},"policy":{"description":"Policy
    enables and configures the policy controller. Enabled by default, set to nil to
    disable.","properties":{"reconcilerPeriod":{"description":"ReconcilerPeriod is
    the period to perform reconciliation with the Calico datastore. [Default: 5m]","type":"string"}},"type":"object"},"serviceAccount":{"description":"ServiceAccount
    enables and configures the service account controller. Enabled by default, set
    to nil to disable.","properties":{"reconcilerPeriod":{"description":"ReconcilerPeriod
    is the period to perform reconciliation with the Calico datastore. [Default: 5m]","type":"string"}},"type":"object"},"workloadEndpoint":{"description":"WorkloadEndpoint
    enables and configures the workload endpoint controller. Enabled by default, set
    to nil to disable.","properties":{"reconcilerPeriod":{"description":"ReconcilerPeriod
    is the period to perform reconciliation with the Calico datastore. [Default: 5m]","type":"string"}},"type":"object"}},"type":"object"},"debugProfilePort":{"description":"DebugProfilePort
    configures the port to serve memory and cpu profiles on. If not specified, profiling
    is disabled.","format":"int32","type":"integer"},"etcdV3CompactionPeriod":{"description":"EtcdV3CompactionPeriod
    is the period between etcdv3 compaction requests. Set to 0 to disable. [Default:
    10m]","type":"string"},"healthChecks":{"description":"HealthChecks enables or
    disables support for health checks [Default: Enabled]","type":"string"},"logSeverityScreen":{"description":"LogSeverityScreen
    is the log severity above which logs are sent to the stdout. [Default: Info]","type":"string"},"prometheusMetricsPort":{"description":"PrometheusMetricsPort
    is the TCP port that the Prometheus metrics server should bind to. Set to 0 to
    disable. [Default: 9094]","type":"integer"}},"required":["controllers"],"type":"object"}},"type":"object"}},"type":"object"}},"served":true,"storage":true}]},"status":{"acceptedNames":{"kind":"","plural":""},"conditions":[],"storedVersions":[]}},{"apiVersion":"apiextensions.k8s.io/v1","kind":"CustomResourceDefinition","metadata":{"name":"networkpolicies.crd.projectcalico.org"},"spec":{"group":"crd.projectcalico.org","names":{"kind":"NetworkPolicy","listKind":"NetworkPolicyList","plural":"networkpolicies","singular":"networkpolicy"},"preserveUnknownFields":false,"scope":"Namespaced","versions":[{"name":"v1","schema":{"openAPIV3Schema":{"properties":{"apiVersion":{"description":"APIVersion
    defines the versioned schema of this representation of an object. Servers should
    convert recognized schemas to the latest internal value, and may reject unrecognized
    values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","type":"string"},"kind":{"description":"Kind
    is a string value representing the REST resource this object represents. Servers
    may infer this from the endpoint the client submits requests to. Cannot be updated.
    In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","type":"string"},"metadata":{"type":"object"},"spec":{"properties":{"egress":{"description":"The
    ordered set of egress rules.  Each rule contains a set of packet match criteria
    and a corresponding action to apply.","items":{"description":"A Rule encapsulates
    a set of match criteria and an action.  Both selector-based security Policy and
    security Profiles reference rules - separated out as a list of rules for both
    ingress and egress packet matching. \n Each positive match criteria has a negated
    version, prefixed with \"Not\". All the match criteria within a rule must be satisfied
    for a packet to match. A single rule can contain the positive and negative version
    of a match and both must be satisfied for the rule to match.","properties":{"action":{"type":"string"},"destination":{"description":"Destination
    contains the match criteria that apply to destination entity.","properties":{"namespaceSelector":{"description":"NamespaceSelector
    is an optional field that contains a selector expression. Only traffic that originates
    from (or terminates at) endpoints within the selected namespaces will be matched.
    When both NamespaceSelector and another selector are defined on the same rule,
    then only workload endpoints that are matched by both selectors will be selected
    by the rule. \n For NetworkPolicy, an empty NamespaceSelector implies that the
    Selector is limited to selecting only workload endpoints in the same namespace
    as the NetworkPolicy. \n For NetworkPolicy, `global()` NamespaceSelector implies
    that the Selector is limited to selecting only GlobalNetworkSet or HostEndpoint.
    \n For GlobalNetworkPolicy, an empty NamespaceSelector implies the Selector applies
    to workload endpoints across all namespaces.","type":"string"},"nets":{"description":"Nets
    is an optional field that restricts the rule to only apply to traffic that originates
    from (or terminates at) IP addresses in any of the given subnets.","items":{"type":"string"},"type":"array"},"notNets":{"description":"NotNets
    is the negated version of the Nets field.","items":{"type":"string"},"type":"array"},"notPorts":{"description":"NotPorts
    is the negated version of the Ports field. Since only some protocols have ports,
    if any ports are specified it requires the Protocol match in the Rule to be set
    to \"TCP\" or \"UDP\".","items":{"anyOf":[{"type":"integer"},{"type":"string"}],"pattern":"^.*","x-kubernetes-int-or-string":true},"type":"array"},"notSelector":{"description":"NotSelector
    is the negated version of the Selector field.  See Selector field for subtleties
    with negated selectors.","type":"string"},"ports":{"description":"Ports is an
    optional field that restricts the rule to only apply to traffic that has a source
    (destination) port that matches one of these ranges/values. This value is a list
    of integers or strings that represent ranges of ports. \n Since only some protocols
    have ports, if any ports are specified it requires the Protocol match in the Rule
    to be set to \"TCP\" or \"UDP\".","items":{"anyOf":[{"type":"integer"},{"type":"string"}],"pattern":"^.*","x-kubernetes-int-or-string":true},"type":"array"},"selector":{"description":"Selector
    is an optional field that contains a selector expression (see Policy for sample
    syntax).  Only traffic that originates from (terminates at) endpoints matching
    the selector will be matched. \n Note that: in addition to the negated version
    of the Selector (see NotSelector below), the selector expression syntax itself
    supports negation.  The two types of negation are subtly different. One negates
    the set of matched endpoints, the other negates the whole match: \n \tSelector
    = \"!has(my_label)\" matches packets that are from other Calico-controlled \tendpoints
    that do not have the label \"my_label\". \n \tNotSelector = \"has(my_label)\"
    matches packets that are not from Calico-controlled \tendpoints that do have the
    label \"my_label\". \n The effect is that the latter will accept packets from
    non-Calico sources whereas the former is limited to packets from Calico-controlled
    endpoints.","type":"string"},"serviceAccounts":{"description":"ServiceAccounts
    is an optional field that restricts the rule to only apply to traffic that originates
    from (or terminates at) a pod running as a matching service account.","properties":{"names":{"description":"Names
    is an optional field that restricts the rule to only apply to traffic that originates
    from (or terminates at) a pod running as a service account whose name is in the
    list.","items":{"type":"string"},"type":"array"},"selector":{"description":"Selector
    is an optional field that restricts the rule to only apply to traffic that originates
    from (or terminates at) a pod running as a service account that matches the given
    label selector. If both Names and Selector are specified then they are AND''ed.","type":"string"}},"type":"object"},"services":{"description":"Services
    is an optional field that contains options for matching Kubernetes Services. If
    specified, only traffic that originates from or terminates at endpoints within
    the selected service(s) will be matched, and only to/from each endpoint''s port.
    \n Services cannot be specified on the same rule as Selector, NotSelector, NamespaceSelector,
    Nets, NotNets or ServiceAccounts. \n Ports and NotPorts can only be specified
    with Services on ingress rules.","properties":{"name":{"description":"Name specifies
    the name of a Kubernetes Service to match.","type":"string"},"namespace":{"description":"Namespace
    specifies the namespace of the given Service. If left empty, the rule will match
    within this policy''s namespace.","type":"string"}},"type":"object"}},"type":"object"},"http":{"description":"HTTP
    contains match criteria that apply to HTTP requests.","properties":{"methods":{"description":"Methods
    is an optional field that restricts the rule to apply only to HTTP requests that
    use one of the listed HTTP Methods (e.g. GET, PUT, etc.) Multiple methods are
    OR''d together.","items":{"type":"string"},"type":"array"},"paths":{"description":"Paths
    is an optional field that restricts the rule to apply to HTTP requests that use
    one of the listed HTTP Paths. Multiple paths are OR''d together. e.g: - exact:
    /foo - prefix: /bar NOTE: Each entry may ONLY specify either a `exact` or a `prefix`
    match. The validator will check for it.","items":{"description":"HTTPPath specifies
    an HTTP path to match. It may be either of the form: exact: <path>: which matches
    the path exactly or prefix: <path-prefix>: which matches the path prefix","properties":{"exact":{"type":"string"},"prefix":{"type":"string"}},"type":"object"},"type":"array"}},"type":"object"},"icmp":{"description":"ICMP
    is an optional field that restricts the rule to apply to a specific type and code
    of ICMP traffic.  This should only be specified if the Protocol field is set to
    \"ICMP\" or \"ICMPv6\".","properties":{"code":{"description":"Match on a specific
    ICMP code.  If specified, the Type value must also be specified. This is a technical
    limitation imposed by the kernel''s iptables firewall, which Calico uses to enforce
    the rule.","type":"integer"},"type":{"description":"Match on a specific ICMP type.  For
    example a value of 8 refers to ICMP Echo Request (i.e. pings).","type":"integer"}},"type":"object"},"ipVersion":{"description":"IPVersion
    is an optional field that restricts the rule to only match a specific IP version.","type":"integer"},"metadata":{"description":"Metadata
    contains additional information for this rule","properties":{"annotations":{"additionalProperties":{"type":"string"},"description":"Annotations
    is a set of key value pairs that give extra information about the rule","type":"object"}},"type":"object"},"notICMP":{"description":"NotICMP
    is the negated version of the ICMP field.","properties":{"code":{"description":"Match
    on a specific ICMP code.  If specified, the Type value must also be specified.
    This is a technical limitation imposed by the kernel''s iptables firewall, which
    Calico uses to enforce the rule.","type":"integer"},"type":{"description":"Match
    on a specific ICMP type.  For example a value of 8 refers to ICMP Echo Request
    (i.e. pings).","type":"integer"}},"type":"object"},"notProtocol":{"anyOf":[{"type":"integer"},{"type":"string"}],"description":"NotProtocol
    is the negated version of the Protocol field.","pattern":"^.*","x-kubernetes-int-or-string":true},"protocol":{"anyOf":[{"type":"integer"},{"type":"string"}],"description":"Protocol
    is an optional field that restricts the rule to only apply to traffic of a specific
    IP protocol. Required if any of the EntityRules contain Ports (because ports only
    apply to certain protocols). \n Must be one of these string values: \"TCP\", \"UDP\",
    \"ICMP\", \"ICMPv6\", \"SCTP\", \"UDPLite\" or an integer in the range 1-255.","pattern":"^.*","x-kubernetes-int-or-string":true},"source":{"description":"Source
    contains the match criteria that apply to source entity.","properties":{"namespaceSelector":{"description":"NamespaceSelector
    is an optional field that contains a selector expression. Only traffic that originates
    from (or terminates at) endpoints within the selected namespaces will be matched.
    When both NamespaceSelector and another selector are defined on the same rule,
    then only workload endpoints that are matched by both selectors will be selected
    by the rule. \n For NetworkPolicy, an empty NamespaceSelector implies that the
    Selector is limited to selecting only workload endpoints in the same namespace
    as the NetworkPolicy. \n For NetworkPolicy, `global()` NamespaceSelector implies
    that the Selector is limited to selecting only GlobalNetworkSet or HostEndpoint.
    \n For GlobalNetworkPolicy, an empty NamespaceSelector implies the Selector applies
    to workload endpoints across all namespaces.","type":"string"},"nets":{"description":"Nets
    is an optional field that restricts the rule to only apply to traffic that originates
    from (or terminates at) IP addresses in any of the given subnets.","items":{"type":"string"},"type":"array"},"notNets":{"description":"NotNets
    is the negated version of the Nets field.","items":{"type":"string"},"type":"array"},"notPorts":{"description":"NotPorts
    is the negated version of the Ports field. Since only some protocols have ports,
    if any ports are specified it requires the Protocol match in the Rule to be set
    to \"TCP\" or \"UDP\".","items":{"anyOf":[{"type":"integer"},{"type":"string"}],"pattern":"^.*","x-kubernetes-int-or-string":true},"type":"array"},"notSelector":{"description":"NotSelector
    is the negated version of the Selector field.  See Selector field for subtleties
    with negated selectors.","type":"string"},"ports":{"description":"Ports is an
    optional field that restricts the rule to only apply to traffic that has a source
    (destination) port that matches one of these ranges/values. This value is a list
    of integers or strings that represent ranges of ports. \n Since only some protocols
    have ports, if any ports are specified it requires the Protocol match in the Rule
    to be set to \"TCP\" or \"UDP\".","items":{"anyOf":[{"type":"integer"},{"type":"string"}],"pattern":"^.*","x-kubernetes-int-or-string":true},"type":"array"},"selector":{"description":"Selector
    is an optional field that contains a selector expression (see Policy for sample
    syntax).  Only traffic that originates from (terminates at) endpoints matching
    the selector will be matched. \n Note that: in addition to the negated version
    of the Selector (see NotSelector below), the selector expression syntax itself
    supports negation.  The two types of negation are subtly different. One negates
    the set of matched endpoints, the other negates the whole match: \n \tSelector
    = \"!has(my_label)\" matches packets that are from other Calico-controlled \tendpoints
    that do not have the label \"my_label\". \n \tNotSelector = \"has(my_label)\"
    matches packets that are not from Calico-controlled \tendpoints that do have the
    label \"my_label\". \n The effect is that the latter will accept packets from
    non-Calico sources whereas the former is limited to packets from Calico-controlled
    endpoints.","type":"string"},"serviceAccounts":{"description":"ServiceAccounts
    is an optional field that restricts the rule to only apply to traffic that originates
    from (or terminates at) a pod running as a matching service account.","properties":{"names":{"description":"Names
    is an optional field that restricts the rule to only apply to traffic that originates
    from (or terminates at) a pod running as a service account whose name is in the
    list.","items":{"type":"string"},"type":"array"},"selector":{"description":"Selector
    is an optional field that restricts the rule to only apply to traffic that originates
    from (or terminates at) a pod running as a service account that matches the given
    label selector. If both Names and Selector are specified then they are AND''ed.","type":"string"}},"type":"object"},"services":{"description":"Services
    is an optional field that contains options for matching Kubernetes Services. If
    specified, only traffic that originates from or terminates at endpoints within
    the selected service(s) will be matched, and only to/from each endpoint''s port.
    \n Services cannot be specified on the same rule as Selector, NotSelector, NamespaceSelector,
    Nets, NotNets or ServiceAccounts. \n Ports and NotPorts can only be specified
    with Services on ingress rules.","properties":{"name":{"description":"Name specifies
    the name of a Kubernetes Service to match.","type":"string"},"namespace":{"description":"Namespace
    specifies the namespace of the given Service. If left empty, the rule will match
    within this policy''s namespace.","type":"string"}},"type":"object"}},"type":"object"}},"required":["action"],"type":"object"},"type":"array"},"ingress":{"description":"The
    ordered set of ingress rules.  Each rule contains a set of packet match criteria
    and a corresponding action to apply.","items":{"description":"A Rule encapsulates
    a set of match criteria and an action.  Both selector-based security Policy and
    security Profiles reference rules - separated out as a list of rules for both
    ingress and egress packet matching. \n Each positive match criteria has a negated
    version, prefixed with \"Not\". All the match criteria within a rule must be satisfied
    for a packet to match. A single rule can contain the positive and negative version
    of a match and both must be satisfied for the rule to match.","properties":{"action":{"type":"string"},"destination":{"description":"Destination
    contains the match criteria that apply to destination entity.","properties":{"namespaceSelector":{"description":"NamespaceSelector
    is an optional field that contains a selector expression. Only traffic that originates
    from (or terminates at) endpoints within the selected namespaces will be matched.
    When both NamespaceSelector and another selector are defined on the same rule,
    then only workload endpoints that are matched by both selectors will be selected
    by the rule. \n For NetworkPolicy, an empty NamespaceSelector implies that the
    Selector is limited to selecting only workload endpoints in the same namespace
    as the NetworkPolicy. \n For NetworkPolicy, `global()` NamespaceSelector implies
    that the Selector is limited to selecting only GlobalNetworkSet or HostEndpoint.
    \n For GlobalNetworkPolicy, an empty NamespaceSelector implies the Selector applies
    to workload endpoints across all namespaces.","type":"string"},"nets":{"description":"Nets
    is an optional field that restricts the rule to only apply to traffic that originates
    from (or terminates at) IP addresses in any of the given subnets.","items":{"type":"string"},"type":"array"},"notNets":{"description":"NotNets
    is the negated version of the Nets field.","items":{"type":"string"},"type":"array"},"notPorts":{"description":"NotPorts
    is the negated version of the Ports field. Since only some protocols have ports,
    if any ports are specified it requires the Protocol match in the Rule to be set
    to \"TCP\" or \"UDP\".","items":{"anyOf":[{"type":"integer"},{"type":"string"}],"pattern":"^.*","x-kubernetes-int-or-string":true},"type":"array"},"notSelector":{"description":"NotSelector
    is the negated version of the Selector field.  See Selector field for subtleties
    with negated selectors.","type":"string"},"ports":{"description":"Ports is an
    optional field that restricts the rule to only apply to traffic that has a source
    (destination) port that matches one of these ranges/values. This value is a list
    of integers or strings that represent ranges of ports. \n Since only some protocols
    have ports, if any ports are specified it requires the Protocol match in the Rule
    to be set to \"TCP\" or \"UDP\".","items":{"anyOf":[{"type":"integer"},{"type":"string"}],"pattern":"^.*","x-kubernetes-int-or-string":true},"type":"array"},"selector":{"description":"Selector
    is an optional field that contains a selector expression (see Policy for sample
    syntax).  Only traffic that originates from (terminates at) endpoints matching
    the selector will be matched. \n Note that: in addition to the negated version
    of the Selector (see NotSelector below), the selector expression syntax itself
    supports negation.  The two types of negation are subtly different. One negates
    the set of matched endpoints, the other negates the whole match: \n \tSelector
    = \"!has(my_label)\" matches packets that are from other Calico-controlled \tendpoints
    that do not have the label \"my_label\". \n \tNotSelector = \"has(my_label)\"
    matches packets that are not from Calico-controlled \tendpoints that do have the
    label \"my_label\". \n The effect is that the latter will accept packets from
    non-Calico sources whereas the former is limited to packets from Calico-controlled
    endpoints.","type":"string"},"serviceAccounts":{"description":"ServiceAccounts
    is an optional field that restricts the rule to only apply to traffic that originates
    from (or terminates at) a pod running as a matching service account.","properties":{"names":{"description":"Names
    is an optional field that restricts the rule to only apply to traffic that originates
    from (or terminates at) a pod running as a service account whose name is in the
    list.","items":{"type":"string"},"type":"array"},"selector":{"description":"Selector
    is an optional field that restricts the rule to only apply to traffic that originates
    from (or terminates at) a pod running as a service account that matches the given
    label selector. If both Names and Selector are specified then they are AND''ed.","type":"string"}},"type":"object"},"services":{"description":"Services
    is an optional field that contains options for matching Kubernetes Services. If
    specified, only traffic that originates from or terminates at endpoints within
    the selected service(s) will be matched, and only to/from each endpoint''s port.
    \n Services cannot be specified on the same rule as Selector, NotSelector, NamespaceSelector,
    Nets, NotNets or ServiceAccounts. \n Ports and NotPorts can only be specified
    with Services on ingress rules.","properties":{"name":{"description":"Name specifies
    the name of a Kubernetes Service to match.","type":"string"},"namespace":{"description":"Namespace
    specifies the namespace of the given Service. If left empty, the rule will match
    within this policy''s namespace.","type":"string"}},"type":"object"}},"type":"object"},"http":{"description":"HTTP
    contains match criteria that apply to HTTP requests.","properties":{"methods":{"description":"Methods
    is an optional field that restricts the rule to apply only to HTTP requests that
    use one of the listed HTTP Methods (e.g. GET, PUT, etc.) Multiple methods are
    OR''d together.","items":{"type":"string"},"type":"array"},"paths":{"description":"Paths
    is an optional field that restricts the rule to apply to HTTP requests that use
    one of the listed HTTP Paths. Multiple paths are OR''d together. e.g: - exact:
    /foo - prefix: /bar NOTE: Each entry may ONLY specify either a `exact` or a `prefix`
    match. The validator will check for it.","items":{"description":"HTTPPath specifies
    an HTTP path to match. It may be either of the form: exact: <path>: which matches
    the path exactly or prefix: <path-prefix>: which matches the path prefix","properties":{"exact":{"type":"string"},"prefix":{"type":"string"}},"type":"object"},"type":"array"}},"type":"object"},"icmp":{"description":"ICMP
    is an optional field that restricts the rule to apply to a specific type and code
    of ICMP traffic.  This should only be specified if the Protocol field is set to
    \"ICMP\" or \"ICMPv6\".","properties":{"code":{"description":"Match on a specific
    ICMP code.  If specified, the Type value must also be specified. This is a technical
    limitation imposed by the kernel''s iptables firewall, which Calico uses to enforce
    the rule.","type":"integer"},"type":{"description":"Match on a specific ICMP type.  For
    example a value of 8 refers to ICMP Echo Request (i.e. pings).","type":"integer"}},"type":"object"},"ipVersion":{"description":"IPVersion
    is an optional field that restricts the rule to only match a specific IP version.","type":"integer"},"metadata":{"description":"Metadata
    contains additional information for this rule","properties":{"annotations":{"additionalProperties":{"type":"string"},"description":"Annotations
    is a set of key value pairs that give extra information about the rule","type":"object"}},"type":"object"},"notICMP":{"description":"NotICMP
    is the negated version of the ICMP field.","properties":{"code":{"description":"Match
    on a specific ICMP code.  If specified, the Type value must also be specified.
    This is a technical limitation imposed by the kernel''s iptables firewall, which
    Calico uses to enforce the rule.","type":"integer"},"type":{"description":"Match
    on a specific ICMP type.  For example a value of 8 refers to ICMP Echo Request
    (i.e. pings).","type":"integer"}},"type":"object"},"notProtocol":{"anyOf":[{"type":"integer"},{"type":"string"}],"description":"NotProtocol
    is the negated version of the Protocol field.","pattern":"^.*","x-kubernetes-int-or-string":true},"protocol":{"anyOf":[{"type":"integer"},{"type":"string"}],"description":"Protocol
    is an optional field that restricts the rule to only apply to traffic of a specific
    IP protocol. Required if any of the EntityRules contain Ports (because ports only
    apply to certain protocols). \n Must be one of these string values: \"TCP\", \"UDP\",
    \"ICMP\", \"ICMPv6\", \"SCTP\", \"UDPLite\" or an integer in the range 1-255.","pattern":"^.*","x-kubernetes-int-or-string":true},"source":{"description":"Source
    contains the match criteria that apply to source entity.","properties":{"namespaceSelector":{"description":"NamespaceSelector
    is an optional field that contains a selector expression. Only traffic that originates
    from (or terminates at) endpoints within the selected namespaces will be matched.
    When both NamespaceSelector and another selector are defined on the same rule,
    then only workload endpoints that are matched by both selectors will be selected
    by the rule. \n For NetworkPolicy, an empty NamespaceSelector implies that the
    Selector is limited to selecting only workload endpoints in the same namespace
    as the NetworkPolicy. \n For NetworkPolicy, `global()` NamespaceSelector implies
    that the Selector is limited to selecting only GlobalNetworkSet or HostEndpoint.
    \n For GlobalNetworkPolicy, an empty NamespaceSelector implies the Selector applies
    to workload endpoints across all namespaces.","type":"string"},"nets":{"description":"Nets
    is an optional field that restricts the rule to only apply to traffic that originates
    from (or terminates at) IP addresses in any of the given subnets.","items":{"type":"string"},"type":"array"},"notNets":{"description":"NotNets
    is the negated version of the Nets field.","items":{"type":"string"},"type":"array"},"notPorts":{"description":"NotPorts
    is the negated version of the Ports field. Since only some protocols have ports,
    if any ports are specified it requires the Protocol match in the Rule to be set
    to \"TCP\" or \"UDP\".","items":{"anyOf":[{"type":"integer"},{"type":"string"}],"pattern":"^.*","x-kubernetes-int-or-string":true},"type":"array"},"notSelector":{"description":"NotSelector
    is the negated version of the Selector field.  See Selector field for subtleties
    with negated selectors.","type":"string"},"ports":{"description":"Ports is an
    optional field that restricts the rule to only apply to traffic that has a source
    (destination) port that matches one of these ranges/values. This value is a list
    of integers or strings that represent ranges of ports. \n Since only some protocols
    have ports, if any ports are specified it requires the Protocol match in the Rule
    to be set to \"TCP\" or \"UDP\".","items":{"anyOf":[{"type":"integer"},{"type":"string"}],"pattern":"^.*","x-kubernetes-int-or-string":true},"type":"array"},"selector":{"description":"Selector
    is an optional field that contains a selector expression (see Policy for sample
    syntax).  Only traffic that originates from (terminates at) endpoints matching
    the selector will be matched. \n Note that: in addition to the negated version
    of the Selector (see NotSelector below), the selector expression syntax itself
    supports negation.  The two types of negation are subtly different. One negates
    the set of matched endpoints, the other negates the whole match: \n \tSelector
    = \"!has(my_label)\" matches packets that are from other Calico-controlled \tendpoints
    that do not have the label \"my_label\". \n \tNotSelector = \"has(my_label)\"
    matches packets that are not from Calico-controlled \tendpoints that do have the
    label \"my_label\". \n The effect is that the latter will accept packets from
    non-Calico sources whereas the former is limited to packets from Calico-controlled
    endpoints.","type":"string"},"serviceAccounts":{"description":"ServiceAccounts
    is an optional field that restricts the rule to only apply to traffic that originates
    from (or terminates at) a pod running as a matching service account.","properties":{"names":{"description":"Names
    is an optional field that restricts the rule to only apply to traffic that originates
    from (or terminates at) a pod running as a service account whose name is in the
    list.","items":{"type":"string"},"type":"array"},"selector":{"description":"Selector
    is an optional field that restricts the rule to only apply to traffic that originates
    from (or terminates at) a pod running as a service account that matches the given
    label selector. If both Names and Selector are specified then they are AND''ed.","type":"string"}},"type":"object"},"services":{"description":"Services
    is an optional field that contains options for matching Kubernetes Services. If
    specified, only traffic that originates from or terminates at endpoints within
    the selected service(s) will be matched, and only to/from each endpoint''s port.
    \n Services cannot be specified on the same rule as Selector, NotSelector, NamespaceSelector,
    Nets, NotNets or ServiceAccounts. \n Ports and NotPorts can only be specified
    with Services on ingress rules.","properties":{"name":{"description":"Name specifies
    the name of a Kubernetes Service to match.","type":"string"},"namespace":{"description":"Namespace
    specifies the namespace of the given Service. If left empty, the rule will match
    within this policy''s namespace.","type":"string"}},"type":"object"}},"type":"object"}},"required":["action"],"type":"object"},"type":"array"},"order":{"description":"Order
    is an optional field that specifies the order in which the policy is applied.
    Policies with higher \"order\" are applied after those with lower order within
    the same tier.  If the order is omitted, it may be considered to be \"infinite\"
    - i.e. the policy will be applied last.  Policies with identical order will be
    applied in alphanumerical order based on the Policy \"Name\" within the tier.","type":"number"},"performanceHints":{"description":"PerformanceHints
    contains a list of hints to Calico''s policy engine to help process the policy
    more efficiently.  Hints never change the enforcement behaviour of the policy.
    \n Currently, the only available hint is \"AssumeNeededOnEveryNode\".  When that
    hint is set on a policy, Felix will act as if the policy matches a local endpoint
    even if it does not. This is useful for \"preloading\" any large static policies
    that are known to be used on every node. If the policy is _not_ used on a particular
    node then the work done to preload the policy (and to maintain it) is wasted.","items":{"type":"string"},"type":"array"},"selector":{"description":"The
    selector is an expression used to pick out the endpoints that the policy should
    be applied to. \n Selector expressions follow this syntax: \n \tlabel == \"string_literal\"  ->  comparison,
    e.g. my_label == \"foo bar\" \tlabel != \"string_literal\"   ->  not equal; also
    matches if label is not present \tlabel in { \"a\", \"b\", \"c\", ... }  ->  true
    if the value of label X is one of \"a\", \"b\", \"c\" \tlabel not in { \"a\",
    \"b\", \"c\", ... }  ->  true if the value of label X is not one of \"a\", \"b\",
    \"c\" \thas(label_name)  -> True if that label is present \t! expr -> negation
    of expr \texpr && expr  -> Short-circuit and \texpr || expr  -> Short-circuit
    or \t( expr ) -> parens for grouping \tall() or the empty selector -> matches
    all endpoints. \n Label names are allowed to contain alphanumerics, -, _ and /.
    String literals are more permissive but they do not support escape characters.
    \n Examples (with made-up labels): \n \ttype == \"webserver\" && deployment ==
    \"prod\" \ttype in {\"frontend\", \"backend\"} \tdeployment != \"dev\" \t! has(label_name)","type":"string"},"serviceAccountSelector":{"description":"ServiceAccountSelector
    is an optional field for an expression used to select a pod based on service accounts.","type":"string"},"tier":{"description":"The
    name of the tier that this policy belongs to.  If this is omitted, the default
    tier (name is \"default\") is assumed.  The specified tier must exist in order
    to create security policies within the tier, the \"default\" tier is created automatically
    if it does not exist, this means for deployments requiring only a single Tier,
    the tier name may be omitted on all policy management requests.","type":"string"},"types":{"description":"Types
    indicates whether this policy applies to ingress, or to egress, or to both.  When
    not explicitly specified (and so the value on creation is empty or nil), Calico
    defaults Types according to what Ingress and Egress are present in the policy.  The
    default is: \n - [ PolicyTypeIngress ], if there are no Egress rules (including
    the case where there are   also no Ingress rules) \n - [ PolicyTypeEgress ], if
    there are Egress rules but no Ingress rules \n - [ PolicyTypeIngress, PolicyTypeEgress
    ], if there are both Ingress and Egress rules. \n When the policy is read back
    again, Types will always be one of these values, never empty or nil.","items":{"description":"PolicyType
    enumerates the possible values of the PolicySpec Types field.","type":"string"},"type":"array"}},"type":"object"}},"type":"object"}},"served":true,"storage":true}]},"status":{"acceptedNames":{"kind":"","plural":""},"conditions":[],"storedVersions":[]}},{"apiVersion":"apiextensions.k8s.io/v1","kind":"CustomResourceDefinition","metadata":{"name":"networksets.crd.projectcalico.org"},"spec":{"group":"crd.projectcalico.org","names":{"kind":"NetworkSet","listKind":"NetworkSetList","plural":"networksets","singular":"networkset"},"preserveUnknownFields":false,"scope":"Namespaced","versions":[{"name":"v1","schema":{"openAPIV3Schema":{"description":"NetworkSet
    is the Namespaced-equivalent of the GlobalNetworkSet.","properties":{"apiVersion":{"description":"APIVersion
    defines the versioned schema of this representation of an object. Servers should
    convert recognized schemas to the latest internal value, and may reject unrecognized
    values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","type":"string"},"kind":{"description":"Kind
    is a string value representing the REST resource this object represents. Servers
    may infer this from the endpoint the client submits requests to. Cannot be updated.
    In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","type":"string"},"metadata":{"type":"object"},"spec":{"description":"NetworkSetSpec
    contains the specification for a NetworkSet resource.","properties":{"nets":{"description":"The
    list of IP networks that belong to this set.","items":{"type":"string"},"type":"array"}},"type":"object"}},"type":"object"}},"served":true,"storage":true}]},"status":{"acceptedNames":{"kind":"","plural":""},"conditions":[],"storedVersions":[]}},{"apiVersion":"apiextensions.k8s.io/v1","kind":"CustomResourceDefinition","metadata":{"annotations":{"controller-gen.kubebuilder.io/version":"(devel)"},"creationTimestamp":null,"name":"tiers.crd.projectcalico.org"},"spec":{"group":"crd.projectcalico.org","names":{"kind":"Tier","listKind":"TierList","plural":"tiers","singular":"tier"},"scope":"Cluster","versions":[{"name":"v1","schema":{"openAPIV3Schema":{"properties":{"apiVersion":{"description":"APIVersion
    defines the versioned schema of this representation of an object. Servers should
    convert recognized schemas to the latest internal value, and may reject unrecognized
    values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","type":"string"},"kind":{"description":"Kind
    is a string value representing the REST resource this object represents. Servers
    may infer this from the endpoint the client submits requests to. Cannot be updated.
    In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","type":"string"},"metadata":{"type":"object"},"spec":{"description":"TierSpec
    contains the specification for a security policy tier resource.","properties":{"defaultAction":{"description":"DefaultAction
    specifies the action applied to workloads selected by a policy in the tier, but
    not rule matched the workload''s traffic. [Default: Deny]","enum":["Pass","Deny"],"type":"string"},"order":{"description":"Order
    is an optional field that specifies the order in which the tier is applied. Tiers
    with higher \"order\" are applied after those with lower order.  If the order
    is omitted, it may be considered to be \"infinite\" - i.e. the tier will be applied
    last.  Tiers with identical order will be applied in alphanumerical order based
    on the Tier \"Name\".","type":"number"}},"type":"object"}},"type":"object"}},"served":true,"storage":true}]},"status":{"acceptedNames":{"kind":"","plural":""},"conditions":[],"storedVersions":[]}},{"apiVersion":"apiextensions.k8s.io/v1","kind":"CustomResourceDefinition","metadata":{"annotations":{"api-approved.kubernetes.io":"https://github.com/kubernetes-sigs/network-policy-api/pull/30","policy.networking.k8s.io/bundle-version":"v0.1.1","policy.networking.k8s.io/channel":"experimental"},"creationTimestamp":null,"name":"adminnetworkpolicies.policy.networking.k8s.io"},"spec":{"group":"policy.networking.k8s.io","names":{"kind":"AdminNetworkPolicy","listKind":"AdminNetworkPolicyList","plural":"adminnetworkpolicies","shortNames":["anp"],"singular":"adminnetworkpolicy"},"scope":"Cluster","versions":[{"additionalPrinterColumns":[{"jsonPath":".spec.priority","name":"Priority","type":"string"},{"jsonPath":".metadata.creationTimestamp","name":"Age","type":"date"}],"name":"v1alpha1","schema":{"openAPIV3Schema":{"description":"AdminNetworkPolicy
    is  a cluster level resource that is part of the\nAdminNetworkPolicy API.","properties":{"apiVersion":{"description":"APIVersion
    defines the versioned schema of this representation of an object.\nServers should
    convert recognized schemas to the latest internal value, and\nmay reject unrecognized
    values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","type":"string"},"kind":{"description":"Kind
    is a string value representing the REST resource this object represents.\nServers
    may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn
    CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","type":"string"},"metadata":{"type":"object"},"spec":{"description":"Specification
    of the desired behavior of AdminNetworkPolicy.","properties":{"egress":{"description":"Egress
    is the list of Egress rules to be applied to the selected pods.\nA total of 100
    rules will be allowed in each ANP instance.\nThe relative precedence of egress
    rules within a single ANP object (all of\nwhich share the priority) will be determined
    by the order in which the rule\nis written. Thus, a rule that appears at the top
    of the egress rules\nwould take the highest precedence.\nANPs with no egress rules
    do not affect egress traffic.\n\n\nSupport: Core","items":{"description":"AdminNetworkPolicyEgressRule
    describes an action to take on a particular\nset of traffic originating from pods
    selected by a AdminNetworkPolicy''s\nSubject field.\n<network-policy-api:experimental:validation>","properties":{"action":{"description":"Action
    specifies the effect this rule will have on matching traffic.\nCurrently the following
    actions are supported:\nAllow: allows the selected traffic (even if it would otherwise
    have been denied by NetworkPolicy)\nDeny: denies the selected traffic\nPass: instructs
    the selected traffic to skip any remaining ANP rules, and\nthen pass execution
    to any NetworkPolicies that select the pod.\nIf the pod is not selected by any
    NetworkPolicies then execution\nis passed to any BaselineAdminNetworkPolicies
    that select the pod.\n\n\nSupport: Core","enum":["Allow","Deny","Pass"],"type":"string"},"name":{"description":"Name
    is an identifier for this rule, that may be no more than 100 characters\nin length.
    This field should be used by the implementation to help\nimprove observability,
    readability and error-reporting for any applied\nAdminNetworkPolicies.\n\n\nSupport:
    Core","maxLength":100,"type":"string"},"ports":{"description":"Ports allows for
    matching traffic based on port and protocols.\nThis field is a list of destination
    ports for the outgoing egress traffic.\nIf Ports is not set then the rule does
    not filter traffic via port.\n\n\nSupport: Core","items":{"description":"AdminNetworkPolicyPort
    describes how to select network ports on pod(s).\nExactly one field must be set.","maxProperties":1,"minProperties":1,"properties":{"namedPort":{"description":"NamedPort
    selects a port on a pod(s) based on name.\n\n\nSupport: Extended\n\n\n<network-policy-api:experimental>","type":"string"},"portNumber":{"description":"Port
    selects a port on a pod(s) based on number.\n\n\nSupport: Core","properties":{"port":{"description":"Number
    defines a network port value.\n\n\nSupport: Core","format":"int32","maximum":65535,"minimum":1,"type":"integer"},"protocol":{"default":"TCP","description":"Protocol
    is the network protocol (TCP, UDP, or SCTP) which traffic must\nmatch. If not
    specified, this field defaults to TCP.\n\n\nSupport: Core","type":"string"}},"required":["port","protocol"],"type":"object"},"portRange":{"description":"PortRange
    selects a port range on a pod(s) based on provided start and end\nvalues.\n\n\nSupport:
    Core","properties":{"end":{"description":"End defines a network port that is the
    end of a port range, the End value\nmust be greater than Start.\n\n\nSupport:
    Core","format":"int32","maximum":65535,"minimum":1,"type":"integer"},"protocol":{"default":"TCP","description":"Protocol
    is the network protocol (TCP, UDP, or SCTP) which traffic must\nmatch. If not
    specified, this field defaults to TCP.\n\n\nSupport: Core","type":"string"},"start":{"description":"Start
    defines a network port that is the start of a port range, the Start\nvalue must
    be less than End.\n\n\nSupport: Core","format":"int32","maximum":65535,"minimum":1,"type":"integer"}},"required":["end","start"],"type":"object"}},"type":"object"},"maxItems":100,"type":"array"},"to":{"description":"To
    is the List of destinations whose traffic this rule applies to.\nIf any AdminNetworkPolicyEgressPeer
    matches the destination of outgoing\ntraffic then the specified action is applied.\nThis
    field must be defined and contain at least one item.\n\n\nSupport: Core","items":{"description":"AdminNetworkPolicyEgressPeer
    defines a peer to allow traffic to.\nExactly one of the selector pointers must
    be set for a given peer. If a\nconsumer observes none of its fields are set, they
    must assume an unknown\noption has been specified and fail closed.","maxProperties":1,"minProperties":1,"properties":{"namespaces":{"description":"Namespaces
    defines a way to select all pods within a set of Namespaces.\nNote that host-networked
    pods are not included in this type of peer.\n\n\nSupport: Core","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"networks":{"description":"Networks
    defines a way to select peers via CIDR blocks.\nThis is intended for representing
    entities that live outside the cluster,\nwhich can''t be selected by pods, namespaces
    and nodes peers, but note\nthat cluster-internal traffic will be checked against
    the rule as\nwell. So if you Allow or Deny traffic to `\"0.0.0.0/0\"`, that will
    allow\nor deny all IPv4 pod-to-pod traffic as well. If you don''t want that,\nadd
    a rule that Passes all pod traffic before the Networks rule.\n\n\nEach item in
    Networks should be provided in the CIDR format and should be\nIPv4 or IPv6, for
    example \"10.0.0.0/8\" or \"fd00::/8\".\n\n\nNetworks can have upto 25 CIDRs specified.\n\n\nSupport:
    Extended\n\n\n<network-policy-api:experimental>","items":{"description":"CIDR
    is an IP address range in CIDR notation (for example, \"10.0.0.0/8\" or \"fd00::/8\").\nThis
    string must be validated by implementations using net.ParseCIDR\nTODO: Introduce
    CEL CIDR validation regex isCIDR() in Kube 1.31 when it is available.","maxLength":43,"type":"string","x-kubernetes-validations":[{"message":"CIDR
    must be either an IPv4 or IPv6 address. IPv4 address embedded in IPv6 addresses
    are not supported","rule":"self.contains('':'') != self.contains(''.'')"}]},"maxItems":25,"minItems":1,"type":"array","x-kubernetes-list-type":"set"},"nodes":{"description":"Nodes
    defines a way to select a set of nodes in\nthe cluster. This field follows standard
    label selector\nsemantics; if present but empty, it selects all Nodes.\n\n\nSupport:
    Extended\n\n\n<network-policy-api:experimental>","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"pods":{"description":"Pods
    defines a way to select a set of pods in\na set of namespaces. Note that host-networked
    pods\nare not included in this type of peer.\n\n\nSupport: Core","properties":{"namespaceSelector":{"description":"NamespaceSelector
    follows standard label selector semantics; if empty,\nit selects all Namespaces.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"podSelector":{"description":"PodSelector
    is used to explicitly select pods within a namespace; if empty,\nit selects all
    Pods.","properties":{"matchExpressions":{"description":"matchExpressions is a
    list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"}},"required":["namespaceSelector","podSelector"],"type":"object"}},"type":"object"},"maxItems":100,"minItems":1,"type":"array"}},"required":["action","to"],"type":"object","x-kubernetes-validations":[{"message":"networks/nodes
    peer cannot be set with namedPorts since there are no namedPorts for networks/nodes","rule":"!(self.to.exists(peer,
    has(peer.networks) || has(peer.nodes)) && has(self.ports) && self.ports.exists(port,
    has(port.namedPort)))"}]},"maxItems":100,"type":"array"},"ingress":{"description":"Ingress
    is the list of Ingress rules to be applied to the selected pods.\nA total of 100
    rules will be allowed in each ANP instance.\nThe relative precedence of ingress
    rules within a single ANP object (all of\nwhich share the priority) will be determined
    by the order in which the rule\nis written. Thus, a rule that appears at the top
    of the ingress rules\nwould take the highest precedence.\nANPs with no ingress
    rules do not affect ingress traffic.\n\n\nSupport: Core","items":{"description":"AdminNetworkPolicyIngressRule
    describes an action to take on a particular\nset of traffic destined for pods
    selected by an AdminNetworkPolicy''s\nSubject field.","properties":{"action":{"description":"Action
    specifies the effect this rule will have on matching traffic.\nCurrently the following
    actions are supported:\nAllow: allows the selected traffic (even if it would otherwise
    have been denied by NetworkPolicy)\nDeny: denies the selected traffic\nPass: instructs
    the selected traffic to skip any remaining ANP rules, and\nthen pass execution
    to any NetworkPolicies that select the pod.\nIf the pod is not selected by any
    NetworkPolicies then execution\nis passed to any BaselineAdminNetworkPolicies
    that select the pod.\n\n\nSupport: Core","enum":["Allow","Deny","Pass"],"type":"string"},"from":{"description":"From
    is the list of sources whose traffic this rule applies to.\nIf any AdminNetworkPolicyIngressPeer
    matches the source of incoming\ntraffic then the specified action is applied.\nThis
    field must be defined and contain at least one item.\n\n\nSupport: Core","items":{"description":"AdminNetworkPolicyIngressPeer
    defines an in-cluster peer to allow traffic from.\nExactly one of the selector
    pointers must be set for a given peer. If a\nconsumer observes none of its fields
    are set, they must assume an unknown\noption has been specified and fail closed.","maxProperties":1,"minProperties":1,"properties":{"namespaces":{"description":"Namespaces
    defines a way to select all pods within a set of Namespaces.\nNote that host-networked
    pods are not included in this type of peer.\n\n\nSupport: Core","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"pods":{"description":"Pods
    defines a way to select a set of pods in\na set of namespaces. Note that host-networked
    pods\nare not included in this type of peer.\n\n\nSupport: Core","properties":{"namespaceSelector":{"description":"NamespaceSelector
    follows standard label selector semantics; if empty,\nit selects all Namespaces.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"podSelector":{"description":"PodSelector
    is used to explicitly select pods within a namespace; if empty,\nit selects all
    Pods.","properties":{"matchExpressions":{"description":"matchExpressions is a
    list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"}},"required":["namespaceSelector","podSelector"],"type":"object"}},"type":"object"},"maxItems":100,"minItems":1,"type":"array"},"name":{"description":"Name
    is an identifier for this rule, that may be no more than 100 characters\nin length.
    This field should be used by the implementation to help\nimprove observability,
    readability and error-reporting for any applied\nAdminNetworkPolicies.\n\n\nSupport:
    Core","maxLength":100,"type":"string"},"ports":{"description":"Ports allows for
    matching traffic based on port and protocols.\nThis field is a list of ports which
    should be matched on\nthe pods selected for this policy i.e the subject of the
    policy.\nSo it matches on the destination port for the ingress traffic.\nIf Ports
    is not set then the rule does not filter traffic via port.\n\n\nSupport: Core","items":{"description":"AdminNetworkPolicyPort
    describes how to select network ports on pod(s).\nExactly one field must be set.","maxProperties":1,"minProperties":1,"properties":{"namedPort":{"description":"NamedPort
    selects a port on a pod(s) based on name.\n\n\nSupport: Extended\n\n\n<network-policy-api:experimental>","type":"string"},"portNumber":{"description":"Port
    selects a port on a pod(s) based on number.\n\n\nSupport: Core","properties":{"port":{"description":"Number
    defines a network port value.\n\n\nSupport: Core","format":"int32","maximum":65535,"minimum":1,"type":"integer"},"protocol":{"default":"TCP","description":"Protocol
    is the network protocol (TCP, UDP, or SCTP) which traffic must\nmatch. If not
    specified, this field defaults to TCP.\n\n\nSupport: Core","type":"string"}},"required":["port","protocol"],"type":"object"},"portRange":{"description":"PortRange
    selects a port range on a pod(s) based on provided start and end\nvalues.\n\n\nSupport:
    Core","properties":{"end":{"description":"End defines a network port that is the
    end of a port range, the End value\nmust be greater than Start.\n\n\nSupport:
    Core","format":"int32","maximum":65535,"minimum":1,"type":"integer"},"protocol":{"default":"TCP","description":"Protocol
    is the network protocol (TCP, UDP, or SCTP) which traffic must\nmatch. If not
    specified, this field defaults to TCP.\n\n\nSupport: Core","type":"string"},"start":{"description":"Start
    defines a network port that is the start of a port range, the Start\nvalue must
    be less than End.\n\n\nSupport: Core","format":"int32","maximum":65535,"minimum":1,"type":"integer"}},"required":["end","start"],"type":"object"}},"type":"object"},"maxItems":100,"type":"array"}},"required":["action","from"],"type":"object"},"maxItems":100,"type":"array"},"priority":{"description":"Priority
    is a value from 0 to 1000. Rules with lower priority values have\nhigher precedence,
    and are checked before rules with higher priority values.\nAll AdminNetworkPolicy
    rules have higher precedence than NetworkPolicy or\nBaselineAdminNetworkPolicy
    rules\nThe behavior is undefined if two ANP objects have same priority.\n\n\nSupport:
    Core","format":"int32","maximum":1000,"minimum":0,"type":"integer"},"subject":{"description":"Subject
    defines the pods to which this AdminNetworkPolicy applies.\nNote that host-networked
    pods are not included in subject selection.\n\n\nSupport: Core","maxProperties":1,"minProperties":1,"properties":{"namespaces":{"description":"Namespaces
    is used to select pods via namespace selectors.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"pods":{"description":"Pods
    is used to select pods via namespace AND pod selectors.","properties":{"namespaceSelector":{"description":"NamespaceSelector
    follows standard label selector semantics; if empty,\nit selects all Namespaces.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"podSelector":{"description":"PodSelector
    is used to explicitly select pods within a namespace; if empty,\nit selects all
    Pods.","properties":{"matchExpressions":{"description":"matchExpressions is a
    list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"}},"required":["namespaceSelector","podSelector"],"type":"object"}},"type":"object"}},"required":["priority","subject"],"type":"object"},"status":{"description":"Status
    is the status to be reported by the implementation.","properties":{"conditions":{"items":{"description":"Condition
    contains details for one aspect of the current state of this API Resource.\n---\nThis
    struct is intended for direct use as an array at the field path .status.conditions.  For
    example,\n\n\n\ttype FooStatus struct{\n\t    // Represents the observations of
    a foo''s current state.\n\t    // Known .status.conditions.type are: \"Available\",
    \"Progressing\", and \"Degraded\"\n\t    // +patchMergeKey=type\n\t    // +patchStrategy=merge\n\t    //
    +listType=map\n\t    // +listMapKey=type\n\t    Conditions []metav1.Condition
    `json:\"conditions,omitempty\" patchStrategy:\"merge\" patchMergeKey:\"type\"
    protobuf:\"bytes,1,rep,name=conditions\"`\n\n\n\t    // other fields\n\t}","properties":{"lastTransitionTime":{"description":"lastTransitionTime
    is the last time the condition transitioned from one status to another.\nThis
    should be when the underlying condition changed.  If that is not known, then using
    the time when the API field changed is acceptable.","format":"date-time","type":"string"},"message":{"description":"message
    is a human readable message indicating details about the transition.\nThis may
    be an empty string.","maxLength":32768,"type":"string"},"observedGeneration":{"description":"observedGeneration
    represents the .metadata.generation that the condition was set based upon.\nFor
    instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration
    is 9, the condition is out of date\nwith respect to the current state of the instance.","format":"int64","minimum":0,"type":"integer"},"reason":{"description":"reason
    contains a programmatic identifier indicating the reason for the condition''s
    last transition.\nProducers of specific condition types may define expected values
    and meanings for this field,\nand whether the values are considered a guaranteed
    API.\nThe value should be a CamelCase string.\nThis field may not be empty.","maxLength":1024,"minLength":1,"pattern":"^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$","type":"string"},"status":{"description":"status
    of the condition, one of True, False, Unknown.","enum":["True","False","Unknown"],"type":"string"},"type":{"description":"type
    of condition in CamelCase or in foo.example.com/CamelCase.\n---\nMany .condition.type
    values are consistent across resources like Available, but because arbitrary conditions
    can be\nuseful (see .node.status.conditions), the ability to deconflict is important.\nThe
    regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)","maxLength":316,"pattern":"^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$","type":"string"}},"required":["lastTransitionTime","message","reason","status","type"],"type":"object"},"type":"array","x-kubernetes-list-map-keys":["type"],"x-kubernetes-list-type":"map"}},"required":["conditions"],"type":"object"}},"required":["metadata","spec"],"type":"object"}},"served":true,"storage":true,"subresources":{"status":{}}}]},"status":{"acceptedNames":{"kind":"","plural":""},"conditions":null,"storedVersions":null}},{"apiVersion":"apiextensions.k8s.io/v1","kind":"CustomResourceDefinition","metadata":{"annotations":{"controller-gen.kubebuilder.io/version":"v0.14.0"},"name":"apiservers.operator.tigera.io"},"spec":{"group":"operator.tigera.io","names":{"kind":"APIServer","listKind":"APIServerList","plural":"apiservers","singular":"apiserver"},"scope":"Cluster","versions":[{"name":"v1","schema":{"openAPIV3Schema":{"description":"APIServer
    installs the Tigera API server and related resources. At most one instance\nof
    this resource is supported. It must be named \"default\" or \"tigera-secure\".","properties":{"apiVersion":{"description":"APIVersion
    defines the versioned schema of this representation of an object.\nServers should
    convert recognized schemas to the latest internal value, and\nmay reject unrecognized
    values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","type":"string"},"kind":{"description":"Kind
    is a string value representing the REST resource this object represents.\nServers
    may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn
    CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","type":"string"},"metadata":{"type":"object"},"spec":{"description":"Specification
    of the desired state for the Tigera API server.","properties":{"apiServerDeployment":{"description":"APIServerDeployment
    configures the calico-apiserver (or tigera-apiserver in Enterprise) Deployment.
    If\nused in conjunction with ControlPlaneNodeSelector or ControlPlaneTolerations,
    then these overrides\ntake precedence.","properties":{"metadata":{"description":"Metadata
    is a subset of a Kubernetes object''s metadata that is added to the Deployment.","properties":{"annotations":{"additionalProperties":{"type":"string"},"description":"Annotations
    is a map of arbitrary non-identifying metadata. Each of these\nkey/value pairs
    are added to the object''s annotations provided the key does not\nalready exist
    in the object''s annotations.","type":"object"},"labels":{"additionalProperties":{"type":"string"},"description":"Labels
    is a map of string keys and values that may match replicaset and\nservice selectors.
    Each of these key/value pairs are added to the\nobject''s labels provided the
    key does not already exist in the object''s labels.","type":"object"}},"type":"object"},"spec":{"description":"Spec
    is the specification of the API server Deployment.","properties":{"minReadySeconds":{"description":"MinReadySeconds
    is the minimum number of seconds for which a newly created Deployment pod should\nbe
    ready without any of its container crashing, for it to be considered available.\nIf
    specified, this overrides any minReadySeconds value that may be set on the API
    server Deployment.\nIf omitted, the API server Deployment will use its default
    value for minReadySeconds.","format":"int32","maximum":2147483647,"minimum":0,"type":"integer"},"template":{"description":"Template
    describes the API server Deployment pod that will be created.","properties":{"metadata":{"description":"Metadata
    is a subset of a Kubernetes object''s metadata that is added to\nthe pod''s metadata.","properties":{"annotations":{"additionalProperties":{"type":"string"},"description":"Annotations
    is a map of arbitrary non-identifying metadata. Each of these\nkey/value pairs
    are added to the object''s annotations provided the key does not\nalready exist
    in the object''s annotations.","type":"object"},"labels":{"additionalProperties":{"type":"string"},"description":"Labels
    is a map of string keys and values that may match replicaset and\nservice selectors.
    Each of these key/value pairs are added to the\nobject''s labels provided the
    key does not already exist in the object''s labels.","type":"object"}},"type":"object"},"spec":{"description":"Spec
    is the API server Deployment''s PodSpec.","properties":{"affinity":{"description":"Affinity
    is a group of affinity scheduling rules for the API server pods.\nIf specified,
    this overrides any affinity that may be set on the API server Deployment.\nIf
    omitted, the API server Deployment will use its default value for affinity.\nWARNING:
    Please note that this field will override the default API server Deployment affinity.","properties":{"nodeAffinity":{"description":"Describes
    node affinity scheduling rules for the pod.","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"description":"The
    scheduler will prefer to schedule pods to nodes that satisfy\nthe affinity expressions
    specified by this field, but it may choose\na node that violates one or more of
    the expressions. The node that is\nmost preferred is the one with the greatest
    sum of weights, i.e.\nfor each node that meets all of the scheduling requirements
    (resource\nrequest, requiredDuringScheduling affinity expressions, etc.),\ncompute
    a sum by iterating through the elements of this field and adding\n\"weight\" to
    the sum if the node matches the corresponding matchExpressions; the\nnode(s) with
    the highest sum are the most preferred.","items":{"description":"An empty preferred
    scheduling term matches all objects with implicit weight 0\n(i.e. it''s a no-op).
    A null preferred scheduling term matches no objects (i.e. is also a no-op).","properties":{"preference":{"description":"A
    node selector term, associated with the corresponding weight.","properties":{"matchExpressions":{"description":"A
    list of node selector requirements by node''s labels.","items":{"description":"A
    node selector requirement is a selector that contains values, a key, and an operator\nthat
    relates the key and values.","properties":{"key":{"description":"The label key
    that the selector applies to.","type":"string"},"operator":{"description":"Represents
    a key''s relationship to a set of values.\nValid operators are In, NotIn, Exists,
    DoesNotExist. Gt, and Lt.","type":"string"},"values":{"description":"An array
    of string values. If the operator is In or NotIn,\nthe values array must be non-empty.
    If the operator is Exists or DoesNotExist,\nthe values array must be empty. If
    the operator is Gt or Lt, the values\narray must have a single element, which
    will be interpreted as an integer.\nThis array is replaced during a strategic
    merge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchFields":{"description":"A
    list of node selector requirements by node''s fields.","items":{"description":"A
    node selector requirement is a selector that contains values, a key, and an operator\nthat
    relates the key and values.","properties":{"key":{"description":"The label key
    that the selector applies to.","type":"string"},"operator":{"description":"Represents
    a key''s relationship to a set of values.\nValid operators are In, NotIn, Exists,
    DoesNotExist. Gt, and Lt.","type":"string"},"values":{"description":"An array
    of string values. If the operator is In or NotIn,\nthe values array must be non-empty.
    If the operator is Exists or DoesNotExist,\nthe values array must be empty. If
    the operator is Gt or Lt, the values\narray must have a single element, which
    will be interpreted as an integer.\nThis array is replaced during a strategic
    merge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"}},"type":"object","x-kubernetes-map-type":"atomic"},"weight":{"description":"Weight
    associated with matching the corresponding nodeSelectorTerm, in the range 1-100.","format":"int32","type":"integer"}},"required":["preference","weight"],"type":"object"},"type":"array"},"requiredDuringSchedulingIgnoredDuringExecution":{"description":"If
    the affinity requirements specified by this field are not met at\nscheduling time,
    the pod will not be scheduled onto the node.\nIf the affinity requirements specified
    by this field cease to be met\nat some point during pod execution (e.g. due to
    an update), the system\nmay or may not try to eventually evict the pod from its
    node.","properties":{"nodeSelectorTerms":{"description":"Required. A list of node
    selector terms. The terms are ORed.","items":{"description":"A null or empty node
    selector term matches no objects. The requirements of\nthem are ANDed.\nThe TopologySelectorTerm
    type implements a subset of the NodeSelectorTerm.","properties":{"matchExpressions":{"description":"A
    list of node selector requirements by node''s labels.","items":{"description":"A
    node selector requirement is a selector that contains values, a key, and an operator\nthat
    relates the key and values.","properties":{"key":{"description":"The label key
    that the selector applies to.","type":"string"},"operator":{"description":"Represents
    a key''s relationship to a set of values.\nValid operators are In, NotIn, Exists,
    DoesNotExist. Gt, and Lt.","type":"string"},"values":{"description":"An array
    of string values. If the operator is In or NotIn,\nthe values array must be non-empty.
    If the operator is Exists or DoesNotExist,\nthe values array must be empty. If
    the operator is Gt or Lt, the values\narray must have a single element, which
    will be interpreted as an integer.\nThis array is replaced during a strategic
    merge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchFields":{"description":"A
    list of node selector requirements by node''s fields.","items":{"description":"A
    node selector requirement is a selector that contains values, a key, and an operator\nthat
    relates the key and values.","properties":{"key":{"description":"The label key
    that the selector applies to.","type":"string"},"operator":{"description":"Represents
    a key''s relationship to a set of values.\nValid operators are In, NotIn, Exists,
    DoesNotExist. Gt, and Lt.","type":"string"},"values":{"description":"An array
    of string values. If the operator is In or NotIn,\nthe values array must be non-empty.
    If the operator is Exists or DoesNotExist,\nthe values array must be empty. If
    the operator is Gt or Lt, the values\narray must have a single element, which
    will be interpreted as an integer.\nThis array is replaced during a strategic
    merge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"}},"type":"object","x-kubernetes-map-type":"atomic"},"type":"array"}},"required":["nodeSelectorTerms"],"type":"object","x-kubernetes-map-type":"atomic"}},"type":"object"},"podAffinity":{"description":"Describes
    pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone,
    etc. as some other pod(s)).","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"description":"The
    scheduler will prefer to schedule pods to nodes that satisfy\nthe affinity expressions
    specified by this field, but it may choose\na node that violates one or more of
    the expressions. The node that is\nmost preferred is the one with the greatest
    sum of weights, i.e.\nfor each node that meets all of the scheduling requirements
    (resource\nrequest, requiredDuringScheduling affinity expressions, etc.),\ncompute
    a sum by iterating through the elements of this field and adding\n\"weight\" to
    the sum if the node has pods which matches the corresponding podAffinityTerm;
    the\nnode(s) with the highest sum are the most preferred.","items":{"description":"The
    weights of all of the matched WeightedPodAffinityTerm fields are added per-node
    to find the most preferred node(s)","properties":{"podAffinityTerm":{"description":"Required.
    A pod affinity term, associated with the corresponding weight.","properties":{"labelSelector":{"description":"A
    label query over a set of resources, in this case pods.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaceSelector":{"description":"A
    label query over the set of namespaces that the term applies to.\nThe term is
    applied to the union of the namespaces selected by this field\nand the ones listed
    in the namespaces field.\nnull selector and null or empty namespaces list means
    \"this pod''s namespace\".\nAn empty selector ({}) matches all namespaces.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaces":{"description":"namespaces
    specifies a static list of namespace names that the term applies to.\nThe term
    is applied to the union of the namespaces listed in this field\nand the ones selected
    by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector
    means \"this pod''s namespace\".","items":{"type":"string"},"type":"array"},"topologyKey":{"description":"This
    pod should be co-located (affinity) or not co-located (anti-affinity) with the
    pods matching\nthe labelSelector in the specified namespaces, where co-located
    is defined as running on a node\nwhose value of the label with key topologyKey
    matches that of any node on which any of the\nselected pods is running.\nEmpty
    topologyKey is not allowed.","type":"string"}},"required":["topologyKey"],"type":"object"},"weight":{"description":"weight
    associated with matching the corresponding podAffinityTerm,\nin the range 1-100.","format":"int32","type":"integer"}},"required":["podAffinityTerm","weight"],"type":"object"},"type":"array"},"requiredDuringSchedulingIgnoredDuringExecution":{"description":"If
    the affinity requirements specified by this field are not met at\nscheduling time,
    the pod will not be scheduled onto the node.\nIf the affinity requirements specified
    by this field cease to be met\nat some point during pod execution (e.g. due to
    a pod label update), the\nsystem may or may not try to eventually evict the pod
    from its node.\nWhen there are multiple elements, the lists of nodes corresponding
    to each\npodAffinityTerm are intersected, i.e. all terms must be satisfied.","items":{"description":"Defines
    a set of pods (namely those matching the labelSelector\nrelative to the given
    namespace(s)) that this pod should be\nco-located (affinity) or not co-located
    (anti-affinity) with,\nwhere co-located is defined as running on a node whose
    value of\nthe label with key <topologyKey> matches that of any node on which\na
    pod of the set of pods is running","properties":{"labelSelector":{"description":"A
    label query over a set of resources, in this case pods.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaceSelector":{"description":"A
    label query over the set of namespaces that the term applies to.\nThe term is
    applied to the union of the namespaces selected by this field\nand the ones listed
    in the namespaces field.\nnull selector and null or empty namespaces list means
    \"this pod''s namespace\".\nAn empty selector ({}) matches all namespaces.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaces":{"description":"namespaces
    specifies a static list of namespace names that the term applies to.\nThe term
    is applied to the union of the namespaces listed in this field\nand the ones selected
    by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector
    means \"this pod''s namespace\".","items":{"type":"string"},"type":"array"},"topologyKey":{"description":"This
    pod should be co-located (affinity) or not co-located (anti-affinity) with the
    pods matching\nthe labelSelector in the specified namespaces, where co-located
    is defined as running on a node\nwhose value of the label with key topologyKey
    matches that of any node on which any of the\nselected pods is running.\nEmpty
    topologyKey is not allowed.","type":"string"}},"required":["topologyKey"],"type":"object"},"type":"array"}},"type":"object"},"podAntiAffinity":{"description":"Describes
    pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node,
    zone, etc. as some other pod(s)).","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"description":"The
    scheduler will prefer to schedule pods to nodes that satisfy\nthe anti-affinity
    expressions specified by this field, but it may choose\na node that violates one
    or more of the expressions. The node that is\nmost preferred is the one with the
    greatest sum of weights, i.e.\nfor each node that meets all of the scheduling
    requirements (resource\nrequest, requiredDuringScheduling anti-affinity expressions,
    etc.),\ncompute a sum by iterating through the elements of this field and adding\n\"weight\"
    to the sum if the node has pods which matches the corresponding podAffinityTerm;
    the\nnode(s) with the highest sum are the most preferred.","items":{"description":"The
    weights of all of the matched WeightedPodAffinityTerm fields are added per-node
    to find the most preferred node(s)","properties":{"podAffinityTerm":{"description":"Required.
    A pod affinity term, associated with the corresponding weight.","properties":{"labelSelector":{"description":"A
    label query over a set of resources, in this case pods.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaceSelector":{"description":"A
    label query over the set of namespaces that the term applies to.\nThe term is
    applied to the union of the namespaces selected by this field\nand the ones listed
    in the namespaces field.\nnull selector and null or empty namespaces list means
    \"this pod''s namespace\".\nAn empty selector ({}) matches all namespaces.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaces":{"description":"namespaces
    specifies a static list of namespace names that the term applies to.\nThe term
    is applied to the union of the namespaces listed in this field\nand the ones selected
    by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector
    means \"this pod''s namespace\".","items":{"type":"string"},"type":"array"},"topologyKey":{"description":"This
    pod should be co-located (affinity) or not co-located (anti-affinity) with the
    pods matching\nthe labelSelector in the specified namespaces, where co-located
    is defined as running on a node\nwhose value of the label with key topologyKey
    matches that of any node on which any of the\nselected pods is running.\nEmpty
    topologyKey is not allowed.","type":"string"}},"required":["topologyKey"],"type":"object"},"weight":{"description":"weight
    associated with matching the corresponding podAffinityTerm,\nin the range 1-100.","format":"int32","type":"integer"}},"required":["podAffinityTerm","weight"],"type":"object"},"type":"array"},"requiredDuringSchedulingIgnoredDuringExecution":{"description":"If
    the anti-affinity requirements specified by this field are not met at\nscheduling
    time, the pod will not be scheduled onto the node.\nIf the anti-affinity requirements
    specified by this field cease to be met\nat some point during pod execution (e.g.
    due to a pod label update), the\nsystem may or may not try to eventually evict
    the pod from its node.\nWhen there are multiple elements, the lists of nodes corresponding
    to each\npodAffinityTerm are intersected, i.e. all terms must be satisfied.","items":{"description":"Defines
    a set of pods (namely those matching the labelSelector\nrelative to the given
    namespace(s)) that this pod should be\nco-located (affinity) or not co-located
    (anti-affinity) with,\nwhere co-located is defined as running on a node whose
    value of\nthe label with key <topologyKey> matches that of any node on which\na
    pod of the set of pods is running","properties":{"labelSelector":{"description":"A
    label query over a set of resources, in this case pods.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaceSelector":{"description":"A
    label query over the set of namespaces that the term applies to.\nThe term is
    applied to the union of the namespaces selected by this field\nand the ones listed
    in the namespaces field.\nnull selector and null or empty namespaces list means
    \"this pod''s namespace\".\nAn empty selector ({}) matches all namespaces.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaces":{"description":"namespaces
    specifies a static list of namespace names that the term applies to.\nThe term
    is applied to the union of the namespaces listed in this field\nand the ones selected
    by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector
    means \"this pod''s namespace\".","items":{"type":"string"},"type":"array"},"topologyKey":{"description":"This
    pod should be co-located (affinity) or not co-located (anti-affinity) with the
    pods matching\nthe labelSelector in the specified namespaces, where co-located
    is defined as running on a node\nwhose value of the label with key topologyKey
    matches that of any node on which any of the\nselected pods is running.\nEmpty
    topologyKey is not allowed.","type":"string"}},"required":["topologyKey"],"type":"object"},"type":"array"}},"type":"object"}},"type":"object"},"containers":{"description":"Containers
    is a list of API server containers.\nIf specified, this overrides the specified
    API server Deployment containers.\nIf omitted, the API server Deployment will
    use its default values for its containers.","items":{"description":"APIServerDeploymentContainer
    is an API server Deployment container.","properties":{"name":{"description":"Name
    is an enum which identifies the API server Deployment container by name.\nSupported
    values are: calico-apiserver, tigera-queryserver","enum":["calico-apiserver","tigera-queryserver","calico-l7-admission-controller"],"type":"string"},"resources":{"description":"Resources
    allows customization of limits and requests for compute resources such as cpu
    and memory.\nIf specified, this overrides the named API server Deployment container''s
    resources.\nIf omitted, the API server Deployment will use its default value for
    this container''s resources.\nIf used in conjunction with the deprecated ComponentResources,
    then this value takes precedence.","properties":{"claims":{"description":"Claims
    lists the names of resources, defined in spec.resourceClaims,\nthat are used by
    this container.\nThis is an alpha field and requires enabling the\nDynamicResourceAllocation
    feature gate.\nThis field is immutable. It can only be set for containers.","items":{"description":"ResourceClaim
    references one entry in PodSpec.ResourceClaims.","properties":{"name":{"description":"Name
    must match the name of one entry in pod.spec.resourceClaims of\nthe Pod where
    this field is used. It makes that resource available\ninside a container.","type":"string"}},"required":["name"],"type":"object"},"type":"array","x-kubernetes-list-map-keys":["name"],"x-kubernetes-list-type":"map"},"limits":{"additionalProperties":{"anyOf":[{"type":"integer"},{"type":"string"}],"pattern":"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$","x-kubernetes-int-or-string":true},"description":"Limits
    describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/","type":"object"},"requests":{"additionalProperties":{"anyOf":[{"type":"integer"},{"type":"string"}],"pattern":"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$","x-kubernetes-int-or-string":true},"description":"Requests
    describes the minimum amount of compute resources required.\nIf Requests is omitted
    for a container, it defaults to Limits if that is explicitly specified,\notherwise
    to an implementation-defined value. Requests cannot exceed Limits.\nMore info:
    https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/","type":"object"}},"type":"object"}},"required":["name"],"type":"object"},"type":"array"},"initContainers":{"description":"InitContainers
    is a list of API server init containers.\nIf specified, this overrides the specified
    API server Deployment init containers.\nIf omitted, the API server Deployment
    will use its default values for its init containers.","items":{"description":"APIServerDeploymentInitContainer
    is an API server Deployment init container.","properties":{"name":{"description":"Name
    is an enum which identifies the API server Deployment init container by name.\nSupported
    values are: calico-apiserver-certs-key-cert-provisioner","enum":["calico-apiserver-certs-key-cert-provisioner"],"type":"string"},"resources":{"description":"Resources
    allows customization of limits and requests for compute resources such as cpu
    and memory.\nIf specified, this overrides the named API server Deployment init
    container''s resources.\nIf omitted, the API server Deployment will use its default
    value for this init container''s resources.","properties":{"claims":{"description":"Claims
    lists the names of resources, defined in spec.resourceClaims,\nthat are used by
    this container.\nThis is an alpha field and requires enabling the\nDynamicResourceAllocation
    feature gate.\nThis field is immutable. It can only be set for containers.","items":{"description":"ResourceClaim
    references one entry in PodSpec.ResourceClaims.","properties":{"name":{"description":"Name
    must match the name of one entry in pod.spec.resourceClaims of\nthe Pod where
    this field is used. It makes that resource available\ninside a container.","type":"string"}},"required":["name"],"type":"object"},"type":"array","x-kubernetes-list-map-keys":["name"],"x-kubernetes-list-type":"map"},"limits":{"additionalProperties":{"anyOf":[{"type":"integer"},{"type":"string"}],"pattern":"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$","x-kubernetes-int-or-string":true},"description":"Limits
    describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/","type":"object"},"requests":{"additionalProperties":{"anyOf":[{"type":"integer"},{"type":"string"}],"pattern":"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$","x-kubernetes-int-or-string":true},"description":"Requests
    describes the minimum amount of compute resources required.\nIf Requests is omitted
    for a container, it defaults to Limits if that is explicitly specified,\notherwise
    to an implementation-defined value. Requests cannot exceed Limits.\nMore info:
    https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/","type":"object"}},"type":"object"}},"required":["name"],"type":"object"},"type":"array"},"nodeSelector":{"additionalProperties":{"type":"string"},"description":"NodeSelector
    is the API server pod''s scheduling constraints.\nIf specified, each of the key/value
    pairs are added to the API server Deployment nodeSelector provided\nthe key does
    not already exist in the object''s nodeSelector.\nIf used in conjunction with
    ControlPlaneNodeSelector, that nodeSelector is set on the API server Deployment\nand
    each of this field''s key/value pairs are added to the API server Deployment nodeSelector
    provided\nthe key does not already exist in the object''s nodeSelector.\nIf omitted,
    the API server Deployment will use its default value for nodeSelector.\nWARNING:
    Please note that this field will modify the default API server Deployment nodeSelector.","type":"object"},"priorityClassName":{"description":"PriorityClassName
    allows to specify a PriorityClass resource to be used.","type":"string"},"tolerations":{"description":"Tolerations
    is the API server pod''s tolerations.\nIf specified, this overrides any tolerations
    that may be set on the API server Deployment.\nIf omitted, the API server Deployment
    will use its default value for tolerations.\nWARNING: Please note that this field
    will override the default API server Deployment tolerations.","items":{"description":"The
    pod this Toleration is attached to tolerates any taint that matches\nthe triple
    <key,value,effect> using the matching operator <operator>.","properties":{"effect":{"description":"Effect
    indicates the taint effect to match. Empty means match all taint effects.\nWhen
    specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.","type":"string"},"key":{"description":"Key
    is the taint key that the toleration applies to. Empty means match all taint keys.\nIf
    the key is empty, operator must be Exists; this combination means to match all
    values and all keys.","type":"string"},"operator":{"description":"Operator represents
    a key''s relationship to the value.\nValid operators are Exists and Equal. Defaults
    to Equal.\nExists is equivalent to wildcard for value, so that a pod can\ntolerate
    all taints of a particular category.","type":"string"},"tolerationSeconds":{"description":"TolerationSeconds
    represents the period of time the toleration (which must be\nof effect NoExecute,
    otherwise this field is ignored) tolerates the taint. By default,\nit is not set,
    which means tolerate the taint forever (do not evict). Zero and\nnegative values
    will be treated as 0 (evict immediately) by the system.","format":"int64","type":"integer"},"value":{"description":"Value
    is the taint value the toleration matches to.\nIf the operator is Exists, the
    value should be empty, otherwise just a regular string.","type":"string"}},"type":"object"},"type":"array"},"topologySpreadConstraints":{"description":"TopologySpreadConstraints
    describes how a group of pods ought to spread across topology\ndomains. Scheduler
    will schedule pods in a way which abides by the constraints.\nAll topologySpreadConstraints
    are ANDed.","items":{"description":"TopologySpreadConstraint specifies how to
    spread matching pods among the given topology.","properties":{"labelSelector":{"description":"LabelSelector
    is used to find matching pods.\nPods that match this label selector are counted
    to determine the number of pods\nin their corresponding topology domain.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"matchLabelKeys":{"description":"MatchLabelKeys
    is a set of pod label keys to select the pods over which\nspreading will be calculated.
    The keys are used to lookup values from the\nincoming pod labels, those key-value
    labels are ANDed with labelSelector\nto select the group of existing pods over
    which spreading will be calculated\nfor the incoming pod. The same key is forbidden
    to exist in both MatchLabelKeys and LabelSelector.\nMatchLabelKeys cannot be set
    when LabelSelector isn''t set.\nKeys that don''t exist in the incoming pod labels
    will\nbe ignored. A null or empty list means only match against labelSelector.\nThis
    is a beta field and requires the MatchLabelKeysInPodTopologySpread feature gate
    to be enabled (enabled by default).","items":{"type":"string"},"type":"array","x-kubernetes-list-type":"atomic"},"maxSkew":{"description":"MaxSkew
    describes the degree to which pods may be unevenly distributed.\nWhen `whenUnsatisfiable=DoNotSchedule`,
    it is the maximum permitted difference\nbetween the number of matching pods in
    the target topology and the global minimum.\nThe global minimum is the minimum
    number of matching pods in an eligible domain\nor zero if the number of eligible
    domains is less than MinDomains.\nFor example, in a 3-zone cluster, MaxSkew is
    set to 1, and pods with the same\nlabelSelector spread as 2/2/1:\nIn this case,
    the global minimum is 1.\n| zone1 | zone2 | zone3 |\n|  P P  |  P P  |   P   |\n-
    if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 2/2/2;\nscheduling
    it onto zone1(zone2) would make the ActualSkew(3-1) on zone1(zone2)\nviolate MaxSkew(1).\n-
    if MaxSkew is 2, incoming pod can be scheduled onto any zone.\nWhen `whenUnsatisfiable=ScheduleAnyway`,
    it is used to give higher precedence\nto topologies that satisfy it.\nIt''s a
    required field. Default value is 1 and 0 is not allowed.","format":"int32","type":"integer"},"minDomains":{"description":"MinDomains
    indicates a minimum number of eligible domains.\nWhen the number of eligible domains
    with matching topology keys is less than minDomains,\nPod Topology Spread treats
    \"global minimum\" as 0, and then the calculation of Skew is performed.\nAnd when
    the number of eligible domains with matching topology keys equals or greater than
    minDomains,\nthis value has no effect on scheduling.\nAs a result, when the number
    of eligible domains is less than minDomains,\nscheduler won''t schedule more than
    maxSkew Pods to those domains.\nIf value is nil, the constraint behaves as if
    MinDomains is equal to 1.\nValid values are integers greater than 0.\nWhen value
    is not nil, WhenUnsatisfiable must be DoNotSchedule.\nFor example, in a 3-zone
    cluster, MaxSkew is set to 2, MinDomains is set to 5 and pods with the same\nlabelSelector
    spread as 2/2/2:\n| zone1 | zone2 | zone3 |\n|  P P  |  P P  |  P P  |\nThe number
    of domains is less than 5(MinDomains), so \"global minimum\" is treated as 0.\nIn
    this situation, new pod with the same labelSelector cannot be scheduled,\nbecause
    computed skew will be 3(3 - 0) if new Pod is scheduled to any of the three zones,\nit
    will violate MaxSkew.\nThis is a beta field and requires the MinDomainsInPodTopologySpread
    feature gate to be enabled (enabled by default).","format":"int32","type":"integer"},"nodeAffinityPolicy":{"description":"NodeAffinityPolicy
    indicates how we will treat Pod''s nodeAffinity/nodeSelector\nwhen calculating
    pod topology spread skew. Options are:\n- Honor: only nodes matching nodeAffinity/nodeSelector
    are included in the calculations.\n- Ignore: nodeAffinity/nodeSelector are ignored.
    All nodes are included in the calculations.\nIf this value is nil, the behavior
    is equivalent to the Honor policy.\nThis is a beta-level feature default enabled
    by the NodeInclusionPolicyInPodTopologySpread feature flag.","type":"string"},"nodeTaintsPolicy":{"description":"NodeTaintsPolicy
    indicates how we will treat node taints when calculating\npod topology spread
    skew. Options are:\n- Honor: nodes without taints, along with tainted nodes for
    which the incoming pod\nhas a toleration, are included.\n- Ignore: node taints
    are ignored. All nodes are included.\nIf this value is nil, the behavior is equivalent
    to the Ignore policy.\nThis is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread
    feature flag.","type":"string"},"topologyKey":{"description":"TopologyKey is the
    key of node labels. Nodes that have a label with this key\nand identical values
    are considered to be in the same topology.\nWe consider each <key, value> as a
    \"bucket\", and try to put balanced number\nof pods into each bucket.\nWe define
    a domain as a particular instance of a topology.\nAlso, we define an eligible
    domain as a domain whose nodes meet the requirements of\nnodeAffinityPolicy and
    nodeTaintsPolicy.\ne.g. If TopologyKey is \"kubernetes.io/hostname\", each Node
    is a domain of that topology.\nAnd, if TopologyKey is \"topology.kubernetes.io/zone\",
    each zone is a domain of that topology.\nIt''s a required field.","type":"string"},"whenUnsatisfiable":{"description":"WhenUnsatisfiable
    indicates how to deal with a pod if it doesn''t satisfy\nthe spread constraint.\n-
    DoNotSchedule (default) tells the scheduler not to schedule it.\n- ScheduleAnyway
    tells the scheduler to schedule the pod in any location,\n  but giving higher
    precedence to topologies that would help reduce the\n  skew.\nA constraint is
    considered \"Unsatisfiable\" for an incoming pod\nif and only if every possible
    node assignment for that pod would violate\n\"MaxSkew\" on some topology.\nFor
    example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same\nlabelSelector
    spread as 3/1/1:\n| zone1 | zone2 | zone3 |\n| P P P |   P   |   P   |\nIf WhenUnsatisfiable
    is set to DoNotSchedule, incoming pod can only be scheduled\nto zone2(zone3) to
    become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies\nMaxSkew(1).
    In other words, the cluster can still be imbalanced, but scheduler\nwon''t make
    it *more* imbalanced.\nIt''s a required field.","type":"string"}},"required":["maxSkew","topologyKey","whenUnsatisfiable"],"type":"object"},"type":"array"}},"type":"object"}},"type":"object"}},"type":"object"}},"type":"object"}},"type":"object"},"status":{"description":"Most
    recently observed status for the Tigera API server.","properties":{"conditions":{"description":"Conditions
    represents the latest observed set of conditions for the component. A component
    may be one or more of\nReady, Progressing, Degraded or other customer types.","items":{"description":"Condition
    contains details for one aspect of the current state of this API Resource.\n---\nThis
    struct is intended for direct use as an array at the field path .status.conditions.  For
    example,\n\n\n\ttype FooStatus struct{\n\t    // Represents the observations of
    a foo''s current state.\n\t    // Known .status.conditions.type are: \"Available\",
    \"Progressing\", and \"Degraded\"\n\t    // +patchMergeKey=type\n\t    // +patchStrategy=merge\n\t    //
    +listType=map\n\t    // +listMapKey=type\n\t    Conditions []metav1.Condition
    `json:\"conditions,omitempty\" patchStrategy:\"merge\" patchMergeKey:\"type\"
    protobuf:\"bytes,1,rep,name=conditions\"`\n\n\n\t    // other fields\n\t}","properties":{"lastTransitionTime":{"description":"lastTransitionTime
    is the last time the condition transitioned from one status to another.\nThis
    should be when the underlying condition changed.  If that is not known, then using
    the time when the API field changed is acceptable.","format":"date-time","type":"string"},"message":{"description":"message
    is a human readable message indicating details about the transition.\nThis may
    be an empty string.","maxLength":32768,"type":"string"},"observedGeneration":{"description":"observedGeneration
    represents the .metadata.generation that the condition was set based upon.\nFor
    instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration
    is 9, the condition is out of date\nwith respect to the current state of the instance.","format":"int64","minimum":0,"type":"integer"},"reason":{"description":"reason
    contains a programmatic identifier indicating the reason for the condition''s
    last transition.\nProducers of specific condition types may define expected values
    and meanings for this field,\nand whether the values are considered a guaranteed
    API.\nThe value should be a CamelCase string.\nThis field may not be empty.","maxLength":1024,"minLength":1,"pattern":"^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$","type":"string"},"status":{"description":"status
    of the condition, one of True, False, Unknown.","enum":["True","False","Unknown"],"type":"string"},"type":{"description":"type
    of condition in CamelCase or in foo.example.com/CamelCase.\n---\nMany .condition.type
    values are consistent across resources like Available, but because arbitrary conditions
    can be\nuseful (see .node.status.conditions), the ability to deconflict is important.\nThe
    regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)","maxLength":316,"pattern":"^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$","type":"string"}},"required":["lastTransitionTime","message","reason","status","type"],"type":"object"},"type":"array"},"state":{"description":"State
    provides user-readable status.","type":"string"}},"type":"object"}},"type":"object"}},"served":true,"storage":true,"subresources":{"status":{}}}]}},{"apiVersion":"apiextensions.k8s.io/v1","kind":"CustomResourceDefinition","metadata":{"annotations":{"controller-gen.kubebuilder.io/version":"v0.14.0"},"name":"imagesets.operator.tigera.io"},"spec":{"group":"operator.tigera.io","names":{"kind":"ImageSet","listKind":"ImageSetList","plural":"imagesets","singular":"imageset"},"scope":"Cluster","versions":[{"name":"v1","schema":{"openAPIV3Schema":{"description":"ImageSet
    is used to specify image digests for the images that the operator deploys.\nThe
    name of the ImageSet is expected to be in the format `<variant>-<release>`.\nThe
    `variant` used is `enterprise` if the InstallationSpec Variant is\n`TigeraSecureEnterprise`
    otherwise it is `calico`.\nThe `release` must match the version of the variant
    that the operator is built to deploy,\nthis version can be obtained by passing
    the `--version` flag to the operator binary.","properties":{"apiVersion":{"description":"APIVersion
    defines the versioned schema of this representation of an object.\nServers should
    convert recognized schemas to the latest internal value, and\nmay reject unrecognized
    values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","type":"string"},"kind":{"description":"Kind
    is a string value representing the REST resource this object represents.\nServers
    may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn
    CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","type":"string"},"metadata":{"type":"object"},"spec":{"description":"ImageSetSpec
    defines the desired state of ImageSet.","properties":{"images":{"description":"Images
    is the list of images to use digests. All images that the operator will deploy\nmust
    be specified.","items":{"properties":{"digest":{"description":"Digest is the image
    identifier that will be used for the Image.\nThe field should not include a leading
    `@` and must be prefixed with `sha256:`.","type":"string"},"image":{"description":"Image
    is an image that the operator deploys and instead of using the built in tag\nthe
    operator will use the Digest for the image identifier.\nThe value should be the
    image name without registry or tag or digest.\nFor the image `docker.io/calico/node:v3.17.1`
    it should be represented as `calico/node`","type":"string"}},"required":["digest","image"],"type":"object"},"type":"array"}},"type":"object"}},"type":"object"}},"served":true,"storage":true,"subresources":{"status":{}}}]}},{"apiVersion":"apiextensions.k8s.io/v1","kind":"CustomResourceDefinition","metadata":{"annotations":{"controller-gen.kubebuilder.io/version":"v0.14.0"},"name":"installations.operator.tigera.io"},"spec":{"group":"operator.tigera.io","names":{"kind":"Installation","listKind":"InstallationList","plural":"installations","singular":"installation"},"scope":"Cluster","versions":[{"name":"v1","schema":{"openAPIV3Schema":{"description":"Installation
    configures an installation of Calico or Calico Enterprise. At most one instance\nof
    this resource is supported. It must be named \"default\". The Installation API
    installs core networking\nand network policy components, and provides general
    install-time configuration.","properties":{"apiVersion":{"description":"APIVersion
    defines the versioned schema of this representation of an object.\nServers should
    convert recognized schemas to the latest internal value, and\nmay reject unrecognized
    values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","type":"string"},"kind":{"description":"Kind
    is a string value representing the REST resource this object represents.\nServers
    may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn
    CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","type":"string"},"metadata":{"type":"object"},"spec":{"description":"Specification
    of the desired state for the Calico or Calico Enterprise installation.","properties":{"azure":{"description":"Azure
    is used to configure azure provider specific options.","properties":{"policyMode":{"default":"Default","description":"PolicyMode
    determines whether the \"control-plane\" label is applied to namespaces. It offers
    two options: Default and Manual.\nThe Default option adds the \"control-plane\"
    label to the required namespaces.\nThe Manual option does not apply the \"control-plane\"
    label to any namespace.\nDefault: Default","enum":["Default","Manual"],"type":"string"}},"type":"object"},"calicoKubeControllersDeployment":{"description":"CalicoKubeControllersDeployment
    configures the calico-kube-controllers Deployment. If used in\nconjunction with
    the deprecated ComponentResources, then these overrides take precedence.","properties":{"metadata":{"description":"Metadata
    is a subset of a Kubernetes object''s metadata that is added to the Deployment.","properties":{"annotations":{"additionalProperties":{"type":"string"},"description":"Annotations
    is a map of arbitrary non-identifying metadata. Each of these\nkey/value pairs
    are added to the object''s annotations provided the key does not\nalready exist
    in the object''s annotations.","type":"object"},"labels":{"additionalProperties":{"type":"string"},"description":"Labels
    is a map of string keys and values that may match replicaset and\nservice selectors.
    Each of these key/value pairs are added to the\nobject''s labels provided the
    key does not already exist in the object''s labels.","type":"object"}},"type":"object"},"spec":{"description":"Spec
    is the specification of the calico-kube-controllers Deployment.","properties":{"minReadySeconds":{"description":"MinReadySeconds
    is the minimum number of seconds for which a newly created Deployment pod should\nbe
    ready without any of its container crashing, for it to be considered available.\nIf
    specified, this overrides any minReadySeconds value that may be set on the calico-kube-controllers
    Deployment.\nIf omitted, the calico-kube-controllers Deployment will use its default
    value for minReadySeconds.","format":"int32","maximum":2147483647,"minimum":0,"type":"integer"},"template":{"description":"Template
    describes the calico-kube-controllers Deployment pod that will be created.","properties":{"metadata":{"description":"Metadata
    is a subset of a Kubernetes object''s metadata that is added to\nthe pod''s metadata.","properties":{"annotations":{"additionalProperties":{"type":"string"},"description":"Annotations
    is a map of arbitrary non-identifying metadata. Each of these\nkey/value pairs
    are added to the object''s annotations provided the key does not\nalready exist
    in the object''s annotations.","type":"object"},"labels":{"additionalProperties":{"type":"string"},"description":"Labels
    is a map of string keys and values that may match replicaset and\nservice selectors.
    Each of these key/value pairs are added to the\nobject''s labels provided the
    key does not already exist in the object''s labels.","type":"object"}},"type":"object"},"spec":{"description":"Spec
    is the calico-kube-controllers Deployment''s PodSpec.","properties":{"affinity":{"description":"Affinity
    is a group of affinity scheduling rules for the calico-kube-controllers pods.\nIf
    specified, this overrides any affinity that may be set on the calico-kube-controllers
    Deployment.\nIf omitted, the calico-kube-controllers Deployment will use its default
    value for affinity.\nWARNING: Please note that this field will override the default
    calico-kube-controllers Deployment affinity.","properties":{"nodeAffinity":{"description":"Describes
    node affinity scheduling rules for the pod.","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"description":"The
    scheduler will prefer to schedule pods to nodes that satisfy\nthe affinity expressions
    specified by this field, but it may choose\na node that violates one or more of
    the expressions. The node that is\nmost preferred is the one with the greatest
    sum of weights, i.e.\nfor each node that meets all of the scheduling requirements
    (resource\nrequest, requiredDuringScheduling affinity expressions, etc.),\ncompute
    a sum by iterating through the elements of this field and adding\n\"weight\" to
    the sum if the node matches the corresponding matchExpressions; the\nnode(s) with
    the highest sum are the most preferred.","items":{"description":"An empty preferred
    scheduling term matches all objects with implicit weight 0\n(i.e. it''s a no-op).
    A null preferred scheduling term matches no objects (i.e. is also a no-op).","properties":{"preference":{"description":"A
    node selector term, associated with the corresponding weight.","properties":{"matchExpressions":{"description":"A
    list of node selector requirements by node''s labels.","items":{"description":"A
    node selector requirement is a selector that contains values, a key, and an operator\nthat
    relates the key and values.","properties":{"key":{"description":"The label key
    that the selector applies to.","type":"string"},"operator":{"description":"Represents
    a key''s relationship to a set of values.\nValid operators are In, NotIn, Exists,
    DoesNotExist. Gt, and Lt.","type":"string"},"values":{"description":"An array
    of string values. If the operator is In or NotIn,\nthe values array must be non-empty.
    If the operator is Exists or DoesNotExist,\nthe values array must be empty. If
    the operator is Gt or Lt, the values\narray must have a single element, which
    will be interpreted as an integer.\nThis array is replaced during a strategic
    merge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchFields":{"description":"A
    list of node selector requirements by node''s fields.","items":{"description":"A
    node selector requirement is a selector that contains values, a key, and an operator\nthat
    relates the key and values.","properties":{"key":{"description":"The label key
    that the selector applies to.","type":"string"},"operator":{"description":"Represents
    a key''s relationship to a set of values.\nValid operators are In, NotIn, Exists,
    DoesNotExist. Gt, and Lt.","type":"string"},"values":{"description":"An array
    of string values. If the operator is In or NotIn,\nthe values array must be non-empty.
    If the operator is Exists or DoesNotExist,\nthe values array must be empty. If
    the operator is Gt or Lt, the values\narray must have a single element, which
    will be interpreted as an integer.\nThis array is replaced during a strategic
    merge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"}},"type":"object","x-kubernetes-map-type":"atomic"},"weight":{"description":"Weight
    associated with matching the corresponding nodeSelectorTerm, in the range 1-100.","format":"int32","type":"integer"}},"required":["preference","weight"],"type":"object"},"type":"array"},"requiredDuringSchedulingIgnoredDuringExecution":{"description":"If
    the affinity requirements specified by this field are not met at\nscheduling time,
    the pod will not be scheduled onto the node.\nIf the affinity requirements specified
    by this field cease to be met\nat some point during pod execution (e.g. due to
    an update), the system\nmay or may not try to eventually evict the pod from its
    node.","properties":{"nodeSelectorTerms":{"description":"Required. A list of node
    selector terms. The terms are ORed.","items":{"description":"A null or empty node
    selector term matches no objects. The requirements of\nthem are ANDed.\nThe TopologySelectorTerm
    type implements a subset of the NodeSelectorTerm.","properties":{"matchExpressions":{"description":"A
    list of node selector requirements by node''s labels.","items":{"description":"A
    node selector requirement is a selector that contains values, a key, and an operator\nthat
    relates the key and values.","properties":{"key":{"description":"The label key
    that the selector applies to.","type":"string"},"operator":{"description":"Represents
    a key''s relationship to a set of values.\nValid operators are In, NotIn, Exists,
    DoesNotExist. Gt, and Lt.","type":"string"},"values":{"description":"An array
    of string values. If the operator is In or NotIn,\nthe values array must be non-empty.
    If the operator is Exists or DoesNotExist,\nthe values array must be empty. If
    the operator is Gt or Lt, the values\narray must have a single element, which
    will be interpreted as an integer.\nThis array is replaced during a strategic
    merge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchFields":{"description":"A
    list of node selector requirements by node''s fields.","items":{"description":"A
    node selector requirement is a selector that contains values, a key, and an operator\nthat
    relates the key and values.","properties":{"key":{"description":"The label key
    that the selector applies to.","type":"string"},"operator":{"description":"Represents
    a key''s relationship to a set of values.\nValid operators are In, NotIn, Exists,
    DoesNotExist. Gt, and Lt.","type":"string"},"values":{"description":"An array
    of string values. If the operator is In or NotIn,\nthe values array must be non-empty.
    If the operator is Exists or DoesNotExist,\nthe values array must be empty. If
    the operator is Gt or Lt, the values\narray must have a single element, which
    will be interpreted as an integer.\nThis array is replaced during a strategic
    merge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"}},"type":"object","x-kubernetes-map-type":"atomic"},"type":"array"}},"required":["nodeSelectorTerms"],"type":"object","x-kubernetes-map-type":"atomic"}},"type":"object"},"podAffinity":{"description":"Describes
    pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone,
    etc. as some other pod(s)).","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"description":"The
    scheduler will prefer to schedule pods to nodes that satisfy\nthe affinity expressions
    specified by this field, but it may choose\na node that violates one or more of
    the expressions. The node that is\nmost preferred is the one with the greatest
    sum of weights, i.e.\nfor each node that meets all of the scheduling requirements
    (resource\nrequest, requiredDuringScheduling affinity expressions, etc.),\ncompute
    a sum by iterating through the elements of this field and adding\n\"weight\" to
    the sum if the node has pods which matches the corresponding podAffinityTerm;
    the\nnode(s) with the highest sum are the most preferred.","items":{"description":"The
    weights of all of the matched WeightedPodAffinityTerm fields are added per-node
    to find the most preferred node(s)","properties":{"podAffinityTerm":{"description":"Required.
    A pod affinity term, associated with the corresponding weight.","properties":{"labelSelector":{"description":"A
    label query over a set of resources, in this case pods.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaceSelector":{"description":"A
    label query over the set of namespaces that the term applies to.\nThe term is
    applied to the union of the namespaces selected by this field\nand the ones listed
    in the namespaces field.\nnull selector and null or empty namespaces list means
    \"this pod''s namespace\".\nAn empty selector ({}) matches all namespaces.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaces":{"description":"namespaces
    specifies a static list of namespace names that the term applies to.\nThe term
    is applied to the union of the namespaces listed in this field\nand the ones selected
    by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector
    means \"this pod''s namespace\".","items":{"type":"string"},"type":"array"},"topologyKey":{"description":"This
    pod should be co-located (affinity) or not co-located (anti-affinity) with the
    pods matching\nthe labelSelector in the specified namespaces, where co-located
    is defined as running on a node\nwhose value of the label with key topologyKey
    matches that of any node on which any of the\nselected pods is running.\nEmpty
    topologyKey is not allowed.","type":"string"}},"required":["topologyKey"],"type":"object"},"weight":{"description":"weight
    associated with matching the corresponding podAffinityTerm,\nin the range 1-100.","format":"int32","type":"integer"}},"required":["podAffinityTerm","weight"],"type":"object"},"type":"array"},"requiredDuringSchedulingIgnoredDuringExecution":{"description":"If
    the affinity requirements specified by this field are not met at\nscheduling time,
    the pod will not be scheduled onto the node.\nIf the affinity requirements specified
    by this field cease to be met\nat some point during pod execution (e.g. due to
    a pod label update), the\nsystem may or may not try to eventually evict the pod
    from its node.\nWhen there are multiple elements, the lists of nodes corresponding
    to each\npodAffinityTerm are intersected, i.e. all terms must be satisfied.","items":{"description":"Defines
    a set of pods (namely those matching the labelSelector\nrelative to the given
    namespace(s)) that this pod should be\nco-located (affinity) or not co-located
    (anti-affinity) with,\nwhere co-located is defined as running on a node whose
    value of\nthe label with key <topologyKey> matches that of any node on which\na
    pod of the set of pods is running","properties":{"labelSelector":{"description":"A
    label query over a set of resources, in this case pods.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaceSelector":{"description":"A
    label query over the set of namespaces that the term applies to.\nThe term is
    applied to the union of the namespaces selected by this field\nand the ones listed
    in the namespaces field.\nnull selector and null or empty namespaces list means
    \"this pod''s namespace\".\nAn empty selector ({}) matches all namespaces.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaces":{"description":"namespaces
    specifies a static list of namespace names that the term applies to.\nThe term
    is applied to the union of the namespaces listed in this field\nand the ones selected
    by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector
    means \"this pod''s namespace\".","items":{"type":"string"},"type":"array"},"topologyKey":{"description":"This
    pod should be co-located (affinity) or not co-located (anti-affinity) with the
    pods matching\nthe labelSelector in the specified namespaces, where co-located
    is defined as running on a node\nwhose value of the label with key topologyKey
    matches that of any node on which any of the\nselected pods is running.\nEmpty
    topologyKey is not allowed.","type":"string"}},"required":["topologyKey"],"type":"object"},"type":"array"}},"type":"object"},"podAntiAffinity":{"description":"Describes
    pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node,
    zone, etc. as some other pod(s)).","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"description":"The
    scheduler will prefer to schedule pods to nodes that satisfy\nthe anti-affinity
    expressions specified by this field, but it may choose\na node that violates one
    or more of the expressions. The node that is\nmost preferred is the one with the
    greatest sum of weights, i.e.\nfor each node that meets all of the scheduling
    requirements (resource\nrequest, requiredDuringScheduling anti-affinity expressions,
    etc.),\ncompute a sum by iterating through the elements of this field and adding\n\"weight\"
    to the sum if the node has pods which matches the corresponding podAffinityTerm;
    the\nnode(s) with the highest sum are the most preferred.","items":{"description":"The
    weights of all of the matched WeightedPodAffinityTerm fields are added per-node
    to find the most preferred node(s)","properties":{"podAffinityTerm":{"description":"Required.
    A pod affinity term, associated with the corresponding weight.","properties":{"labelSelector":{"description":"A
    label query over a set of resources, in this case pods.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaceSelector":{"description":"A
    label query over the set of namespaces that the term applies to.\nThe term is
    applied to the union of the namespaces selected by this field\nand the ones listed
    in the namespaces field.\nnull selector and null or empty namespaces list means
    \"this pod''s namespace\".\nAn empty selector ({}) matches all namespaces.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaces":{"description":"namespaces
    specifies a static list of namespace names that the term applies to.\nThe term
    is applied to the union of the namespaces listed in this field\nand the ones selected
    by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector
    means \"this pod''s namespace\".","items":{"type":"string"},"type":"array"},"topologyKey":{"description":"This
    pod should be co-located (affinity) or not co-located (anti-affinity) with the
    pods matching\nthe labelSelector in the specified namespaces, where co-located
    is defined as running on a node\nwhose value of the label with key topologyKey
    matches that of any node on which any of the\nselected pods is running.\nEmpty
    topologyKey is not allowed.","type":"string"}},"required":["topologyKey"],"type":"object"},"weight":{"description":"weight
    associated with matching the corresponding podAffinityTerm,\nin the range 1-100.","format":"int32","type":"integer"}},"required":["podAffinityTerm","weight"],"type":"object"},"type":"array"},"requiredDuringSchedulingIgnoredDuringExecution":{"description":"If
    the anti-affinity requirements specified by this field are not met at\nscheduling
    time, the pod will not be scheduled onto the node.\nIf the anti-affinity requirements
    specified by this field cease to be met\nat some point during pod execution (e.g.
    due to a pod label update), the\nsystem may or may not try to eventually evict
    the pod from its node.\nWhen there are multiple elements, the lists of nodes corresponding
    to each\npodAffinityTerm are intersected, i.e. all terms must be satisfied.","items":{"description":"Defines
    a set of pods (namely those matching the labelSelector\nrelative to the given
    namespace(s)) that this pod should be\nco-located (affinity) or not co-located
    (anti-affinity) with,\nwhere co-located is defined as running on a node whose
    value of\nthe label with key <topologyKey> matches that of any node on which\na
    pod of the set of pods is running","properties":{"labelSelector":{"description":"A
    label query over a set of resources, in this case pods.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaceSelector":{"description":"A
    label query over the set of namespaces that the term applies to.\nThe term is
    applied to the union of the namespaces selected by this field\nand the ones listed
    in the namespaces field.\nnull selector and null or empty namespaces list means
    \"this pod''s namespace\".\nAn empty selector ({}) matches all namespaces.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaces":{"description":"namespaces
    specifies a static list of namespace names that the term applies to.\nThe term
    is applied to the union of the namespaces listed in this field\nand the ones selected
    by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector
    means \"this pod''s namespace\".","items":{"type":"string"},"type":"array"},"topologyKey":{"description":"This
    pod should be co-located (affinity) or not co-located (anti-affinity) with the
    pods matching\nthe labelSelector in the specified namespaces, where co-located
    is defined as running on a node\nwhose value of the label with key topologyKey
    matches that of any node on which any of the\nselected pods is running.\nEmpty
    topologyKey is not allowed.","type":"string"}},"required":["topologyKey"],"type":"object"},"type":"array"}},"type":"object"}},"type":"object"},"containers":{"description":"Containers
    is a list of calico-kube-controllers containers.\nIf specified, this overrides
    the specified calico-kube-controllers Deployment containers.\nIf omitted, the
    calico-kube-controllers Deployment will use its default values for its containers.","items":{"description":"CalicoKubeControllersDeploymentContainer
    is a calico-kube-controllers Deployment container.","properties":{"name":{"description":"Name
    is an enum which identifies the calico-kube-controllers Deployment container by
    name.\nSupported values are: calico-kube-controllers, es-calico-kube-controllers","enum":["calico-kube-controllers","es-calico-kube-controllers"],"type":"string"},"resources":{"description":"Resources
    allows customization of limits and requests for compute resources such as cpu
    and memory.\nIf specified, this overrides the named calico-kube-controllers Deployment
    container''s resources.\nIf omitted, the calico-kube-controllers Deployment will
    use its default value for this container''s resources.\nIf used in conjunction
    with the deprecated ComponentResources, then this value takes precedence.","properties":{"claims":{"description":"Claims
    lists the names of resources, defined in spec.resourceClaims,\nthat are used by
    this container.\nThis is an alpha field and requires enabling the\nDynamicResourceAllocation
    feature gate.\nThis field is immutable. It can only be set for containers.","items":{"description":"ResourceClaim
    references one entry in PodSpec.ResourceClaims.","properties":{"name":{"description":"Name
    must match the name of one entry in pod.spec.resourceClaims of\nthe Pod where
    this field is used. It makes that resource available\ninside a container.","type":"string"}},"required":["name"],"type":"object"},"type":"array","x-kubernetes-list-map-keys":["name"],"x-kubernetes-list-type":"map"},"limits":{"additionalProperties":{"anyOf":[{"type":"integer"},{"type":"string"}],"pattern":"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$","x-kubernetes-int-or-string":true},"description":"Limits
    describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/","type":"object"},"requests":{"additionalProperties":{"anyOf":[{"type":"integer"},{"type":"string"}],"pattern":"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$","x-kubernetes-int-or-string":true},"description":"Requests
    describes the minimum amount of compute resources required.\nIf Requests is omitted
    for a container, it defaults to Limits if that is explicitly specified,\notherwise
    to an implementation-defined value. Requests cannot exceed Limits.\nMore info:
    https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/","type":"object"}},"type":"object"}},"required":["name"],"type":"object"},"type":"array"},"nodeSelector":{"additionalProperties":{"type":"string"},"description":"NodeSelector
    is the calico-kube-controllers pod''s scheduling constraints.\nIf specified, each
    of the key/value pairs are added to the calico-kube-controllers Deployment nodeSelector
    provided\nthe key does not already exist in the object''s nodeSelector.\nIf used
    in conjunction with ControlPlaneNodeSelector, that nodeSelector is set on the
    calico-kube-controllers Deployment\nand each of this field''s key/value pairs
    are added to the calico-kube-controllers Deployment nodeSelector provided\nthe
    key does not already exist in the object''s nodeSelector.\nIf omitted, the calico-kube-controllers
    Deployment will use its default value for nodeSelector.\nWARNING: Please note
    that this field will modify the default calico-kube-controllers Deployment nodeSelector.","type":"object"},"tolerations":{"description":"Tolerations
    is the calico-kube-controllers pod''s tolerations.\nIf specified, this overrides
    any tolerations that may be set on the calico-kube-controllers Deployment.\nIf
    omitted, the calico-kube-controllers Deployment will use its default value for
    tolerations.\nWARNING: Please note that this field will override the default calico-kube-controllers
    Deployment tolerations.","items":{"description":"The pod this Toleration is attached
    to tolerates any taint that matches\nthe triple <key,value,effect> using the matching
    operator <operator>.","properties":{"effect":{"description":"Effect indicates
    the taint effect to match. Empty means match all taint effects.\nWhen specified,
    allowed values are NoSchedule, PreferNoSchedule and NoExecute.","type":"string"},"key":{"description":"Key
    is the taint key that the toleration applies to. Empty means match all taint keys.\nIf
    the key is empty, operator must be Exists; this combination means to match all
    values and all keys.","type":"string"},"operator":{"description":"Operator represents
    a key''s relationship to the value.\nValid operators are Exists and Equal. Defaults
    to Equal.\nExists is equivalent to wildcard for value, so that a pod can\ntolerate
    all taints of a particular category.","type":"string"},"tolerationSeconds":{"description":"TolerationSeconds
    represents the period of time the toleration (which must be\nof effect NoExecute,
    otherwise this field is ignored) tolerates the taint. By default,\nit is not set,
    which means tolerate the taint forever (do not evict). Zero and\nnegative values
    will be treated as 0 (evict immediately) by the system.","format":"int64","type":"integer"},"value":{"description":"Value
    is the taint value the toleration matches to.\nIf the operator is Exists, the
    value should be empty, otherwise just a regular string.","type":"string"}},"type":"object"},"type":"array"}},"type":"object"}},"type":"object"}},"type":"object"}},"type":"object"},"calicoNetwork":{"description":"CalicoNetwork
    specifies networking configuration options for Calico.","properties":{"bgp":{"description":"BGP
    configures whether or not to enable Calico''s BGP capabilities.","enum":["Enabled","Disabled"],"type":"string"},"containerIPForwarding":{"description":"ContainerIPForwarding
    configures whether ip forwarding will be enabled for containers in the CNI configuration.\nDefault:
    Disabled","enum":["Enabled","Disabled"],"type":"string"},"hostPorts":{"description":"HostPorts
    configures whether or not Calico will support Kubernetes HostPorts. Valid only
    when using the Calico CNI plugin.\nDefault: Enabled","enum":["Enabled","Disabled"],"type":"string"},"ipPools":{"description":"IPPools
    contains a list of IP pools to manage. If nil, a single IP pool\nwill be defaulted.
    If an empty list is provided, the operator will not create any IP pools and will
    instead\nwait for IP pools to be created out-of-band.\nIP pools in this list will
    be reconciled by the operator and should not be modified out-of-band.","items":{"properties":{"allowedUses":{"description":"AllowedUse
    controls what the IP pool will be used for.  If not specified or empty, defaults
    to\n[\"Tunnel\", \"Workload\"] for back-compatibility","items":{"type":"string"},"type":"array"},"blockSize":{"description":"BlockSize
    specifies the CIDR prefex length to use when allocating per-node IP blocks from\nthe
    main IP pool CIDR.\nDefault: 26 (IPv4), 122 (IPv6)","format":"int32","type":"integer"},"cidr":{"description":"CIDR
    contains the address range for the IP Pool in classless inter-domain routing format.","type":"string"},"disableBGPExport":{"default":false,"description":"DisableBGPExport
    specifies whether routes from this IP pool''s CIDR are exported over BGP.\nDefault:
    false","type":"boolean"},"disableNewAllocations":{"description":"DisableNewAllocations
    specifies whether or not new IP allocations are allowed from this pool.\nThis
    is useful when you want to prevent new pods from receiving IP addresses from this
    pool, without\nimpacting any existing pods that have already been assigned addresses
    from this pool.","type":"boolean"},"encapsulation":{"description":"Encapsulation
    specifies the encapsulation type that will be used with\nthe IP Pool.\nDefault:
    IPIP","enum":["IPIPCrossSubnet","IPIP","VXLAN","VXLANCrossSubnet","None"],"type":"string"},"name":{"description":"Name
    is the name of the IP pool. If omitted, this will be generated.","type":"string"},"natOutgoing":{"description":"NATOutgoing
    specifies if NAT will be enabled or disabled for outgoing traffic.\nDefault: Enabled","enum":["Enabled","Disabled"],"type":"string"},"nodeSelector":{"description":"NodeSelector
    specifies the node selector that will be set for the IP Pool.\nDefault: ''all()''","type":"string"}},"required":["cidr"],"type":"object"},"maxItems":25,"type":"array"},"linuxDataplane":{"description":"LinuxDataplane
    is used to select the dataplane used for Linux nodes. In particular, it\ncauses
    the operator to add required mounts and environment variables for the particular
    dataplane.\nIf not specified, iptables mode is used.\nDefault: Iptables","enum":["Iptables","BPF","VPP","Nftables"],"type":"string"},"linuxPolicySetupTimeoutSeconds":{"description":"LinuxPolicySetupTimeoutSeconds
    delays new pods from running containers\nuntil their policy has been programmed
    in the dataplane.\nThe specified delay defines the maximum amount of time\nthat
    the Calico CNI plugin will wait for policy to be programmed.\nOnly applies to
    pods created on Linux nodes.\n* A value of 0 disables pod startup delays.\nDefault:
    0","format":"int32","type":"integer"},"mtu":{"description":"MTU specifies the
    maximum transmission unit to use on the pod network.\nIf not specified, Calico
    will perform MTU auto-detection based on the cluster network.","format":"int32","type":"integer"},"multiInterfaceMode":{"description":"MultiInterfaceMode
    configures what will configure multiple interface per pod. Only valid for Calico
    Enterprise installations\nusing the Calico CNI plugin.\nDefault: None","enum":["None","Multus"],"type":"string"},"nodeAddressAutodetectionV4":{"description":"NodeAddressAutodetectionV4
    specifies an approach to automatically detect node IPv4 addresses. If not specified,\nwill
    use default auto-detection settings to acquire an IPv4 address for each node.","properties":{"canReach":{"description":"CanReach
    enables IP auto-detection based on which source address on the node is used to
    reach the\nspecified IP or domain.","type":"string"},"cidrs":{"description":"CIDRS
    enables IP auto-detection based on which addresses on the nodes are within\none
    of the provided CIDRs.","items":{"type":"string"},"type":"array"},"firstFound":{"description":"FirstFound
    uses default interface matching parameters to select an interface, performing
    best-effort\nfiltering based on well-known interface names.","type":"boolean"},"interface":{"description":"Interface
    enables IP auto-detection based on interfaces that match the given regex.","type":"string"},"kubernetes":{"description":"Kubernetes
    configures Calico to detect node addresses based on the Kubernetes API.","enum":["NodeInternalIP"],"type":"string"},"skipInterface":{"description":"SkipInterface
    enables IP auto-detection based on interfaces that do not match\nthe given regex.","type":"string"}},"type":"object"},"nodeAddressAutodetectionV6":{"description":"NodeAddressAutodetectionV6
    specifies an approach to automatically detect node IPv6 addresses. If not specified,\nIPv6
    addresses will not be auto-detected.","properties":{"canReach":{"description":"CanReach
    enables IP auto-detection based on which source address on the node is used to
    reach the\nspecified IP or domain.","type":"string"},"cidrs":{"description":"CIDRS
    enables IP auto-detection based on which addresses on the nodes are within\none
    of the provided CIDRs.","items":{"type":"string"},"type":"array"},"firstFound":{"description":"FirstFound
    uses default interface matching parameters to select an interface, performing
    best-effort\nfiltering based on well-known interface names.","type":"boolean"},"interface":{"description":"Interface
    enables IP auto-detection based on interfaces that match the given regex.","type":"string"},"kubernetes":{"description":"Kubernetes
    configures Calico to detect node addresses based on the Kubernetes API.","enum":["NodeInternalIP"],"type":"string"},"skipInterface":{"description":"SkipInterface
    enables IP auto-detection based on interfaces that do not match\nthe given regex.","type":"string"}},"type":"object"},"sysctl":{"description":"Sysctl
    configures sysctl parameters for tuning plugin","items":{"properties":{"key":{"enum":["net.ipv4.tcp_keepalive_intvl","net.ipv4.tcp_keepalive_probes","net.ipv4.tcp_keepalive_time"],"type":"string"},"value":{"type":"string"}},"required":["key","value"],"type":"object"},"type":"array"},"windowsDataplane":{"description":"WindowsDataplane
    is used to select the dataplane used for Windows nodes. In particular, it\ncauses
    the operator to add required mounts and environment variables for the particular
    dataplane.\nIf not specified, it is disabled and the operator will not render
    the Calico Windows nodes daemonset.\nDefault: Disabled","enum":["HNS","Disabled"],"type":"string"}},"type":"object"},"calicoNodeDaemonSet":{"description":"CalicoNodeDaemonSet
    configures the calico-node DaemonSet. If used in\nconjunction with the deprecated
    ComponentResources, then these overrides take precedence.","properties":{"metadata":{"description":"Metadata
    is a subset of a Kubernetes object''s metadata that is added to the DaemonSet.","properties":{"annotations":{"additionalProperties":{"type":"string"},"description":"Annotations
    is a map of arbitrary non-identifying metadata. Each of these\nkey/value pairs
    are added to the object''s annotations provided the key does not\nalready exist
    in the object''s annotations.","type":"object"},"labels":{"additionalProperties":{"type":"string"},"description":"Labels
    is a map of string keys and values that may match replicaset and\nservice selectors.
    Each of these key/value pairs are added to the\nobject''s labels provided the
    key does not already exist in the object''s labels.","type":"object"}},"type":"object"},"spec":{"description":"Spec
    is the specification of the calico-node DaemonSet.","properties":{"minReadySeconds":{"description":"MinReadySeconds
    is the minimum number of seconds for which a newly created DaemonSet pod should\nbe
    ready without any of its container crashing, for it to be considered available.\nIf
    specified, this overrides any minReadySeconds value that may be set on the calico-node
    DaemonSet.\nIf omitted, the calico-node DaemonSet will use its default value for
    minReadySeconds.","format":"int32","maximum":2147483647,"minimum":0,"type":"integer"},"template":{"description":"Template
    describes the calico-node DaemonSet pod that will be created.","properties":{"metadata":{"description":"Metadata
    is a subset of a Kubernetes object''s metadata that is added to\nthe pod''s metadata.","properties":{"annotations":{"additionalProperties":{"type":"string"},"description":"Annotations
    is a map of arbitrary non-identifying metadata. Each of these\nkey/value pairs
    are added to the object''s annotations provided the key does not\nalready exist
    in the object''s annotations.","type":"object"},"labels":{"additionalProperties":{"type":"string"},"description":"Labels
    is a map of string keys and values that may match replicaset and\nservice selectors.
    Each of these key/value pairs are added to the\nobject''s labels provided the
    key does not already exist in the object''s labels.","type":"object"}},"type":"object"},"spec":{"description":"Spec
    is the calico-node DaemonSet''s PodSpec.","properties":{"affinity":{"description":"Affinity
    is a group of affinity scheduling rules for the calico-node pods.\nIf specified,
    this overrides any affinity that may be set on the calico-node DaemonSet.\nIf
    omitted, the calico-node DaemonSet will use its default value for affinity.\nWARNING:
    Please note that this field will override the default calico-node DaemonSet affinity.","properties":{"nodeAffinity":{"description":"Describes
    node affinity scheduling rules for the pod.","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"description":"The
    scheduler will prefer to schedule pods to nodes that satisfy\nthe affinity expressions
    specified by this field, but it may choose\na node that violates one or more of
    the expressions. The node that is\nmost preferred is the one with the greatest
    sum of weights, i.e.\nfor each node that meets all of the scheduling requirements
    (resource\nrequest, requiredDuringScheduling affinity expressions, etc.),\ncompute
    a sum by iterating through the elements of this field and adding\n\"weight\" to
    the sum if the node matches the corresponding matchExpressions; the\nnode(s) with
    the highest sum are the most preferred.","items":{"description":"An empty preferred
    scheduling term matches all objects with implicit weight 0\n(i.e. it''s a no-op).
    A null preferred scheduling term matches no objects (i.e. is also a no-op).","properties":{"preference":{"description":"A
    node selector term, associated with the corresponding weight.","properties":{"matchExpressions":{"description":"A
    list of node selector requirements by node''s labels.","items":{"description":"A
    node selector requirement is a selector that contains values, a key, and an operator\nthat
    relates the key and values.","properties":{"key":{"description":"The label key
    that the selector applies to.","type":"string"},"operator":{"description":"Represents
    a key''s relationship to a set of values.\nValid operators are In, NotIn, Exists,
    DoesNotExist. Gt, and Lt.","type":"string"},"values":{"description":"An array
    of string values. If the operator is In or NotIn,\nthe values array must be non-empty.
    If the operator is Exists or DoesNotExist,\nthe values array must be empty. If
    the operator is Gt or Lt, the values\narray must have a single element, which
    will be interpreted as an integer.\nThis array is replaced during a strategic
    merge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchFields":{"description":"A
    list of node selector requirements by node''s fields.","items":{"description":"A
    node selector requirement is a selector that contains values, a key, and an operator\nthat
    relates the key and values.","properties":{"key":{"description":"The label key
    that the selector applies to.","type":"string"},"operator":{"description":"Represents
    a key''s relationship to a set of values.\nValid operators are In, NotIn, Exists,
    DoesNotExist. Gt, and Lt.","type":"string"},"values":{"description":"An array
    of string values. If the operator is In or NotIn,\nthe values array must be non-empty.
    If the operator is Exists or DoesNotExist,\nthe values array must be empty. If
    the operator is Gt or Lt, the values\narray must have a single element, which
    will be interpreted as an integer.\nThis array is replaced during a strategic
    merge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"}},"type":"object","x-kubernetes-map-type":"atomic"},"weight":{"description":"Weight
    associated with matching the corresponding nodeSelectorTerm, in the range 1-100.","format":"int32","type":"integer"}},"required":["preference","weight"],"type":"object"},"type":"array"},"requiredDuringSchedulingIgnoredDuringExecution":{"description":"If
    the affinity requirements specified by this field are not met at\nscheduling time,
    the pod will not be scheduled onto the node.\nIf the affinity requirements specified
    by this field cease to be met\nat some point during pod execution (e.g. due to
    an update), the system\nmay or may not try to eventually evict the pod from its
    node.","properties":{"nodeSelectorTerms":{"description":"Required. A list of node
    selector terms. The terms are ORed.","items":{"description":"A null or empty node
    selector term matches no objects. The requirements of\nthem are ANDed.\nThe TopologySelectorTerm
    type implements a subset of the NodeSelectorTerm.","properties":{"matchExpressions":{"description":"A
    list of node selector requirements by node''s labels.","items":{"description":"A
    node selector requirement is a selector that contains values, a key, and an operator\nthat
    relates the key and values.","properties":{"key":{"description":"The label key
    that the selector applies to.","type":"string"},"operator":{"description":"Represents
    a key''s relationship to a set of values.\nValid operators are In, NotIn, Exists,
    DoesNotExist. Gt, and Lt.","type":"string"},"values":{"description":"An array
    of string values. If the operator is In or NotIn,\nthe values array must be non-empty.
    If the operator is Exists or DoesNotExist,\nthe values array must be empty. If
    the operator is Gt or Lt, the values\narray must have a single element, which
    will be interpreted as an integer.\nThis array is replaced during a strategic
    merge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchFields":{"description":"A
    list of node selector requirements by node''s fields.","items":{"description":"A
    node selector requirement is a selector that contains values, a key, and an operator\nthat
    relates the key and values.","properties":{"key":{"description":"The label key
    that the selector applies to.","type":"string"},"operator":{"description":"Represents
    a key''s relationship to a set of values.\nValid operators are In, NotIn, Exists,
    DoesNotExist. Gt, and Lt.","type":"string"},"values":{"description":"An array
    of string values. If the operator is In or NotIn,\nthe values array must be non-empty.
    If the operator is Exists or DoesNotExist,\nthe values array must be empty. If
    the operator is Gt or Lt, the values\narray must have a single element, which
    will be interpreted as an integer.\nThis array is replaced during a strategic
    merge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"}},"type":"object","x-kubernetes-map-type":"atomic"},"type":"array"}},"required":["nodeSelectorTerms"],"type":"object","x-kubernetes-map-type":"atomic"}},"type":"object"},"podAffinity":{"description":"Describes
    pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone,
    etc. as some other pod(s)).","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"description":"The
    scheduler will prefer to schedule pods to nodes that satisfy\nthe affinity expressions
    specified by this field, but it may choose\na node that violates one or more of
    the expressions. The node that is\nmost preferred is the one with the greatest
    sum of weights, i.e.\nfor each node that meets all of the scheduling requirements
    (resource\nrequest, requiredDuringScheduling affinity expressions, etc.),\ncompute
    a sum by iterating through the elements of this field and adding\n\"weight\" to
    the sum if the node has pods which matches the corresponding podAffinityTerm;
    the\nnode(s) with the highest sum are the most preferred.","items":{"description":"The
    weights of all of the matched WeightedPodAffinityTerm fields are added per-node
    to find the most preferred node(s)","properties":{"podAffinityTerm":{"description":"Required.
    A pod affinity term, associated with the corresponding weight.","properties":{"labelSelector":{"description":"A
    label query over a set of resources, in this case pods.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaceSelector":{"description":"A
    label query over the set of namespaces that the term applies to.\nThe term is
    applied to the union of the namespaces selected by this field\nand the ones listed
    in the namespaces field.\nnull selector and null or empty namespaces list means
    \"this pod''s namespace\".\nAn empty selector ({}) matches all namespaces.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaces":{"description":"namespaces
    specifies a static list of namespace names that the term applies to.\nThe term
    is applied to the union of the namespaces listed in this field\nand the ones selected
    by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector
    means \"this pod''s namespace\".","items":{"type":"string"},"type":"array"},"topologyKey":{"description":"This
    pod should be co-located (affinity) or not co-located (anti-affinity) with the
    pods matching\nthe labelSelector in the specified namespaces, where co-located
    is defined as running on a node\nwhose value of the label with key topologyKey
    matches that of any node on which any of the\nselected pods is running.\nEmpty
    topologyKey is not allowed.","type":"string"}},"required":["topologyKey"],"type":"object"},"weight":{"description":"weight
    associated with matching the corresponding podAffinityTerm,\nin the range 1-100.","format":"int32","type":"integer"}},"required":["podAffinityTerm","weight"],"type":"object"},"type":"array"},"requiredDuringSchedulingIgnoredDuringExecution":{"description":"If
    the affinity requirements specified by this field are not met at\nscheduling time,
    the pod will not be scheduled onto the node.\nIf the affinity requirements specified
    by this field cease to be met\nat some point during pod execution (e.g. due to
    a pod label update), the\nsystem may or may not try to eventually evict the pod
    from its node.\nWhen there are multiple elements, the lists of nodes corresponding
    to each\npodAffinityTerm are intersected, i.e. all terms must be satisfied.","items":{"description":"Defines
    a set of pods (namely those matching the labelSelector\nrelative to the given
    namespace(s)) that this pod should be\nco-located (affinity) or not co-located
    (anti-affinity) with,\nwhere co-located is defined as running on a node whose
    value of\nthe label with key <topologyKey> matches that of any node on which\na
    pod of the set of pods is running","properties":{"labelSelector":{"description":"A
    label query over a set of resources, in this case pods.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaceSelector":{"description":"A
    label query over the set of namespaces that the term applies to.\nThe term is
    applied to the union of the namespaces selected by this field\nand the ones listed
    in the namespaces field.\nnull selector and null or empty namespaces list means
    \"this pod''s namespace\".\nAn empty selector ({}) matches all namespaces.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaces":{"description":"namespaces
    specifies a static list of namespace names that the term applies to.\nThe term
    is applied to the union of the namespaces listed in this field\nand the ones selected
    by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector
    means \"this pod''s namespace\".","items":{"type":"string"},"type":"array"},"topologyKey":{"description":"This
    pod should be co-located (affinity) or not co-located (anti-affinity) with the
    pods matching\nthe labelSelector in the specified namespaces, where co-located
    is defined as running on a node\nwhose value of the label with key topologyKey
    matches that of any node on which any of the\nselected pods is running.\nEmpty
    topologyKey is not allowed.","type":"string"}},"required":["topologyKey"],"type":"object"},"type":"array"}},"type":"object"},"podAntiAffinity":{"description":"Describes
    pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node,
    zone, etc. as some other pod(s)).","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"description":"The
    scheduler will prefer to schedule pods to nodes that satisfy\nthe anti-affinity
    expressions specified by this field, but it may choose\na node that violates one
    or more of the expressions. The node that is\nmost preferred is the one with the
    greatest sum of weights, i.e.\nfor each node that meets all of the scheduling
    requirements (resource\nrequest, requiredDuringScheduling anti-affinity expressions,
    etc.),\ncompute a sum by iterating through the elements of this field and adding\n\"weight\"
    to the sum if the node has pods which matches the corresponding podAffinityTerm;
    the\nnode(s) with the highest sum are the most preferred.","items":{"description":"The
    weights of all of the matched WeightedPodAffinityTerm fields are added per-node
    to find the most preferred node(s)","properties":{"podAffinityTerm":{"description":"Required.
    A pod affinity term, associated with the corresponding weight.","properties":{"labelSelector":{"description":"A
    label query over a set of resources, in this case pods.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaceSelector":{"description":"A
    label query over the set of namespaces that the term applies to.\nThe term is
    applied to the union of the namespaces selected by this field\nand the ones listed
    in the namespaces field.\nnull selector and null or empty namespaces list means
    \"this pod''s namespace\".\nAn empty selector ({}) matches all namespaces.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaces":{"description":"namespaces
    specifies a static list of namespace names that the term applies to.\nThe term
    is applied to the union of the namespaces listed in this field\nand the ones selected
    by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector
    means \"this pod''s namespace\".","items":{"type":"string"},"type":"array"},"topologyKey":{"description":"This
    pod should be co-located (affinity) or not co-located (anti-affinity) with the
    pods matching\nthe labelSelector in the specified namespaces, where co-located
    is defined as running on a node\nwhose value of the label with key topologyKey
    matches that of any node on which any of the\nselected pods is running.\nEmpty
    topologyKey is not allowed.","type":"string"}},"required":["topologyKey"],"type":"object"},"weight":{"description":"weight
    associated with matching the corresponding podAffinityTerm,\nin the range 1-100.","format":"int32","type":"integer"}},"required":["podAffinityTerm","weight"],"type":"object"},"type":"array"},"requiredDuringSchedulingIgnoredDuringExecution":{"description":"If
    the anti-affinity requirements specified by this field are not met at\nscheduling
    time, the pod will not be scheduled onto the node.\nIf the anti-affinity requirements
    specified by this field cease to be met\nat some point during pod execution (e.g.
    due to a pod label update), the\nsystem may or may not try to eventually evict
    the pod from its node.\nWhen there are multiple elements, the lists of nodes corresponding
    to each\npodAffinityTerm are intersected, i.e. all terms must be satisfied.","items":{"description":"Defines
    a set of pods (namely those matching the labelSelector\nrelative to the given
    namespace(s)) that this pod should be\nco-located (affinity) or not co-located
    (anti-affinity) with,\nwhere co-located is defined as running on a node whose
    value of\nthe label with key <topologyKey> matches that of any node on which\na
    pod of the set of pods is running","properties":{"labelSelector":{"description":"A
    label query over a set of resources, in this case pods.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaceSelector":{"description":"A
    label query over the set of namespaces that the term applies to.\nThe term is
    applied to the union of the namespaces selected by this field\nand the ones listed
    in the namespaces field.\nnull selector and null or empty namespaces list means
    \"this pod''s namespace\".\nAn empty selector ({}) matches all namespaces.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaces":{"description":"namespaces
    specifies a static list of namespace names that the term applies to.\nThe term
    is applied to the union of the namespaces listed in this field\nand the ones selected
    by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector
    means \"this pod''s namespace\".","items":{"type":"string"},"type":"array"},"topologyKey":{"description":"This
    pod should be co-located (affinity) or not co-located (anti-affinity) with the
    pods matching\nthe labelSelector in the specified namespaces, where co-located
    is defined as running on a node\nwhose value of the label with key topologyKey
    matches that of any node on which any of the\nselected pods is running.\nEmpty
    topologyKey is not allowed.","type":"string"}},"required":["topologyKey"],"type":"object"},"type":"array"}},"type":"object"}},"type":"object"},"containers":{"description":"Containers
    is a list of calico-node containers.\nIf specified, this overrides the specified
    calico-node DaemonSet containers.\nIf omitted, the calico-node DaemonSet will
    use its default values for its containers.","items":{"description":"CalicoNodeDaemonSetContainer
    is a calico-node DaemonSet container.","properties":{"name":{"description":"Name
    is an enum which identifies the calico-node DaemonSet container by name.\nSupported
    values are: calico-node","enum":["calico-node"],"type":"string"},"resources":{"description":"Resources
    allows customization of limits and requests for compute resources such as cpu
    and memory.\nIf specified, this overrides the named calico-node DaemonSet container''s
    resources.\nIf omitted, the calico-node DaemonSet will use its default value for
    this container''s resources.\nIf used in conjunction with the deprecated ComponentResources,
    then this value takes precedence.","properties":{"claims":{"description":"Claims
    lists the names of resources, defined in spec.resourceClaims,\nthat are used by
    this container.\nThis is an alpha field and requires enabling the\nDynamicResourceAllocation
    feature gate.\nThis field is immutable. It can only be set for containers.","items":{"description":"ResourceClaim
    references one entry in PodSpec.ResourceClaims.","properties":{"name":{"description":"Name
    must match the name of one entry in pod.spec.resourceClaims of\nthe Pod where
    this field is used. It makes that resource available\ninside a container.","type":"string"}},"required":["name"],"type":"object"},"type":"array","x-kubernetes-list-map-keys":["name"],"x-kubernetes-list-type":"map"},"limits":{"additionalProperties":{"anyOf":[{"type":"integer"},{"type":"string"}],"pattern":"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$","x-kubernetes-int-or-string":true},"description":"Limits
    describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/","type":"object"},"requests":{"additionalProperties":{"anyOf":[{"type":"integer"},{"type":"string"}],"pattern":"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$","x-kubernetes-int-or-string":true},"description":"Requests
    describes the minimum amount of compute resources required.\nIf Requests is omitted
    for a container, it defaults to Limits if that is explicitly specified,\notherwise
    to an implementation-defined value. Requests cannot exceed Limits.\nMore info:
    https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/","type":"object"}},"type":"object"}},"required":["name"],"type":"object"},"type":"array"},"initContainers":{"description":"InitContainers
    is a list of calico-node init containers.\nIf specified, this overrides the specified
    calico-node DaemonSet init containers.\nIf omitted, the calico-node DaemonSet
    will use its default values for its init containers.","items":{"description":"CalicoNodeDaemonSetInitContainer
    is a calico-node DaemonSet init container.","properties":{"name":{"description":"Name
    is an enum which identifies the calico-node DaemonSet init container by name.\nSupported
    values are: install-cni, hostpath-init, flexvol-driver, mount-bpffs, node-certs-key-cert-provisioner,
    calico-node-prometheus-server-tls-key-cert-provisioner","enum":["install-cni","hostpath-init","flexvol-driver","mount-bpffs","node-certs-key-cert-provisioner","calico-node-prometheus-server-tls-key-cert-provisioner"],"type":"string"},"resources":{"description":"Resources
    allows customization of limits and requests for compute resources such as cpu
    and memory.\nIf specified, this overrides the named calico-node DaemonSet init
    container''s resources.\nIf omitted, the calico-node DaemonSet will use its default
    value for this container''s resources.\nIf used in conjunction with the deprecated
    ComponentResources, then this value takes precedence.","properties":{"claims":{"description":"Claims
    lists the names of resources, defined in spec.resourceClaims,\nthat are used by
    this container.\nThis is an alpha field and requires enabling the\nDynamicResourceAllocation
    feature gate.\nThis field is immutable. It can only be set for containers.","items":{"description":"ResourceClaim
    references one entry in PodSpec.ResourceClaims.","properties":{"name":{"description":"Name
    must match the name of one entry in pod.spec.resourceClaims of\nthe Pod where
    this field is used. It makes that resource available\ninside a container.","type":"string"}},"required":["name"],"type":"object"},"type":"array","x-kubernetes-list-map-keys":["name"],"x-kubernetes-list-type":"map"},"limits":{"additionalProperties":{"anyOf":[{"type":"integer"},{"type":"string"}],"pattern":"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$","x-kubernetes-int-or-string":true},"description":"Limits
    describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/","type":"object"},"requests":{"additionalProperties":{"anyOf":[{"type":"integer"},{"type":"string"}],"pattern":"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$","x-kubernetes-int-or-string":true},"description":"Requests
    describes the minimum amount of compute resources required.\nIf Requests is omitted
    for a container, it defaults to Limits if that is explicitly specified,\notherwise
    to an implementation-defined value. Requests cannot exceed Limits.\nMore info:
    https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/","type":"object"}},"type":"object"}},"required":["name"],"type":"object"},"type":"array"},"nodeSelector":{"additionalProperties":{"type":"string"},"description":"NodeSelector
    is the calico-node pod''s scheduling constraints.\nIf specified, each of the key/value
    pairs are added to the calico-node DaemonSet nodeSelector provided\nthe key does
    not already exist in the object''s nodeSelector.\nIf omitted, the calico-node
    DaemonSet will use its default value for nodeSelector.\nWARNING: Please note that
    this field will modify the default calico-node DaemonSet nodeSelector.","type":"object"},"tolerations":{"description":"Tolerations
    is the calico-node pod''s tolerations.\nIf specified, this overrides any tolerations
    that may be set on the calico-node DaemonSet.\nIf omitted, the calico-node DaemonSet
    will use its default value for tolerations.\nWARNING: Please note that this field
    will override the default calico-node DaemonSet tolerations.","items":{"description":"The
    pod this Toleration is attached to tolerates any taint that matches\nthe triple
    <key,value,effect> using the matching operator <operator>.","properties":{"effect":{"description":"Effect
    indicates the taint effect to match. Empty means match all taint effects.\nWhen
    specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.","type":"string"},"key":{"description":"Key
    is the taint key that the toleration applies to. Empty means match all taint keys.\nIf
    the key is empty, operator must be Exists; this combination means to match all
    values and all keys.","type":"string"},"operator":{"description":"Operator represents
    a key''s relationship to the value.\nValid operators are Exists and Equal. Defaults
    to Equal.\nExists is equivalent to wildcard for value, so that a pod can\ntolerate
    all taints of a particular category.","type":"string"},"tolerationSeconds":{"description":"TolerationSeconds
    represents the period of time the toleration (which must be\nof effect NoExecute,
    otherwise this field is ignored) tolerates the taint. By default,\nit is not set,
    which means tolerate the taint forever (do not evict). Zero and\nnegative values
    will be treated as 0 (evict immediately) by the system.","format":"int64","type":"integer"},"value":{"description":"Value
    is the taint value the toleration matches to.\nIf the operator is Exists, the
    value should be empty, otherwise just a regular string.","type":"string"}},"type":"object"},"type":"array"}},"type":"object"}},"type":"object"}},"type":"object"}},"type":"object"},"calicoNodeWindowsDaemonSet":{"description":"CalicoNodeWindowsDaemonSet
    configures the calico-node-windows DaemonSet.","properties":{"metadata":{"description":"Metadata
    is a subset of a Kubernetes object''s metadata that is added to the DaemonSet.","properties":{"annotations":{"additionalProperties":{"type":"string"},"description":"Annotations
    is a map of arbitrary non-identifying metadata. Each of these\nkey/value pairs
    are added to the object''s annotations provided the key does not\nalready exist
    in the object''s annotations.","type":"object"},"labels":{"additionalProperties":{"type":"string"},"description":"Labels
    is a map of string keys and values that may match replicaset and\nservice selectors.
    Each of these key/value pairs are added to the\nobject''s labels provided the
    key does not already exist in the object''s labels.","type":"object"}},"type":"object"},"spec":{"description":"Spec
    is the specification of the calico-node-windows DaemonSet.","properties":{"minReadySeconds":{"description":"MinReadySeconds
    is the minimum number of seconds for which a newly created DaemonSet pod should\nbe
    ready without any of its container crashing, for it to be considered available.\nIf
    specified, this overrides any minReadySeconds value that may be set on the calico-node-windows
    DaemonSet.\nIf omitted, the calico-node-windows DaemonSet will use its default
    value for minReadySeconds.","format":"int32","maximum":2147483647,"minimum":0,"type":"integer"},"template":{"description":"Template
    describes the calico-node-windows DaemonSet pod that will be created.","properties":{"metadata":{"description":"Metadata
    is a subset of a Kubernetes object''s metadata that is added to\nthe pod''s metadata.","properties":{"annotations":{"additionalProperties":{"type":"string"},"description":"Annotations
    is a map of arbitrary non-identifying metadata. Each of these\nkey/value pairs
    are added to the object''s annotations provided the key does not\nalready exist
    in the object''s annotations.","type":"object"},"labels":{"additionalProperties":{"type":"string"},"description":"Labels
    is a map of string keys and values that may match replicaset and\nservice selectors.
    Each of these key/value pairs are added to the\nobject''s labels provided the
    key does not already exist in the object''s labels.","type":"object"}},"type":"object"},"spec":{"description":"Spec
    is the calico-node-windows DaemonSet''s PodSpec.","properties":{"affinity":{"description":"Affinity
    is a group of affinity scheduling rules for the calico-node-windows pods.\nIf
    specified, this overrides any affinity that may be set on the calico-node-windows
    DaemonSet.\nIf omitted, the calico-node-windows DaemonSet will use its default
    value for affinity.\nWARNING: Please note that this field will override the default
    calico-node-windows DaemonSet affinity.","properties":{"nodeAffinity":{"description":"Describes
    node affinity scheduling rules for the pod.","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"description":"The
    scheduler will prefer to schedule pods to nodes that satisfy\nthe affinity expressions
    specified by this field, but it may choose\na node that violates one or more of
    the expressions. The node that is\nmost preferred is the one with the greatest
    sum of weights, i.e.\nfor each node that meets all of the scheduling requirements
    (resource\nrequest, requiredDuringScheduling affinity expressions, etc.),\ncompute
    a sum by iterating through the elements of this field and adding\n\"weight\" to
    the sum if the node matches the corresponding matchExpressions; the\nnode(s) with
    the highest sum are the most preferred.","items":{"description":"An empty preferred
    scheduling term matches all objects with implicit weight 0\n(i.e. it''s a no-op).
    A null preferred scheduling term matches no objects (i.e. is also a no-op).","properties":{"preference":{"description":"A
    node selector term, associated with the corresponding weight.","properties":{"matchExpressions":{"description":"A
    list of node selector requirements by node''s labels.","items":{"description":"A
    node selector requirement is a selector that contains values, a key, and an operator\nthat
    relates the key and values.","properties":{"key":{"description":"The label key
    that the selector applies to.","type":"string"},"operator":{"description":"Represents
    a key''s relationship to a set of values.\nValid operators are In, NotIn, Exists,
    DoesNotExist. Gt, and Lt.","type":"string"},"values":{"description":"An array
    of string values. If the operator is In or NotIn,\nthe values array must be non-empty.
    If the operator is Exists or DoesNotExist,\nthe values array must be empty. If
    the operator is Gt or Lt, the values\narray must have a single element, which
    will be interpreted as an integer.\nThis array is replaced during a strategic
    merge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchFields":{"description":"A
    list of node selector requirements by node''s fields.","items":{"description":"A
    node selector requirement is a selector that contains values, a key, and an operator\nthat
    relates the key and values.","properties":{"key":{"description":"The label key
    that the selector applies to.","type":"string"},"operator":{"description":"Represents
    a key''s relationship to a set of values.\nValid operators are In, NotIn, Exists,
    DoesNotExist. Gt, and Lt.","type":"string"},"values":{"description":"An array
    of string values. If the operator is In or NotIn,\nthe values array must be non-empty.
    If the operator is Exists or DoesNotExist,\nthe values array must be empty. If
    the operator is Gt or Lt, the values\narray must have a single element, which
    will be interpreted as an integer.\nThis array is replaced during a strategic
    merge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"}},"type":"object","x-kubernetes-map-type":"atomic"},"weight":{"description":"Weight
    associated with matching the corresponding nodeSelectorTerm, in the range 1-100.","format":"int32","type":"integer"}},"required":["preference","weight"],"type":"object"},"type":"array"},"requiredDuringSchedulingIgnoredDuringExecution":{"description":"If
    the affinity requirements specified by this field are not met at\nscheduling time,
    the pod will not be scheduled onto the node.\nIf the affinity requirements specified
    by this field cease to be met\nat some point during pod execution (e.g. due to
    an update), the system\nmay or may not try to eventually evict the pod from its
    node.","properties":{"nodeSelectorTerms":{"description":"Required. A list of node
    selector terms. The terms are ORed.","items":{"description":"A null or empty node
    selector term matches no objects. The requirements of\nthem are ANDed.\nThe TopologySelectorTerm
    type implements a subset of the NodeSelectorTerm.","properties":{"matchExpressions":{"description":"A
    list of node selector requirements by node''s labels.","items":{"description":"A
    node selector requirement is a selector that contains values, a key, and an operator\nthat
    relates the key and values.","properties":{"key":{"description":"The label key
    that the selector applies to.","type":"string"},"operator":{"description":"Represents
    a key''s relationship to a set of values.\nValid operators are In, NotIn, Exists,
    DoesNotExist. Gt, and Lt.","type":"string"},"values":{"description":"An array
    of string values. If the operator is In or NotIn,\nthe values array must be non-empty.
    If the operator is Exists or DoesNotExist,\nthe values array must be empty. If
    the operator is Gt or Lt, the values\narray must have a single element, which
    will be interpreted as an integer.\nThis array is replaced during a strategic
    merge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchFields":{"description":"A
    list of node selector requirements by node''s fields.","items":{"description":"A
    node selector requirement is a selector that contains values, a key, and an operator\nthat
    relates the key and values.","properties":{"key":{"description":"The label key
    that the selector applies to.","type":"string"},"operator":{"description":"Represents
    a key''s relationship to a set of values.\nValid operators are In, NotIn, Exists,
    DoesNotExist. Gt, and Lt.","type":"string"},"values":{"description":"An array
    of string values. If the operator is In or NotIn,\nthe values array must be non-empty.
    If the operator is Exists or DoesNotExist,\nthe values array must be empty. If
    the operator is Gt or Lt, the values\narray must have a single element, which
    will be interpreted as an integer.\nThis array is replaced during a strategic
    merge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"}},"type":"object","x-kubernetes-map-type":"atomic"},"type":"array"}},"required":["nodeSelectorTerms"],"type":"object","x-kubernetes-map-type":"atomic"}},"type":"object"},"podAffinity":{"description":"Describes
    pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone,
    etc. as some other pod(s)).","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"description":"The
    scheduler will prefer to schedule pods to nodes that satisfy\nthe affinity expressions
    specified by this field, but it may choose\na node that violates one or more of
    the expressions. The node that is\nmost preferred is the one with the greatest
    sum of weights, i.e.\nfor each node that meets all of the scheduling requirements
    (resource\nrequest, requiredDuringScheduling affinity expressions, etc.),\ncompute
    a sum by iterating through the elements of this field and adding\n\"weight\" to
    the sum if the node has pods which matches the corresponding podAffinityTerm;
    the\nnode(s) with the highest sum are the most preferred.","items":{"description":"The
    weights of all of the matched WeightedPodAffinityTerm fields are added per-node
    to find the most preferred node(s)","properties":{"podAffinityTerm":{"description":"Required.
    A pod affinity term, associated with the corresponding weight.","properties":{"labelSelector":{"description":"A
    label query over a set of resources, in this case pods.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaceSelector":{"description":"A
    label query over the set of namespaces that the term applies to.\nThe term is
    applied to the union of the namespaces selected by this field\nand the ones listed
    in the namespaces field.\nnull selector and null or empty namespaces list means
    \"this pod''s namespace\".\nAn empty selector ({}) matches all namespaces.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaces":{"description":"namespaces
    specifies a static list of namespace names that the term applies to.\nThe term
    is applied to the union of the namespaces listed in this field\nand the ones selected
    by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector
    means \"this pod''s namespace\".","items":{"type":"string"},"type":"array"},"topologyKey":{"description":"This
    pod should be co-located (affinity) or not co-located (anti-affinity) with the
    pods matching\nthe labelSelector in the specified namespaces, where co-located
    is defined as running on a node\nwhose value of the label with key topologyKey
    matches that of any node on which any of the\nselected pods is running.\nEmpty
    topologyKey is not allowed.","type":"string"}},"required":["topologyKey"],"type":"object"},"weight":{"description":"weight
    associated with matching the corresponding podAffinityTerm,\nin the range 1-100.","format":"int32","type":"integer"}},"required":["podAffinityTerm","weight"],"type":"object"},"type":"array"},"requiredDuringSchedulingIgnoredDuringExecution":{"description":"If
    the affinity requirements specified by this field are not met at\nscheduling time,
    the pod will not be scheduled onto the node.\nIf the affinity requirements specified
    by this field cease to be met\nat some point during pod execution (e.g. due to
    a pod label update), the\nsystem may or may not try to eventually evict the pod
    from its node.\nWhen there are multiple elements, the lists of nodes corresponding
    to each\npodAffinityTerm are intersected, i.e. all terms must be satisfied.","items":{"description":"Defines
    a set of pods (namely those matching the labelSelector\nrelative to the given
    namespace(s)) that this pod should be\nco-located (affinity) or not co-located
    (anti-affinity) with,\nwhere co-located is defined as running on a node whose
    value of\nthe label with key <topologyKey> matches that of any node on which\na
    pod of the set of pods is running","properties":{"labelSelector":{"description":"A
    label query over a set of resources, in this case pods.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaceSelector":{"description":"A
    label query over the set of namespaces that the term applies to.\nThe term is
    applied to the union of the namespaces selected by this field\nand the ones listed
    in the namespaces field.\nnull selector and null or empty namespaces list means
    \"this pod''s namespace\".\nAn empty selector ({}) matches all namespaces.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaces":{"description":"namespaces
    specifies a static list of namespace names that the term applies to.\nThe term
    is applied to the union of the namespaces listed in this field\nand the ones selected
    by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector
    means \"this pod''s namespace\".","items":{"type":"string"},"type":"array"},"topologyKey":{"description":"This
    pod should be co-located (affinity) or not co-located (anti-affinity) with the
    pods matching\nthe labelSelector in the specified namespaces, where co-located
    is defined as running on a node\nwhose value of the label with key topologyKey
    matches that of any node on which any of the\nselected pods is running.\nEmpty
    topologyKey is not allowed.","type":"string"}},"required":["topologyKey"],"type":"object"},"type":"array"}},"type":"object"},"podAntiAffinity":{"description":"Describes
    pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node,
    zone, etc. as some other pod(s)).","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"description":"The
    scheduler will prefer to schedule pods to nodes that satisfy\nthe anti-affinity
    expressions specified by this field, but it may choose\na node that violates one
    or more of the expressions. The node that is\nmost preferred is the one with the
    greatest sum of weights, i.e.\nfor each node that meets all of the scheduling
    requirements (resource\nrequest, requiredDuringScheduling anti-affinity expressions,
    etc.),\ncompute a sum by iterating through the elements of this field and adding\n\"weight\"
    to the sum if the node has pods which matches the corresponding podAffinityTerm;
    the\nnode(s) with the highest sum are the most preferred.","items":{"description":"The
    weights of all of the matched WeightedPodAffinityTerm fields are added per-node
    to find the most preferred node(s)","properties":{"podAffinityTerm":{"description":"Required.
    A pod affinity term, associated with the corresponding weight.","properties":{"labelSelector":{"description":"A
    label query over a set of resources, in this case pods.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaceSelector":{"description":"A
    label query over the set of namespaces that the term applies to.\nThe term is
    applied to the union of the namespaces selected by this field\nand the ones listed
    in the namespaces field.\nnull selector and null or empty namespaces list means
    \"this pod''s namespace\".\nAn empty selector ({}) matches all namespaces.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaces":{"description":"namespaces
    specifies a static list of namespace names that the term applies to.\nThe term
    is applied to the union of the namespaces listed in this field\nand the ones selected
    by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector
    means \"this pod''s namespace\".","items":{"type":"string"},"type":"array"},"topologyKey":{"description":"This
    pod should be co-located (affinity) or not co-located (anti-affinity) with the
    pods matching\nthe labelSelector in the specified namespaces, where co-located
    is defined as running on a node\nwhose value of the label with key topologyKey
    matches that of any node on which any of the\nselected pods is running.\nEmpty
    topologyKey is not allowed.","type":"string"}},"required":["topologyKey"],"type":"object"},"weight":{"description":"weight
    associated with matching the corresponding podAffinityTerm,\nin the range 1-100.","format":"int32","type":"integer"}},"required":["podAffinityTerm","weight"],"type":"object"},"type":"array"},"requiredDuringSchedulingIgnoredDuringExecution":{"description":"If
    the anti-affinity requirements specified by this field are not met at\nscheduling
    time, the pod will not be scheduled onto the node.\nIf the anti-affinity requirements
    specified by this field cease to be met\nat some point during pod execution (e.g.
    due to a pod label update), the\nsystem may or may not try to eventually evict
    the pod from its node.\nWhen there are multiple elements, the lists of nodes corresponding
    to each\npodAffinityTerm are intersected, i.e. all terms must be satisfied.","items":{"description":"Defines
    a set of pods (namely those matching the labelSelector\nrelative to the given
    namespace(s)) that this pod should be\nco-located (affinity) or not co-located
    (anti-affinity) with,\nwhere co-located is defined as running on a node whose
    value of\nthe label with key <topologyKey> matches that of any node on which\na
    pod of the set of pods is running","properties":{"labelSelector":{"description":"A
    label query over a set of resources, in this case pods.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaceSelector":{"description":"A
    label query over the set of namespaces that the term applies to.\nThe term is
    applied to the union of the namespaces selected by this field\nand the ones listed
    in the namespaces field.\nnull selector and null or empty namespaces list means
    \"this pod''s namespace\".\nAn empty selector ({}) matches all namespaces.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaces":{"description":"namespaces
    specifies a static list of namespace names that the term applies to.\nThe term
    is applied to the union of the namespaces listed in this field\nand the ones selected
    by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector
    means \"this pod''s namespace\".","items":{"type":"string"},"type":"array"},"topologyKey":{"description":"This
    pod should be co-located (affinity) or not co-located (anti-affinity) with the
    pods matching\nthe labelSelector in the specified namespaces, where co-located
    is defined as running on a node\nwhose value of the label with key topologyKey
    matches that of any node on which any of the\nselected pods is running.\nEmpty
    topologyKey is not allowed.","type":"string"}},"required":["topologyKey"],"type":"object"},"type":"array"}},"type":"object"}},"type":"object"},"containers":{"description":"Containers
    is a list of calico-node-windows containers.\nIf specified, this overrides the
    specified calico-node-windows DaemonSet containers.\nIf omitted, the calico-node-windows
    DaemonSet will use its default values for its containers.","items":{"description":"CalicoNodeWindowsDaemonSetContainer
    is a calico-node-windows DaemonSet container.","properties":{"name":{"description":"Name
    is an enum which identifies the calico-node-windows DaemonSet container by name.\nSupported
    values are: calico-node-windows","enum":["calico-node-windows"],"type":"string"},"resources":{"description":"Resources
    allows customization of limits and requests for compute resources such as cpu
    and memory.\nIf specified, this overrides the named calico-node-windows DaemonSet
    container''s resources.\nIf omitted, the calico-node-windows DaemonSet will use
    its default value for this container''s resources.\nIf used in conjunction with
    the deprecated ComponentResources, then this value takes precedence.","properties":{"claims":{"description":"Claims
    lists the names of resources, defined in spec.resourceClaims,\nthat are used by
    this container.\nThis is an alpha field and requires enabling the\nDynamicResourceAllocation
    feature gate.\nThis field is immutable. It can only be set for containers.","items":{"description":"ResourceClaim
    references one entry in PodSpec.ResourceClaims.","properties":{"name":{"description":"Name
    must match the name of one entry in pod.spec.resourceClaims of\nthe Pod where
    this field is used. It makes that resource available\ninside a container.","type":"string"}},"required":["name"],"type":"object"},"type":"array","x-kubernetes-list-map-keys":["name"],"x-kubernetes-list-type":"map"},"limits":{"additionalProperties":{"anyOf":[{"type":"integer"},{"type":"string"}],"pattern":"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$","x-kubernetes-int-or-string":true},"description":"Limits
    describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/","type":"object"},"requests":{"additionalProperties":{"anyOf":[{"type":"integer"},{"type":"string"}],"pattern":"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$","x-kubernetes-int-or-string":true},"description":"Requests
    describes the minimum amount of compute resources required.\nIf Requests is omitted
    for a container, it defaults to Limits if that is explicitly specified,\notherwise
    to an implementation-defined value. Requests cannot exceed Limits.\nMore info:
    https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/","type":"object"}},"type":"object"}},"required":["name"],"type":"object"},"type":"array"},"initContainers":{"description":"InitContainers
    is a list of calico-node-windows init containers.\nIf specified, this overrides
    the specified calico-node-windows DaemonSet init containers.\nIf omitted, the
    calico-node-windows DaemonSet will use its default values for its init containers.","items":{"description":"CalicoNodeWindowsDaemonSetInitContainer
    is a calico-node-windows DaemonSet init container.","properties":{"name":{"description":"Name
    is an enum which identifies the calico-node-windows DaemonSet init container by
    name.\nSupported values are: install-cni;hostpath-init, flexvol-driver, mount-bpffs,
    node-certs-key-cert-provisioner, calico-node-windows-prometheus-server-tls-key-cert-provisioner","enum":["install-cni","hostpath-init","flexvol-driver","mount-bpffs","node-certs-key-cert-provisioner","calico-node-windows-prometheus-server-tls-key-cert-provisioner"],"type":"string"},"resources":{"description":"Resources
    allows customization of limits and requests for compute resources such as cpu
    and memory.\nIf specified, this overrides the named calico-node-windows DaemonSet
    init container''s resources.\nIf omitted, the calico-node-windows DaemonSet will
    use its default value for this container''s resources.\nIf used in conjunction
    with the deprecated ComponentResources, then this value takes precedence.","properties":{"claims":{"description":"Claims
    lists the names of resources, defined in spec.resourceClaims,\nthat are used by
    this container.\nThis is an alpha field and requires enabling the\nDynamicResourceAllocation
    feature gate.\nThis field is immutable. It can only be set for containers.","items":{"description":"ResourceClaim
    references one entry in PodSpec.ResourceClaims.","properties":{"name":{"description":"Name
    must match the name of one entry in pod.spec.resourceClaims of\nthe Pod where
    this field is used. It makes that resource available\ninside a container.","type":"string"}},"required":["name"],"type":"object"},"type":"array","x-kubernetes-list-map-keys":["name"],"x-kubernetes-list-type":"map"},"limits":{"additionalProperties":{"anyOf":[{"type":"integer"},{"type":"string"}],"pattern":"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$","x-kubernetes-int-or-string":true},"description":"Limits
    describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/","type":"object"},"requests":{"additionalProperties":{"anyOf":[{"type":"integer"},{"type":"string"}],"pattern":"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$","x-kubernetes-int-or-string":true},"description":"Requests
    describes the minimum amount of compute resources required.\nIf Requests is omitted
    for a container, it defaults to Limits if that is explicitly specified,\notherwise
    to an implementation-defined value. Requests cannot exceed Limits.\nMore info:
    https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/","type":"object"}},"type":"object"}},"required":["name"],"type":"object"},"type":"array"},"nodeSelector":{"additionalProperties":{"type":"string"},"description":"NodeSelector
    is the calico-node-windows pod''s scheduling constraints.\nIf specified, each
    of the key/value pairs are added to the calico-node-windows DaemonSet nodeSelector
    provided\nthe key does not already exist in the object''s nodeSelector.\nIf omitted,
    the calico-node-windows DaemonSet will use its default value for nodeSelector.\nWARNING:
    Please note that this field will modify the default calico-node-windows DaemonSet
    nodeSelector.","type":"object"},"tolerations":{"description":"Tolerations is the
    calico-node-windows pod''s tolerations.\nIf specified, this overrides any tolerations
    that may be set on the calico-node-windows DaemonSet.\nIf omitted, the calico-node-windows
    DaemonSet will use its default value for tolerations.\nWARNING: Please note that
    this field will override the default calico-node-windows DaemonSet tolerations.","items":{"description":"The
    pod this Toleration is attached to tolerates any taint that matches\nthe triple
    <key,value,effect> using the matching operator <operator>.","properties":{"effect":{"description":"Effect
    indicates the taint effect to match. Empty means match all taint effects.\nWhen
    specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.","type":"string"},"key":{"description":"Key
    is the taint key that the toleration applies to. Empty means match all taint keys.\nIf
    the key is empty, operator must be Exists; this combination means to match all
    values and all keys.","type":"string"},"operator":{"description":"Operator represents
    a key''s relationship to the value.\nValid operators are Exists and Equal. Defaults
    to Equal.\nExists is equivalent to wildcard for value, so that a pod can\ntolerate
    all taints of a particular category.","type":"string"},"tolerationSeconds":{"description":"TolerationSeconds
    represents the period of time the toleration (which must be\nof effect NoExecute,
    otherwise this field is ignored) tolerates the taint. By default,\nit is not set,
    which means tolerate the taint forever (do not evict). Zero and\nnegative values
    will be treated as 0 (evict immediately) by the system.","format":"int64","type":"integer"},"value":{"description":"Value
    is the taint value the toleration matches to.\nIf the operator is Exists, the
    value should be empty, otherwise just a regular string.","type":"string"}},"type":"object"},"type":"array"}},"type":"object"}},"type":"object"}},"type":"object"}},"type":"object"},"calicoWindowsUpgradeDaemonSet":{"description":"Deprecated.
    The CalicoWindowsUpgradeDaemonSet is deprecated and will be removed from the API
    in the future.\nCalicoWindowsUpgradeDaemonSet configures the calico-windows-upgrade
    DaemonSet.","properties":{"metadata":{"description":"Metadata is a subset of a
    Kubernetes object''s metadata that is added to the Deployment.","properties":{"annotations":{"additionalProperties":{"type":"string"},"description":"Annotations
    is a map of arbitrary non-identifying metadata. Each of these\nkey/value pairs
    are added to the object''s annotations provided the key does not\nalready exist
    in the object''s annotations.","type":"object"},"labels":{"additionalProperties":{"type":"string"},"description":"Labels
    is a map of string keys and values that may match replicaset and\nservice selectors.
    Each of these key/value pairs are added to the\nobject''s labels provided the
    key does not already exist in the object''s labels.","type":"object"}},"type":"object"},"spec":{"description":"Spec
    is the specification of the calico-windows-upgrade DaemonSet.","properties":{"minReadySeconds":{"description":"MinReadySeconds
    is the minimum number of seconds for which a newly created Deployment pod should\nbe
    ready without any of its container crashing, for it to be considered available.\nIf
    specified, this overrides any minReadySeconds value that may be set on the calico-windows-upgrade
    DaemonSet.\nIf omitted, the calico-windows-upgrade DaemonSet will use its default
    value for minReadySeconds.","format":"int32","maximum":2147483647,"minimum":0,"type":"integer"},"template":{"description":"Template
    describes the calico-windows-upgrade DaemonSet pod that will be created.","properties":{"metadata":{"description":"Metadata
    is a subset of a Kubernetes object''s metadata that is added to\nthe pod''s metadata.","properties":{"annotations":{"additionalProperties":{"type":"string"},"description":"Annotations
    is a map of arbitrary non-identifying metadata. Each of these\nkey/value pairs
    are added to the object''s annotations provided the key does not\nalready exist
    in the object''s annotations.","type":"object"},"labels":{"additionalProperties":{"type":"string"},"description":"Labels
    is a map of string keys and values that may match replicaset and\nservice selectors.
    Each of these key/value pairs are added to the\nobject''s labels provided the
    key does not already exist in the object''s labels.","type":"object"}},"type":"object"},"spec":{"description":"Spec
    is the calico-windows-upgrade DaemonSet''s PodSpec.","properties":{"affinity":{"description":"Affinity
    is a group of affinity scheduling rules for the calico-windows-upgrade pods.\nIf
    specified, this overrides any affinity that may be set on the calico-windows-upgrade
    DaemonSet.\nIf omitted, the calico-windows-upgrade DaemonSet will use its default
    value for affinity.\nWARNING: Please note that this field will override the default
    calico-windows-upgrade DaemonSet affinity.","properties":{"nodeAffinity":{"description":"Describes
    node affinity scheduling rules for the pod.","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"description":"The
    scheduler will prefer to schedule pods to nodes that satisfy\nthe affinity expressions
    specified by this field, but it may choose\na node that violates one or more of
    the expressions. The node that is\nmost preferred is the one with the greatest
    sum of weights, i.e.\nfor each node that meets all of the scheduling requirements
    (resource\nrequest, requiredDuringScheduling affinity expressions, etc.),\ncompute
    a sum by iterating through the elements of this field and adding\n\"weight\" to
    the sum if the node matches the corresponding matchExpressions; the\nnode(s) with
    the highest sum are the most preferred.","items":{"description":"An empty preferred
    scheduling term matches all objects with implicit weight 0\n(i.e. it''s a no-op).
    A null preferred scheduling term matches no objects (i.e. is also a no-op).","properties":{"preference":{"description":"A
    node selector term, associated with the corresponding weight.","properties":{"matchExpressions":{"description":"A
    list of node selector requirements by node''s labels.","items":{"description":"A
    node selector requirement is a selector that contains values, a key, and an operator\nthat
    relates the key and values.","properties":{"key":{"description":"The label key
    that the selector applies to.","type":"string"},"operator":{"description":"Represents
    a key''s relationship to a set of values.\nValid operators are In, NotIn, Exists,
    DoesNotExist. Gt, and Lt.","type":"string"},"values":{"description":"An array
    of string values. If the operator is In or NotIn,\nthe values array must be non-empty.
    If the operator is Exists or DoesNotExist,\nthe values array must be empty. If
    the operator is Gt or Lt, the values\narray must have a single element, which
    will be interpreted as an integer.\nThis array is replaced during a strategic
    merge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchFields":{"description":"A
    list of node selector requirements by node''s fields.","items":{"description":"A
    node selector requirement is a selector that contains values, a key, and an operator\nthat
    relates the key and values.","properties":{"key":{"description":"The label key
    that the selector applies to.","type":"string"},"operator":{"description":"Represents
    a key''s relationship to a set of values.\nValid operators are In, NotIn, Exists,
    DoesNotExist. Gt, and Lt.","type":"string"},"values":{"description":"An array
    of string values. If the operator is In or NotIn,\nthe values array must be non-empty.
    If the operator is Exists or DoesNotExist,\nthe values array must be empty. If
    the operator is Gt or Lt, the values\narray must have a single element, which
    will be interpreted as an integer.\nThis array is replaced during a strategic
    merge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"}},"type":"object","x-kubernetes-map-type":"atomic"},"weight":{"description":"Weight
    associated with matching the corresponding nodeSelectorTerm, in the range 1-100.","format":"int32","type":"integer"}},"required":["preference","weight"],"type":"object"},"type":"array"},"requiredDuringSchedulingIgnoredDuringExecution":{"description":"If
    the affinity requirements specified by this field are not met at\nscheduling time,
    the pod will not be scheduled onto the node.\nIf the affinity requirements specified
    by this field cease to be met\nat some point during pod execution (e.g. due to
    an update), the system\nmay or may not try to eventually evict the pod from its
    node.","properties":{"nodeSelectorTerms":{"description":"Required. A list of node
    selector terms. The terms are ORed.","items":{"description":"A null or empty node
    selector term matches no objects. The requirements of\nthem are ANDed.\nThe TopologySelectorTerm
    type implements a subset of the NodeSelectorTerm.","properties":{"matchExpressions":{"description":"A
    list of node selector requirements by node''s labels.","items":{"description":"A
    node selector requirement is a selector that contains values, a key, and an operator\nthat
    relates the key and values.","properties":{"key":{"description":"The label key
    that the selector applies to.","type":"string"},"operator":{"description":"Represents
    a key''s relationship to a set of values.\nValid operators are In, NotIn, Exists,
    DoesNotExist. Gt, and Lt.","type":"string"},"values":{"description":"An array
    of string values. If the operator is In or NotIn,\nthe values array must be non-empty.
    If the operator is Exists or DoesNotExist,\nthe values array must be empty. If
    the operator is Gt or Lt, the values\narray must have a single element, which
    will be interpreted as an integer.\nThis array is replaced during a strategic
    merge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchFields":{"description":"A
    list of node selector requirements by node''s fields.","items":{"description":"A
    node selector requirement is a selector that contains values, a key, and an operator\nthat
    relates the key and values.","properties":{"key":{"description":"The label key
    that the selector applies to.","type":"string"},"operator":{"description":"Represents
    a key''s relationship to a set of values.\nValid operators are In, NotIn, Exists,
    DoesNotExist. Gt, and Lt.","type":"string"},"values":{"description":"An array
    of string values. If the operator is In or NotIn,\nthe values array must be non-empty.
    If the operator is Exists or DoesNotExist,\nthe values array must be empty. If
    the operator is Gt or Lt, the values\narray must have a single element, which
    will be interpreted as an integer.\nThis array is replaced during a strategic
    merge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"}},"type":"object","x-kubernetes-map-type":"atomic"},"type":"array"}},"required":["nodeSelectorTerms"],"type":"object","x-kubernetes-map-type":"atomic"}},"type":"object"},"podAffinity":{"description":"Describes
    pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone,
    etc. as some other pod(s)).","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"description":"The
    scheduler will prefer to schedule pods to nodes that satisfy\nthe affinity expressions
    specified by this field, but it may choose\na node that violates one or more of
    the expressions. The node that is\nmost preferred is the one with the greatest
    sum of weights, i.e.\nfor each node that meets all of the scheduling requirements
    (resource\nrequest, requiredDuringScheduling affinity expressions, etc.),\ncompute
    a sum by iterating through the elements of this field and adding\n\"weight\" to
    the sum if the node has pods which matches the corresponding podAffinityTerm;
    the\nnode(s) with the highest sum are the most preferred.","items":{"description":"The
    weights of all of the matched WeightedPodAffinityTerm fields are added per-node
    to find the most preferred node(s)","properties":{"podAffinityTerm":{"description":"Required.
    A pod affinity term, associated with the corresponding weight.","properties":{"labelSelector":{"description":"A
    label query over a set of resources, in this case pods.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaceSelector":{"description":"A
    label query over the set of namespaces that the term applies to.\nThe term is
    applied to the union of the namespaces selected by this field\nand the ones listed
    in the namespaces field.\nnull selector and null or empty namespaces list means
    \"this pod''s namespace\".\nAn empty selector ({}) matches all namespaces.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaces":{"description":"namespaces
    specifies a static list of namespace names that the term applies to.\nThe term
    is applied to the union of the namespaces listed in this field\nand the ones selected
    by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector
    means \"this pod''s namespace\".","items":{"type":"string"},"type":"array"},"topologyKey":{"description":"This
    pod should be co-located (affinity) or not co-located (anti-affinity) with the
    pods matching\nthe labelSelector in the specified namespaces, where co-located
    is defined as running on a node\nwhose value of the label with key topologyKey
    matches that of any node on which any of the\nselected pods is running.\nEmpty
    topologyKey is not allowed.","type":"string"}},"required":["topologyKey"],"type":"object"},"weight":{"description":"weight
    associated with matching the corresponding podAffinityTerm,\nin the range 1-100.","format":"int32","type":"integer"}},"required":["podAffinityTerm","weight"],"type":"object"},"type":"array"},"requiredDuringSchedulingIgnoredDuringExecution":{"description":"If
    the affinity requirements specified by this field are not met at\nscheduling time,
    the pod will not be scheduled onto the node.\nIf the affinity requirements specified
    by this field cease to be met\nat some point during pod execution (e.g. due to
    a pod label update), the\nsystem may or may not try to eventually evict the pod
    from its node.\nWhen there are multiple elements, the lists of nodes corresponding
    to each\npodAffinityTerm are intersected, i.e. all terms must be satisfied.","items":{"description":"Defines
    a set of pods (namely those matching the labelSelector\nrelative to the given
    namespace(s)) that this pod should be\nco-located (affinity) or not co-located
    (anti-affinity) with,\nwhere co-located is defined as running on a node whose
    value of\nthe label with key <topologyKey> matches that of any node on which\na
    pod of the set of pods is running","properties":{"labelSelector":{"description":"A
    label query over a set of resources, in this case pods.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaceSelector":{"description":"A
    label query over the set of namespaces that the term applies to.\nThe term is
    applied to the union of the namespaces selected by this field\nand the ones listed
    in the namespaces field.\nnull selector and null or empty namespaces list means
    \"this pod''s namespace\".\nAn empty selector ({}) matches all namespaces.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaces":{"description":"namespaces
    specifies a static list of namespace names that the term applies to.\nThe term
    is applied to the union of the namespaces listed in this field\nand the ones selected
    by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector
    means \"this pod''s namespace\".","items":{"type":"string"},"type":"array"},"topologyKey":{"description":"This
    pod should be co-located (affinity) or not co-located (anti-affinity) with the
    pods matching\nthe labelSelector in the specified namespaces, where co-located
    is defined as running on a node\nwhose value of the label with key topologyKey
    matches that of any node on which any of the\nselected pods is running.\nEmpty
    topologyKey is not allowed.","type":"string"}},"required":["topologyKey"],"type":"object"},"type":"array"}},"type":"object"},"podAntiAffinity":{"description":"Describes
    pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node,
    zone, etc. as some other pod(s)).","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"description":"The
    scheduler will prefer to schedule pods to nodes that satisfy\nthe anti-affinity
    expressions specified by this field, but it may choose\na node that violates one
    or more of the expressions. The node that is\nmost preferred is the one with the
    greatest sum of weights, i.e.\nfor each node that meets all of the scheduling
    requirements (resource\nrequest, requiredDuringScheduling anti-affinity expressions,
    etc.),\ncompute a sum by iterating through the elements of this field and adding\n\"weight\"
    to the sum if the node has pods which matches the corresponding podAffinityTerm;
    the\nnode(s) with the highest sum are the most preferred.","items":{"description":"The
    weights of all of the matched WeightedPodAffinityTerm fields are added per-node
    to find the most preferred node(s)","properties":{"podAffinityTerm":{"description":"Required.
    A pod affinity term, associated with the corresponding weight.","properties":{"labelSelector":{"description":"A
    label query over a set of resources, in this case pods.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaceSelector":{"description":"A
    label query over the set of namespaces that the term applies to.\nThe term is
    applied to the union of the namespaces selected by this field\nand the ones listed
    in the namespaces field.\nnull selector and null or empty namespaces list means
    \"this pod''s namespace\".\nAn empty selector ({}) matches all namespaces.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaces":{"description":"namespaces
    specifies a static list of namespace names that the term applies to.\nThe term
    is applied to the union of the namespaces listed in this field\nand the ones selected
    by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector
    means \"this pod''s namespace\".","items":{"type":"string"},"type":"array"},"topologyKey":{"description":"This
    pod should be co-located (affinity) or not co-located (anti-affinity) with the
    pods matching\nthe labelSelector in the specified namespaces, where co-located
    is defined as running on a node\nwhose value of the label with key topologyKey
    matches that of any node on which any of the\nselected pods is running.\nEmpty
    topologyKey is not allowed.","type":"string"}},"required":["topologyKey"],"type":"object"},"weight":{"description":"weight
    associated with matching the corresponding podAffinityTerm,\nin the range 1-100.","format":"int32","type":"integer"}},"required":["podAffinityTerm","weight"],"type":"object"},"type":"array"},"requiredDuringSchedulingIgnoredDuringExecution":{"description":"If
    the anti-affinity requirements specified by this field are not met at\nscheduling
    time, the pod will not be scheduled onto the node.\nIf the anti-affinity requirements
    specified by this field cease to be met\nat some point during pod execution (e.g.
    due to a pod label update), the\nsystem may or may not try to eventually evict
    the pod from its node.\nWhen there are multiple elements, the lists of nodes corresponding
    to each\npodAffinityTerm are intersected, i.e. all terms must be satisfied.","items":{"description":"Defines
    a set of pods (namely those matching the labelSelector\nrelative to the given
    namespace(s)) that this pod should be\nco-located (affinity) or not co-located
    (anti-affinity) with,\nwhere co-located is defined as running on a node whose
    value of\nthe label with key <topologyKey> matches that of any node on which\na
    pod of the set of pods is running","properties":{"labelSelector":{"description":"A
    label query over a set of resources, in this case pods.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaceSelector":{"description":"A
    label query over the set of namespaces that the term applies to.\nThe term is
    applied to the union of the namespaces selected by this field\nand the ones listed
    in the namespaces field.\nnull selector and null or empty namespaces list means
    \"this pod''s namespace\".\nAn empty selector ({}) matches all namespaces.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaces":{"description":"namespaces
    specifies a static list of namespace names that the term applies to.\nThe term
    is applied to the union of the namespaces listed in this field\nand the ones selected
    by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector
    means \"this pod''s namespace\".","items":{"type":"string"},"type":"array"},"topologyKey":{"description":"This
    pod should be co-located (affinity) or not co-located (anti-affinity) with the
    pods matching\nthe labelSelector in the specified namespaces, where co-located
    is defined as running on a node\nwhose value of the label with key topologyKey
    matches that of any node on which any of the\nselected pods is running.\nEmpty
    topologyKey is not allowed.","type":"string"}},"required":["topologyKey"],"type":"object"},"type":"array"}},"type":"object"}},"type":"object"},"containers":{"description":"Containers
    is a list of calico-windows-upgrade containers.\nIf specified, this overrides
    the specified calico-windows-upgrade DaemonSet containers.\nIf omitted, the calico-windows-upgrade
    DaemonSet will use its default values for its containers.","items":{"description":"CalicoWindowsUpgradeDaemonSetContainer
    is a calico-windows-upgrade DaemonSet container.","properties":{"name":{"description":"Name
    is an enum which identifies the calico-windows-upgrade DaemonSet container by
    name.","enum":["calico-windows-upgrade"],"type":"string"},"resources":{"description":"Resources
    allows customization of limits and requests for compute resources such as cpu
    and memory.\nIf specified, this overrides the named calico-windows-upgrade DaemonSet
    container''s resources.\nIf omitted, the calico-windows-upgrade DaemonSet will
    use its default value for this container''s resources.","properties":{"claims":{"description":"Claims
    lists the names of resources, defined in spec.resourceClaims,\nthat are used by
    this container.\nThis is an alpha field and requires enabling the\nDynamicResourceAllocation
    feature gate.\nThis field is immutable. It can only be set for containers.","items":{"description":"ResourceClaim
    references one entry in PodSpec.ResourceClaims.","properties":{"name":{"description":"Name
    must match the name of one entry in pod.spec.resourceClaims of\nthe Pod where
    this field is used. It makes that resource available\ninside a container.","type":"string"}},"required":["name"],"type":"object"},"type":"array","x-kubernetes-list-map-keys":["name"],"x-kubernetes-list-type":"map"},"limits":{"additionalProperties":{"anyOf":[{"type":"integer"},{"type":"string"}],"pattern":"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$","x-kubernetes-int-or-string":true},"description":"Limits
    describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/","type":"object"},"requests":{"additionalProperties":{"anyOf":[{"type":"integer"},{"type":"string"}],"pattern":"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$","x-kubernetes-int-or-string":true},"description":"Requests
    describes the minimum amount of compute resources required.\nIf Requests is omitted
    for a container, it defaults to Limits if that is explicitly specified,\notherwise
    to an implementation-defined value. Requests cannot exceed Limits.\nMore info:
    https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/","type":"object"}},"type":"object"}},"required":["name"],"type":"object"},"type":"array"},"nodeSelector":{"additionalProperties":{"type":"string"},"description":"NodeSelector
    is the calico-windows-upgrade pod''s scheduling constraints.\nIf specified, each
    of the key/value pairs are added to the calico-windows-upgrade DaemonSet nodeSelector
    provided\nthe key does not already exist in the object''s nodeSelector.\nIf omitted,
    the calico-windows-upgrade DaemonSet will use its default value for nodeSelector.\nWARNING:
    Please note that this field will modify the default calico-windows-upgrade DaemonSet
    nodeSelector.","type":"object"},"tolerations":{"description":"Tolerations is the
    calico-windows-upgrade pod''s tolerations.\nIf specified, this overrides any tolerations
    that may be set on the calico-windows-upgrade DaemonSet.\nIf omitted, the calico-windows-upgrade
    DaemonSet will use its default value for tolerations.\nWARNING: Please note that
    this field will override the default calico-windows-upgrade DaemonSet tolerations.","items":{"description":"The
    pod this Toleration is attached to tolerates any taint that matches\nthe triple
    <key,value,effect> using the matching operator <operator>.","properties":{"effect":{"description":"Effect
    indicates the taint effect to match. Empty means match all taint effects.\nWhen
    specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.","type":"string"},"key":{"description":"Key
    is the taint key that the toleration applies to. Empty means match all taint keys.\nIf
    the key is empty, operator must be Exists; this combination means to match all
    values and all keys.","type":"string"},"operator":{"description":"Operator represents
    a key''s relationship to the value.\nValid operators are Exists and Equal. Defaults
    to Equal.\nExists is equivalent to wildcard for value, so that a pod can\ntolerate
    all taints of a particular category.","type":"string"},"tolerationSeconds":{"description":"TolerationSeconds
    represents the period of time the toleration (which must be\nof effect NoExecute,
    otherwise this field is ignored) tolerates the taint. By default,\nit is not set,
    which means tolerate the taint forever (do not evict). Zero and\nnegative values
    will be treated as 0 (evict immediately) by the system.","format":"int64","type":"integer"},"value":{"description":"Value
    is the taint value the toleration matches to.\nIf the operator is Exists, the
    value should be empty, otherwise just a regular string.","type":"string"}},"type":"object"},"type":"array"}},"type":"object"}},"type":"object"}},"type":"object"}},"type":"object"},"certificateManagement":{"description":"CertificateManagement
    configures pods to submit a CertificateSigningRequest to the certificates.k8s.io/v1beta1
    API in order\nto obtain TLS certificates. This feature requires that you bring
    your own CSR signing and approval process, otherwise\npods will be stuck during
    initialization.","properties":{"caCert":{"description":"Certificate of the authority
    that signs the CertificateSigningRequests in PEM format.","format":"byte","type":"string"},"keyAlgorithm":{"description":"Specify
    the algorithm used by pods to generate a key pair that is associated with the
    X.509 certificate request.\nDefault: RSAWithSize2048","enum":["","RSAWithSize2048","RSAWithSize4096","RSAWithSize8192","ECDSAWithCurve256","ECDSAWithCurve384","ECDSAWithCurve521"],"type":"string"},"signatureAlgorithm":{"description":"Specify
    the algorithm used for the signature of the X.509 certificate request.\nDefault:
    SHA256WithRSA","enum":["","SHA256WithRSA","SHA384WithRSA","SHA512WithRSA","ECDSAWithSHA256","ECDSAWithSHA384","ECDSAWithSHA512"],"type":"string"},"signerName":{"description":"When
    a CSR is issued to the certificates.k8s.io API, the signerName is added to the
    request in order to accommodate for clusters\nwith multiple signers.\nMust be
    formatted as: `<my-domain>/<my-signername>`.","type":"string"}},"required":["caCert","signerName"],"type":"object"},"cni":{"description":"CNI
    specifies the CNI that will be used by this installation.","properties":{"ipam":{"description":"IPAM
    specifies the pod IP address management that will be used in the Calico or\nCalico
    Enterprise installation.","properties":{"type":{"description":"Specifies the IPAM
    plugin that will be used in the Calico or Calico Enterprise installation.\n* For
    CNI Plugin Calico, this field defaults to Calico.\n* For CNI Plugin GKE, this
    field defaults to HostLocal.\n* For CNI Plugin AzureVNET, this field defaults
    to AzureVNET.\n* For CNI Plugin AmazonVPC, this field defaults to AmazonVPC.\nThe
    IPAM plugin is installed and configured only if the CNI plugin is set to Calico,\nfor
    all other values of the CNI plugin the plugin binaries and CNI config is a dependency\nthat
    is expected to be installed separately.\nDefault: Calico","enum":["Calico","HostLocal","AmazonVPC","AzureVNET"],"type":"string"}},"required":["type"],"type":"object"},"type":{"description":"Specifies
    the CNI plugin that will be used in the Calico or Calico Enterprise installation.\n*
    For KubernetesProvider GKE, this field defaults to GKE.\n* For KubernetesProvider
    AKS, this field defaults to AzureVNET.\n* For KubernetesProvider EKS, this field
    defaults to AmazonVPC.\n* If aws-node daemonset exists in kube-system when the
    Installation resource is created, this field defaults to AmazonVPC.\n* For all
    other cases this field defaults to Calico.\nFor the value Calico, the CNI plugin
    binaries and CNI config will be installed as part of deployment,\nfor all other
    values the CNI plugin binaries and CNI config is a dependency that is expected\nto
    be installed separately.\nDefault: Calico","enum":["Calico","GKE","AmazonVPC","AzureVNET"],"type":"string"}},"required":["type"],"type":"object"},"componentResources":{"description":"Deprecated.
    Please use CalicoNodeDaemonSet, TyphaDeployment, and KubeControllersDeployment.\nComponentResources
    can be used to customize the resource requirements for each component.\nNode,
    Typha, and KubeControllers are supported for installations.","items":{"description":"Deprecated.
    Please use component resource config fields in Installation.Spec instead.\nThe
    ComponentResource struct associates a ResourceRequirements with a component by
    name","properties":{"componentName":{"description":"ComponentName is an enum which
    identifies the component","enum":["Node","Typha","KubeControllers"],"type":"string"},"resourceRequirements":{"description":"ResourceRequirements
    allows customization of limits and requests for compute resources such as cpu
    and memory.","properties":{"claims":{"description":"Claims lists the names of
    resources, defined in spec.resourceClaims,\nthat are used by this container.\nThis
    is an alpha field and requires enabling the\nDynamicResourceAllocation feature
    gate.\nThis field is immutable. It can only be set for containers.","items":{"description":"ResourceClaim
    references one entry in PodSpec.ResourceClaims.","properties":{"name":{"description":"Name
    must match the name of one entry in pod.spec.resourceClaims of\nthe Pod where
    this field is used. It makes that resource available\ninside a container.","type":"string"}},"required":["name"],"type":"object"},"type":"array","x-kubernetes-list-map-keys":["name"],"x-kubernetes-list-type":"map"},"limits":{"additionalProperties":{"anyOf":[{"type":"integer"},{"type":"string"}],"pattern":"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$","x-kubernetes-int-or-string":true},"description":"Limits
    describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/","type":"object"},"requests":{"additionalProperties":{"anyOf":[{"type":"integer"},{"type":"string"}],"pattern":"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$","x-kubernetes-int-or-string":true},"description":"Requests
    describes the minimum amount of compute resources required.\nIf Requests is omitted
    for a container, it defaults to Limits if that is explicitly specified,\notherwise
    to an implementation-defined value. Requests cannot exceed Limits.\nMore info:
    https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/","type":"object"}},"type":"object"}},"required":["componentName","resourceRequirements"],"type":"object"},"type":"array"},"controlPlaneNodeSelector":{"additionalProperties":{"type":"string"},"description":"ControlPlaneNodeSelector
    is used to select control plane nodes on which to run Calico\ncomponents. This
    is globally applied to all resources created by the operator excluding daemonsets.","type":"object"},"controlPlaneReplicas":{"description":"ControlPlaneReplicas
    defines how many replicas of the control plane core components will be deployed.\nThis
    field applies to all control plane components that support High Availability.
    Defaults to 2.","format":"int32","type":"integer"},"controlPlaneTolerations":{"description":"ControlPlaneTolerations
    specify tolerations which are then globally applied to all resources\ncreated
    by the operator.","items":{"description":"The pod this Toleration is attached
    to tolerates any taint that matches\nthe triple <key,value,effect> using the matching
    operator <operator>.","properties":{"effect":{"description":"Effect indicates
    the taint effect to match. Empty means match all taint effects.\nWhen specified,
    allowed values are NoSchedule, PreferNoSchedule and NoExecute.","type":"string"},"key":{"description":"Key
    is the taint key that the toleration applies to. Empty means match all taint keys.\nIf
    the key is empty, operator must be Exists; this combination means to match all
    values and all keys.","type":"string"},"operator":{"description":"Operator represents
    a key''s relationship to the value.\nValid operators are Exists and Equal. Defaults
    to Equal.\nExists is equivalent to wildcard for value, so that a pod can\ntolerate
    all taints of a particular category.","type":"string"},"tolerationSeconds":{"description":"TolerationSeconds
    represents the period of time the toleration (which must be\nof effect NoExecute,
    otherwise this field is ignored) tolerates the taint. By default,\nit is not set,
    which means tolerate the taint forever (do not evict). Zero and\nnegative values
    will be treated as 0 (evict immediately) by the system.","format":"int64","type":"integer"},"value":{"description":"Value
    is the taint value the toleration matches to.\nIf the operator is Exists, the
    value should be empty, otherwise just a regular string.","type":"string"}},"type":"object"},"type":"array"},"csiNodeDriverDaemonSet":{"description":"CSINodeDriverDaemonSet
    configures the csi-node-driver DaemonSet.","properties":{"metadata":{"description":"Metadata
    is a subset of a Kubernetes object''s metadata that is added to the DaemonSet.","properties":{"annotations":{"additionalProperties":{"type":"string"},"description":"Annotations
    is a map of arbitrary non-identifying metadata. Each of these\nkey/value pairs
    are added to the object''s annotations provided the key does not\nalready exist
    in the object''s annotations.","type":"object"},"labels":{"additionalProperties":{"type":"string"},"description":"Labels
    is a map of string keys and values that may match replicaset and\nservice selectors.
    Each of these key/value pairs are added to the\nobject''s labels provided the
    key does not already exist in the object''s labels.","type":"object"}},"type":"object"},"spec":{"description":"Spec
    is the specification of the csi-node-driver DaemonSet.","properties":{"minReadySeconds":{"description":"MinReadySeconds
    is the minimum number of seconds for which a newly created DaemonSet pod should\nbe
    ready without any of its container crashing, for it to be considered available.\nIf
    specified, this overrides any minReadySeconds value that may be set on the csi-node-driver
    DaemonSet.\nIf omitted, the csi-node-driver DaemonSet will use its default value
    for minReadySeconds.","format":"int32","maximum":2147483647,"minimum":0,"type":"integer"},"template":{"description":"Template
    describes the csi-node-driver DaemonSet pod that will be created.","properties":{"metadata":{"description":"Metadata
    is a subset of a Kubernetes object''s metadata that is added to\nthe pod''s metadata.","properties":{"annotations":{"additionalProperties":{"type":"string"},"description":"Annotations
    is a map of arbitrary non-identifying metadata. Each of these\nkey/value pairs
    are added to the object''s annotations provided the key does not\nalready exist
    in the object''s annotations.","type":"object"},"labels":{"additionalProperties":{"type":"string"},"description":"Labels
    is a map of string keys and values that may match replicaset and\nservice selectors.
    Each of these key/value pairs are added to the\nobject''s labels provided the
    key does not already exist in the object''s labels.","type":"object"}},"type":"object"},"spec":{"description":"Spec
    is the csi-node-driver DaemonSet''s PodSpec.","properties":{"affinity":{"description":"Affinity
    is a group of affinity scheduling rules for the csi-node-driver pods.\nIf specified,
    this overrides any affinity that may be set on the csi-node-driver DaemonSet.\nIf
    omitted, the csi-node-driver DaemonSet will use its default value for affinity.\nWARNING:
    Please note that this field will override the default csi-node-driver DaemonSet
    affinity.","properties":{"nodeAffinity":{"description":"Describes node affinity
    scheduling rules for the pod.","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"description":"The
    scheduler will prefer to schedule pods to nodes that satisfy\nthe affinity expressions
    specified by this field, but it may choose\na node that violates one or more of
    the expressions. The node that is\nmost preferred is the one with the greatest
    sum of weights, i.e.\nfor each node that meets all of the scheduling requirements
    (resource\nrequest, requiredDuringScheduling affinity expressions, etc.),\ncompute
    a sum by iterating through the elements of this field and adding\n\"weight\" to
    the sum if the node matches the corresponding matchExpressions; the\nnode(s) with
    the highest sum are the most preferred.","items":{"description":"An empty preferred
    scheduling term matches all objects with implicit weight 0\n(i.e. it''s a no-op).
    A null preferred scheduling term matches no objects (i.e. is also a no-op).","properties":{"preference":{"description":"A
    node selector term, associated with the corresponding weight.","properties":{"matchExpressions":{"description":"A
    list of node selector requirements by node''s labels.","items":{"description":"A
    node selector requirement is a selector that contains values, a key, and an operator\nthat
    relates the key and values.","properties":{"key":{"description":"The label key
    that the selector applies to.","type":"string"},"operator":{"description":"Represents
    a key''s relationship to a set of values.\nValid operators are In, NotIn, Exists,
    DoesNotExist. Gt, and Lt.","type":"string"},"values":{"description":"An array
    of string values. If the operator is In or NotIn,\nthe values array must be non-empty.
    If the operator is Exists or DoesNotExist,\nthe values array must be empty. If
    the operator is Gt or Lt, the values\narray must have a single element, which
    will be interpreted as an integer.\nThis array is replaced during a strategic
    merge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchFields":{"description":"A
    list of node selector requirements by node''s fields.","items":{"description":"A
    node selector requirement is a selector that contains values, a key, and an operator\nthat
    relates the key and values.","properties":{"key":{"description":"The label key
    that the selector applies to.","type":"string"},"operator":{"description":"Represents
    a key''s relationship to a set of values.\nValid operators are In, NotIn, Exists,
    DoesNotExist. Gt, and Lt.","type":"string"},"values":{"description":"An array
    of string values. If the operator is In or NotIn,\nthe values array must be non-empty.
    If the operator is Exists or DoesNotExist,\nthe values array must be empty. If
    the operator is Gt or Lt, the values\narray must have a single element, which
    will be interpreted as an integer.\nThis array is replaced during a strategic
    merge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"}},"type":"object","x-kubernetes-map-type":"atomic"},"weight":{"description":"Weight
    associated with matching the corresponding nodeSelectorTerm, in the range 1-100.","format":"int32","type":"integer"}},"required":["preference","weight"],"type":"object"},"type":"array"},"requiredDuringSchedulingIgnoredDuringExecution":{"description":"If
    the affinity requirements specified by this field are not met at\nscheduling time,
    the pod will not be scheduled onto the node.\nIf the affinity requirements specified
    by this field cease to be met\nat some point during pod execution (e.g. due to
    an update), the system\nmay or may not try to eventually evict the pod from its
    node.","properties":{"nodeSelectorTerms":{"description":"Required. A list of node
    selector terms. The terms are ORed.","items":{"description":"A null or empty node
    selector term matches no objects. The requirements of\nthem are ANDed.\nThe TopologySelectorTerm
    type implements a subset of the NodeSelectorTerm.","properties":{"matchExpressions":{"description":"A
    list of node selector requirements by node''s labels.","items":{"description":"A
    node selector requirement is a selector that contains values, a key, and an operator\nthat
    relates the key and values.","properties":{"key":{"description":"The label key
    that the selector applies to.","type":"string"},"operator":{"description":"Represents
    a key''s relationship to a set of values.\nValid operators are In, NotIn, Exists,
    DoesNotExist. Gt, and Lt.","type":"string"},"values":{"description":"An array
    of string values. If the operator is In or NotIn,\nthe values array must be non-empty.
    If the operator is Exists or DoesNotExist,\nthe values array must be empty. If
    the operator is Gt or Lt, the values\narray must have a single element, which
    will be interpreted as an integer.\nThis array is replaced during a strategic
    merge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchFields":{"description":"A
    list of node selector requirements by node''s fields.","items":{"description":"A
    node selector requirement is a selector that contains values, a key, and an operator\nthat
    relates the key and values.","properties":{"key":{"description":"The label key
    that the selector applies to.","type":"string"},"operator":{"description":"Represents
    a key''s relationship to a set of values.\nValid operators are In, NotIn, Exists,
    DoesNotExist. Gt, and Lt.","type":"string"},"values":{"description":"An array
    of string values. If the operator is In or NotIn,\nthe values array must be non-empty.
    If the operator is Exists or DoesNotExist,\nthe values array must be empty. If
    the operator is Gt or Lt, the values\narray must have a single element, which
    will be interpreted as an integer.\nThis array is replaced during a strategic
    merge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"}},"type":"object","x-kubernetes-map-type":"atomic"},"type":"array"}},"required":["nodeSelectorTerms"],"type":"object","x-kubernetes-map-type":"atomic"}},"type":"object"},"podAffinity":{"description":"Describes
    pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone,
    etc. as some other pod(s)).","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"description":"The
    scheduler will prefer to schedule pods to nodes that satisfy\nthe affinity expressions
    specified by this field, but it may choose\na node that violates one or more of
    the expressions. The node that is\nmost preferred is the one with the greatest
    sum of weights, i.e.\nfor each node that meets all of the scheduling requirements
    (resource\nrequest, requiredDuringScheduling affinity expressions, etc.),\ncompute
    a sum by iterating through the elements of this field and adding\n\"weight\" to
    the sum if the node has pods which matches the corresponding podAffinityTerm;
    the\nnode(s) with the highest sum are the most preferred.","items":{"description":"The
    weights of all of the matched WeightedPodAffinityTerm fields are added per-node
    to find the most preferred node(s)","properties":{"podAffinityTerm":{"description":"Required.
    A pod affinity term, associated with the corresponding weight.","properties":{"labelSelector":{"description":"A
    label query over a set of resources, in this case pods.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaceSelector":{"description":"A
    label query over the set of namespaces that the term applies to.\nThe term is
    applied to the union of the namespaces selected by this field\nand the ones listed
    in the namespaces field.\nnull selector and null or empty namespaces list means
    \"this pod''s namespace\".\nAn empty selector ({}) matches all namespaces.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaces":{"description":"namespaces
    specifies a static list of namespace names that the term applies to.\nThe term
    is applied to the union of the namespaces listed in this field\nand the ones selected
    by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector
    means \"this pod''s namespace\".","items":{"type":"string"},"type":"array"},"topologyKey":{"description":"This
    pod should be co-located (affinity) or not co-located (anti-affinity) with the
    pods matching\nthe labelSelector in the specified namespaces, where co-located
    is defined as running on a node\nwhose value of the label with key topologyKey
    matches that of any node on which any of the\nselected pods is running.\nEmpty
    topologyKey is not allowed.","type":"string"}},"required":["topologyKey"],"type":"object"},"weight":{"description":"weight
    associated with matching the corresponding podAffinityTerm,\nin the range 1-100.","format":"int32","type":"integer"}},"required":["podAffinityTerm","weight"],"type":"object"},"type":"array"},"requiredDuringSchedulingIgnoredDuringExecution":{"description":"If
    the affinity requirements specified by this field are not met at\nscheduling time,
    the pod will not be scheduled onto the node.\nIf the affinity requirements specified
    by this field cease to be met\nat some point during pod execution (e.g. due to
    a pod label update), the\nsystem may or may not try to eventually evict the pod
    from its node.\nWhen there are multiple elements, the lists of nodes corresponding
    to each\npodAffinityTerm are intersected, i.e. all terms must be satisfied.","items":{"description":"Defines
    a set of pods (namely those matching the labelSelector\nrelative to the given
    namespace(s)) that this pod should be\nco-located (affinity) or not co-located
    (anti-affinity) with,\nwhere co-located is defined as running on a node whose
    value of\nthe label with key <topologyKey> matches that of any node on which\na
    pod of the set of pods is running","properties":{"labelSelector":{"description":"A
    label query over a set of resources, in this case pods.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaceSelector":{"description":"A
    label query over the set of namespaces that the term applies to.\nThe term is
    applied to the union of the namespaces selected by this field\nand the ones listed
    in the namespaces field.\nnull selector and null or empty namespaces list means
    \"this pod''s namespace\".\nAn empty selector ({}) matches all namespaces.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaces":{"description":"namespaces
    specifies a static list of namespace names that the term applies to.\nThe term
    is applied to the union of the namespaces listed in this field\nand the ones selected
    by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector
    means \"this pod''s namespace\".","items":{"type":"string"},"type":"array"},"topologyKey":{"description":"This
    pod should be co-located (affinity) or not co-located (anti-affinity) with the
    pods matching\nthe labelSelector in the specified namespaces, where co-located
    is defined as running on a node\nwhose value of the label with key topologyKey
    matches that of any node on which any of the\nselected pods is running.\nEmpty
    topologyKey is not allowed.","type":"string"}},"required":["topologyKey"],"type":"object"},"type":"array"}},"type":"object"},"podAntiAffinity":{"description":"Describes
    pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node,
    zone, etc. as some other pod(s)).","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"description":"The
    scheduler will prefer to schedule pods to nodes that satisfy\nthe anti-affinity
    expressions specified by this field, but it may choose\na node that violates one
    or more of the expressions. The node that is\nmost preferred is the one with the
    greatest sum of weights, i.e.\nfor each node that meets all of the scheduling
    requirements (resource\nrequest, requiredDuringScheduling anti-affinity expressions,
    etc.),\ncompute a sum by iterating through the elements of this field and adding\n\"weight\"
    to the sum if the node has pods which matches the corresponding podAffinityTerm;
    the\nnode(s) with the highest sum are the most preferred.","items":{"description":"The
    weights of all of the matched WeightedPodAffinityTerm fields are added per-node
    to find the most preferred node(s)","properties":{"podAffinityTerm":{"description":"Required.
    A pod affinity term, associated with the corresponding weight.","properties":{"labelSelector":{"description":"A
    label query over a set of resources, in this case pods.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaceSelector":{"description":"A
    label query over the set of namespaces that the term applies to.\nThe term is
    applied to the union of the namespaces selected by this field\nand the ones listed
    in the namespaces field.\nnull selector and null or empty namespaces list means
    \"this pod''s namespace\".\nAn empty selector ({}) matches all namespaces.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaces":{"description":"namespaces
    specifies a static list of namespace names that the term applies to.\nThe term
    is applied to the union of the namespaces listed in this field\nand the ones selected
    by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector
    means \"this pod''s namespace\".","items":{"type":"string"},"type":"array"},"topologyKey":{"description":"This
    pod should be co-located (affinity) or not co-located (anti-affinity) with the
    pods matching\nthe labelSelector in the specified namespaces, where co-located
    is defined as running on a node\nwhose value of the label with key topologyKey
    matches that of any node on which any of the\nselected pods is running.\nEmpty
    topologyKey is not allowed.","type":"string"}},"required":["topologyKey"],"type":"object"},"weight":{"description":"weight
    associated with matching the corresponding podAffinityTerm,\nin the range 1-100.","format":"int32","type":"integer"}},"required":["podAffinityTerm","weight"],"type":"object"},"type":"array"},"requiredDuringSchedulingIgnoredDuringExecution":{"description":"If
    the anti-affinity requirements specified by this field are not met at\nscheduling
    time, the pod will not be scheduled onto the node.\nIf the anti-affinity requirements
    specified by this field cease to be met\nat some point during pod execution (e.g.
    due to a pod label update), the\nsystem may or may not try to eventually evict
    the pod from its node.\nWhen there are multiple elements, the lists of nodes corresponding
    to each\npodAffinityTerm are intersected, i.e. all terms must be satisfied.","items":{"description":"Defines
    a set of pods (namely those matching the labelSelector\nrelative to the given
    namespace(s)) that this pod should be\nco-located (affinity) or not co-located
    (anti-affinity) with,\nwhere co-located is defined as running on a node whose
    value of\nthe label with key <topologyKey> matches that of any node on which\na
    pod of the set of pods is running","properties":{"labelSelector":{"description":"A
    label query over a set of resources, in this case pods.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaceSelector":{"description":"A
    label query over the set of namespaces that the term applies to.\nThe term is
    applied to the union of the namespaces selected by this field\nand the ones listed
    in the namespaces field.\nnull selector and null or empty namespaces list means
    \"this pod''s namespace\".\nAn empty selector ({}) matches all namespaces.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaces":{"description":"namespaces
    specifies a static list of namespace names that the term applies to.\nThe term
    is applied to the union of the namespaces listed in this field\nand the ones selected
    by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector
    means \"this pod''s namespace\".","items":{"type":"string"},"type":"array"},"topologyKey":{"description":"This
    pod should be co-located (affinity) or not co-located (anti-affinity) with the
    pods matching\nthe labelSelector in the specified namespaces, where co-located
    is defined as running on a node\nwhose value of the label with key topologyKey
    matches that of any node on which any of the\nselected pods is running.\nEmpty
    topologyKey is not allowed.","type":"string"}},"required":["topologyKey"],"type":"object"},"type":"array"}},"type":"object"}},"type":"object"},"containers":{"description":"Containers
    is a list of csi-node-driver containers.\nIf specified, this overrides the specified
    csi-node-driver DaemonSet containers.\nIf omitted, the csi-node-driver DaemonSet
    will use its default values for its containers.","items":{"description":"CSINodeDriverDaemonSetContainer
    is a csi-node-driver DaemonSet container.","properties":{"name":{"description":"Name
    is an enum which identifies the csi-node-driver DaemonSet container by name.\nSupported
    values are: calico-csi, csi-node-driver-registrar.","enum":["calico-csi","csi-node-driver-registrar","csi-node-driver"],"type":"string"},"resources":{"description":"Resources
    allows customization of limits and requests for compute resources such as cpu
    and memory.\nIf specified, this overrides the named csi-node-driver DaemonSet
    container''s resources.\nIf omitted, the csi-node-driver DaemonSet will use its
    default value for this container''s resources.","properties":{"claims":{"description":"Claims
    lists the names of resources, defined in spec.resourceClaims,\nthat are used by
    this container.\nThis is an alpha field and requires enabling the\nDynamicResourceAllocation
    feature gate.\nThis field is immutable. It can only be set for containers.","items":{"description":"ResourceClaim
    references one entry in PodSpec.ResourceClaims.","properties":{"name":{"description":"Name
    must match the name of one entry in pod.spec.resourceClaims of\nthe Pod where
    this field is used. It makes that resource available\ninside a container.","type":"string"}},"required":["name"],"type":"object"},"type":"array","x-kubernetes-list-map-keys":["name"],"x-kubernetes-list-type":"map"},"limits":{"additionalProperties":{"anyOf":[{"type":"integer"},{"type":"string"}],"pattern":"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$","x-kubernetes-int-or-string":true},"description":"Limits
    describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/","type":"object"},"requests":{"additionalProperties":{"anyOf":[{"type":"integer"},{"type":"string"}],"pattern":"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$","x-kubernetes-int-or-string":true},"description":"Requests
    describes the minimum amount of compute resources required.\nIf Requests is omitted
    for a container, it defaults to Limits if that is explicitly specified,\notherwise
    to an implementation-defined value. Requests cannot exceed Limits.\nMore info:
    https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/","type":"object"}},"type":"object"}},"required":["name"],"type":"object"},"type":"array"},"nodeSelector":{"additionalProperties":{"type":"string"},"description":"NodeSelector
    is the csi-node-driver pod''s scheduling constraints.\nIf specified, each of the
    key/value pairs are added to the csi-node-driver DaemonSet nodeSelector provided\nthe
    key does not already exist in the object''s nodeSelector.\nIf omitted, the csi-node-driver
    DaemonSet will use its default value for nodeSelector.\nWARNING: Please note that
    this field will modify the default csi-node-driver DaemonSet nodeSelector.","type":"object"},"tolerations":{"description":"Tolerations
    is the csi-node-driver pod''s tolerations.\nIf specified, this overrides any tolerations
    that may be set on the csi-node-driver DaemonSet.\nIf omitted, the csi-node-driver
    DaemonSet will use its default value for tolerations.\nWARNING: Please note that
    this field will override the default csi-node-driver DaemonSet tolerations.","items":{"description":"The
    pod this Toleration is attached to tolerates any taint that matches\nthe triple
    <key,value,effect> using the matching operator <operator>.","properties":{"effect":{"description":"Effect
    indicates the taint effect to match. Empty means match all taint effects.\nWhen
    specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.","type":"string"},"key":{"description":"Key
    is the taint key that the toleration applies to. Empty means match all taint keys.\nIf
    the key is empty, operator must be Exists; this combination means to match all
    values and all keys.","type":"string"},"operator":{"description":"Operator represents
    a key''s relationship to the value.\nValid operators are Exists and Equal. Defaults
    to Equal.\nExists is equivalent to wildcard for value, so that a pod can\ntolerate
    all taints of a particular category.","type":"string"},"tolerationSeconds":{"description":"TolerationSeconds
    represents the period of time the toleration (which must be\nof effect NoExecute,
    otherwise this field is ignored) tolerates the taint. By default,\nit is not set,
    which means tolerate the taint forever (do not evict). Zero and\nnegative values
    will be treated as 0 (evict immediately) by the system.","format":"int64","type":"integer"},"value":{"description":"Value
    is the taint value the toleration matches to.\nIf the operator is Exists, the
    value should be empty, otherwise just a regular string.","type":"string"}},"type":"object"},"type":"array"}},"type":"object"}},"type":"object"}},"type":"object"}},"type":"object"},"fipsMode":{"description":"FIPSMode
    uses images and features only that are using FIPS 140-2 validated cryptographic
    modules and standards.\nDefault: Disabled","enum":["Enabled","Disabled"],"type":"string"},"flexVolumePath":{"description":"FlexVolumePath
    optionally specifies a custom path for FlexVolume. If not specified, FlexVolume
    will be\nenabled by default. If set to ''None'', FlexVolume will be disabled.
    The default is based on the\nkubernetesProvider.","type":"string"},"imagePath":{"description":"ImagePath
    allows for the path part of an image to be specified. If specified\nthen the specified
    value will be used as the image path for each image. If not specified\nor empty,
    the default for each image will be used.\nA special case value, UseDefault, is
    supported to explicitly specify the default\nimage path will be used for each
    image.\nImage format:\n   `<registry><imagePath>/<imagePrefix><imageName>:<image-tag>`\nThis
    option allows configuring the `<imagePath>` portion of the above format.","type":"string"},"imagePrefix":{"description":"ImagePrefix
    allows for the prefix part of an image to be specified. If specified\nthen the
    given value will be used as a prefix on each image. If not specified\nor empty,
    no prefix will be used.\nA special case value, UseDefault, is supported to explicitly
    specify the default\nimage prefix will be used for each image.\nImage format:\n   `<registry><imagePath>/<imagePrefix><imageName>:<image-tag>`\nThis
    option allows configuring the `<imagePrefix>` portion of the above format.","type":"string"},"imagePullSecrets":{"description":"ImagePullSecrets
    is an array of references to container registry pull secrets to use. These are\napplied
    to all images to be pulled.","items":{"description":"LocalObjectReference contains
    enough information to let you locate the\nreferenced object inside the same namespace.","properties":{"name":{"description":"Name
    of the referent.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names\nTODO:
    Add other useful fields. apiVersion, kind, uid?","type":"string"}},"type":"object","x-kubernetes-map-type":"atomic"},"type":"array"},"kubeletVolumePluginPath":{"description":"KubeletVolumePluginPath
    optionally specifies enablement of Calico CSI plugin. If not specified,\nCSI will
    be enabled by default. If set to ''None'', CSI will be disabled.\nDefault: /var/lib/kubelet","type":"string"},"kubernetesProvider":{"description":"KubernetesProvider
    specifies a particular provider of the Kubernetes platform and enables provider-specific
    configuration.\nIf the specified value is empty, the Operator will attempt to
    automatically determine the current provider.\nIf the specified value is not empty,
    the Operator will still attempt auto-detection, but\nwill additionally compare
    the auto-detected value to the specified value to confirm they match.","enum":["","EKS","GKE","AKS","OpenShift","DockerEnterprise","RKE2","TKG"],"type":"string"},"logging":{"description":"Logging
    Configuration for Components","properties":{"cni":{"description":"Customized logging
    specification for calico-cni plugin","properties":{"logFileMaxAgeDays":{"description":"Default:
    30 (days)","format":"int32","type":"integer"},"logFileMaxCount":{"description":"Default:
    10","format":"int32","type":"integer"},"logFileMaxSize":{"anyOf":[{"type":"integer"},{"type":"string"}],"description":"Default:
    100Mi","pattern":"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$","x-kubernetes-int-or-string":true},"logSeverity":{"description":"Default:
    Info","enum":["Error","Warning","Debug","Info"],"type":"string"}},"type":"object"}},"type":"object"},"nodeMetricsPort":{"description":"NodeMetricsPort
    specifies which port calico/node serves prometheus metrics on. By default, metrics
    are not enabled.\nIf specified, this overrides any FelixConfiguration resources
    which may exist. If omitted, then\nprometheus metrics may still be configured
    through FelixConfiguration.","format":"int32","type":"integer"},"nodeUpdateStrategy":{"description":"NodeUpdateStrategy
    can be used to customize the desired update strategy, such as the MaxUnavailable\nfield.","properties":{"rollingUpdate":{"description":"Rolling
    update config params. Present only if type = \"RollingUpdate\".\n---\nTODO: Update
    this to follow our convention for oneOf, whatever we decide it\nto be. Same as
    Deployment `strategy.rollingUpdate`.\nSee https://github.com/kubernetes/kubernetes/issues/35345","properties":{"maxSurge":{"anyOf":[{"type":"integer"},{"type":"string"}],"description":"The
    maximum number of nodes with an existing available DaemonSet pod that\ncan have
    an updated DaemonSet pod during during an update.\nValue can be an absolute number
    (ex: 5) or a percentage of desired pods (ex: 10%).\nThis can not be 0 if MaxUnavailable
    is 0.\nAbsolute number is calculated from percentage by rounding up to a minimum
    of 1.\nDefault value is 0.\nExample: when this is set to 30%, at most 30% of the
    total number of nodes\nthat should be running the daemon pod (i.e. status.desiredNumberScheduled)\ncan
    have their a new pod created before the old pod is marked as deleted.\nThe update
    starts by launching new pods on 30% of nodes. Once an updated\npod is available
    (Ready for at least minReadySeconds) the old DaemonSet pod\non that node is marked
    deleted. If the old pod becomes unavailable for any\nreason (Ready transitions
    to false, is evicted, or is drained) an updated\npod is immediatedly created on
    that node without considering surge limits.\nAllowing surge implies the possibility
    that the resources consumed by the\ndaemonset on any given node can double if
    the readiness check fails, and\nso resource intensive daemonsets should take into
    account that they may\ncause evictions during disruption.","x-kubernetes-int-or-string":true},"maxUnavailable":{"anyOf":[{"type":"integer"},{"type":"string"}],"description":"The
    maximum number of DaemonSet pods that can be unavailable during the\nupdate. Value
    can be an absolute number (ex: 5) or a percentage of total\nnumber of DaemonSet
    pods at the start of the update (ex: 10%). Absolute\nnumber is calculated from
    percentage by rounding up.\nThis cannot be 0 if MaxSurge is 0\nDefault value is
    1.\nExample: when this is set to 30%, at most 30% of the total number of nodes\nthat
    should be running the daemon pod (i.e. status.desiredNumberScheduled)\ncan have
    their pods stopped for an update at any given time. The update\nstarts by stopping
    at most 30% of those DaemonSet pods and then brings\nup new DaemonSet pods in
    their place. Once the new pods are available,\nit then proceeds onto other DaemonSet
    pods, thus ensuring that at least\n70% of original number of DaemonSet pods are
    available at all times during\nthe update.","x-kubernetes-int-or-string":true}},"type":"object"},"type":{"description":"Type
    of daemon set update. Can be \"RollingUpdate\" or \"OnDelete\". Default is RollingUpdate.","type":"string"}},"type":"object"},"nonPrivileged":{"description":"NonPrivileged
    configures Calico to be run in non-privileged containers as non-root users where
    possible.","type":"string"},"registry":{"description":"Registry is the default
    Docker registry used for component Docker images.\nIf specified then the given
    value must end with a slash character (`/`) and all images will be pulled from
    this registry.\nIf not specified then the default registries will be used. A special
    case value, UseDefault, is\nsupported to explicitly specify the default registries
    will be used.\nImage format:\n   `<registry><imagePath>/<imagePrefix><imageName>:<image-tag>`\nThis
    option allows configuring the `<registry>` portion of the above format.","type":"string"},"serviceCIDRs":{"description":"Kubernetes
    Service CIDRs. Specifying this is required when using Calico for Windows.","items":{"type":"string"},"type":"array"},"typhaAffinity":{"description":"Deprecated.
    Please use Installation.Spec.TyphaDeployment instead.\nTyphaAffinity allows configuration
    of node affinity characteristics for Typha pods.","properties":{"nodeAffinity":{"description":"NodeAffinity
    describes node affinity scheduling rules for typha.","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"description":"The
    scheduler will prefer to schedule pods to nodes that satisfy\nthe affinity expressions
    specified by this field, but it may choose\na node that violates one or more of
    the expressions.","items":{"description":"An empty preferred scheduling term matches
    all objects with implicit weight 0\n(i.e. it''s a no-op). A null preferred scheduling
    term matches no objects (i.e. is also a no-op).","properties":{"preference":{"description":"A
    node selector term, associated with the corresponding weight.","properties":{"matchExpressions":{"description":"A
    list of node selector requirements by node''s labels.","items":{"description":"A
    node selector requirement is a selector that contains values, a key, and an operator\nthat
    relates the key and values.","properties":{"key":{"description":"The label key
    that the selector applies to.","type":"string"},"operator":{"description":"Represents
    a key''s relationship to a set of values.\nValid operators are In, NotIn, Exists,
    DoesNotExist. Gt, and Lt.","type":"string"},"values":{"description":"An array
    of string values. If the operator is In or NotIn,\nthe values array must be non-empty.
    If the operator is Exists or DoesNotExist,\nthe values array must be empty. If
    the operator is Gt or Lt, the values\narray must have a single element, which
    will be interpreted as an integer.\nThis array is replaced during a strategic
    merge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchFields":{"description":"A
    list of node selector requirements by node''s fields.","items":{"description":"A
    node selector requirement is a selector that contains values, a key, and an operator\nthat
    relates the key and values.","properties":{"key":{"description":"The label key
    that the selector applies to.","type":"string"},"operator":{"description":"Represents
    a key''s relationship to a set of values.\nValid operators are In, NotIn, Exists,
    DoesNotExist. Gt, and Lt.","type":"string"},"values":{"description":"An array
    of string values. If the operator is In or NotIn,\nthe values array must be non-empty.
    If the operator is Exists or DoesNotExist,\nthe values array must be empty. If
    the operator is Gt or Lt, the values\narray must have a single element, which
    will be interpreted as an integer.\nThis array is replaced during a strategic
    merge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"}},"type":"object","x-kubernetes-map-type":"atomic"},"weight":{"description":"Weight
    associated with matching the corresponding nodeSelectorTerm, in the range 1-100.","format":"int32","type":"integer"}},"required":["preference","weight"],"type":"object"},"type":"array"},"requiredDuringSchedulingIgnoredDuringExecution":{"description":"WARNING:
    Please note that if the affinity requirements specified by this field are not
    met at\nscheduling time, the pod will NOT be scheduled onto the node.\nThere is
    no fallback to another affinity rules with this setting.\nThis may cause networking
    disruption or even catastrophic failure!\nPreferredDuringSchedulingIgnoredDuringExecution
    should be used for affinity\nunless there is a specific well understood reason
    to use RequiredDuringSchedulingIgnoredDuringExecution and\nyou can guarantee that
    the RequiredDuringSchedulingIgnoredDuringExecution will always have sufficient
    nodes to satisfy the requirement.\nNOTE: RequiredDuringSchedulingIgnoredDuringExecution
    is set by default for AKS nodes,\nto avoid scheduling Typhas on virtual-nodes.\nIf
    the affinity requirements specified by this field cease to be met\nat some point
    during pod execution (e.g. due to an update), the system\nmay or may not try to
    eventually evict the pod from its node.","properties":{"nodeSelectorTerms":{"description":"Required.
    A list of node selector terms. The terms are ORed.","items":{"description":"A
    null or empty node selector term matches no objects. The requirements of\nthem
    are ANDed.\nThe TopologySelectorTerm type implements a subset of the NodeSelectorTerm.","properties":{"matchExpressions":{"description":"A
    list of node selector requirements by node''s labels.","items":{"description":"A
    node selector requirement is a selector that contains values, a key, and an operator\nthat
    relates the key and values.","properties":{"key":{"description":"The label key
    that the selector applies to.","type":"string"},"operator":{"description":"Represents
    a key''s relationship to a set of values.\nValid operators are In, NotIn, Exists,
    DoesNotExist. Gt, and Lt.","type":"string"},"values":{"description":"An array
    of string values. If the operator is In or NotIn,\nthe values array must be non-empty.
    If the operator is Exists or DoesNotExist,\nthe values array must be empty. If
    the operator is Gt or Lt, the values\narray must have a single element, which
    will be interpreted as an integer.\nThis array is replaced during a strategic
    merge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchFields":{"description":"A
    list of node selector requirements by node''s fields.","items":{"description":"A
    node selector requirement is a selector that contains values, a key, and an operator\nthat
    relates the key and values.","properties":{"key":{"description":"The label key
    that the selector applies to.","type":"string"},"operator":{"description":"Represents
    a key''s relationship to a set of values.\nValid operators are In, NotIn, Exists,
    DoesNotExist. Gt, and Lt.","type":"string"},"values":{"description":"An array
    of string values. If the operator is In or NotIn,\nthe values array must be non-empty.
    If the operator is Exists or DoesNotExist,\nthe values array must be empty. If
    the operator is Gt or Lt, the values\narray must have a single element, which
    will be interpreted as an integer.\nThis array is replaced during a strategic
    merge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"}},"type":"object","x-kubernetes-map-type":"atomic"},"type":"array"}},"required":["nodeSelectorTerms"],"type":"object","x-kubernetes-map-type":"atomic"}},"type":"object"}},"type":"object"},"typhaDeployment":{"description":"TyphaDeployment
    configures the typha Deployment. If used in conjunction with the deprecated\nComponentResources
    or TyphaAffinity, then these overrides take precedence.","properties":{"metadata":{"description":"Metadata
    is a subset of a Kubernetes object''s metadata that is added to the Deployment.","properties":{"annotations":{"additionalProperties":{"type":"string"},"description":"Annotations
    is a map of arbitrary non-identifying metadata. Each of these\nkey/value pairs
    are added to the object''s annotations provided the key does not\nalready exist
    in the object''s annotations.","type":"object"},"labels":{"additionalProperties":{"type":"string"},"description":"Labels
    is a map of string keys and values that may match replicaset and\nservice selectors.
    Each of these key/value pairs are added to the\nobject''s labels provided the
    key does not already exist in the object''s labels.","type":"object"}},"type":"object"},"spec":{"description":"Spec
    is the specification of the typha Deployment.","properties":{"minReadySeconds":{"description":"MinReadySeconds
    is the minimum number of seconds for which a newly created Deployment pod should\nbe
    ready without any of its container crashing, for it to be considered available.\nIf
    specified, this overrides any minReadySeconds value that may be set on the typha
    Deployment.\nIf omitted, the typha Deployment will use its default value for minReadySeconds.","format":"int32","maximum":2147483647,"minimum":0,"type":"integer"},"strategy":{"description":"The
    deployment strategy to use to replace existing pods with new ones.","properties":{"rollingUpdate":{"description":"Rolling
    update config params. Present only if DeploymentStrategyType =\nRollingUpdate.\nto
    be.","properties":{"maxSurge":{"anyOf":[{"type":"integer"},{"type":"string"}],"description":"The
    maximum number of pods that can be scheduled above the desired number of\npods.\nValue
    can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).\nThis
    can not be 0 if MaxUnavailable is 0.\nAbsolute number is calculated from percentage
    by rounding up.\nDefaults to 25%.\nExample: when this is set to 30%, the new ReplicaSet
    can be scaled up immediately when\nthe rolling update starts, such that the total
    number of old and new pods do not exceed\n130% of desired pods. Once old pods
    have been killed,\nnew ReplicaSet can be scaled up further, ensuring that total
    number of pods running\nat any time during the update is at most 130% of desired
    pods.","x-kubernetes-int-or-string":true},"maxUnavailable":{"anyOf":[{"type":"integer"},{"type":"string"}],"description":"The
    maximum number of pods that can be unavailable during the update.\nValue can be
    an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).\nAbsolute
    number is calculated from percentage by rounding down.\nThis can not be 0 if MaxSurge
    is 0.\nDefaults to 25%.\nExample: when this is set to 30%, the old ReplicaSet
    can be scaled down to 70% of desired pods\nimmediately when the rolling update
    starts. Once new pods are ready, old ReplicaSet\ncan be scaled down further, followed
    by scaling up the new ReplicaSet, ensuring\nthat the total number of pods available
    at all times during the update is at\nleast 70% of desired pods.","x-kubernetes-int-or-string":true}},"type":"object"}},"type":"object"},"template":{"description":"Template
    describes the typha Deployment pod that will be created.","properties":{"metadata":{"description":"Metadata
    is a subset of a Kubernetes object''s metadata that is added to\nthe pod''s metadata.","properties":{"annotations":{"additionalProperties":{"type":"string"},"description":"Annotations
    is a map of arbitrary non-identifying metadata. Each of these\nkey/value pairs
    are added to the object''s annotations provided the key does not\nalready exist
    in the object''s annotations.","type":"object"},"labels":{"additionalProperties":{"type":"string"},"description":"Labels
    is a map of string keys and values that may match replicaset and\nservice selectors.
    Each of these key/value pairs are added to the\nobject''s labels provided the
    key does not already exist in the object''s labels.","type":"object"}},"type":"object"},"spec":{"description":"Spec
    is the typha Deployment''s PodSpec.","properties":{"affinity":{"description":"Affinity
    is a group of affinity scheduling rules for the typha pods.\nIf specified, this
    overrides any affinity that may be set on the typha Deployment.\nIf omitted, the
    typha Deployment will use its default value for affinity.\nIf used in conjunction
    with the deprecated TyphaAffinity, then this value takes precedence.\nWARNING:
    Please note that this field will override the default calico-typha Deployment
    affinity.","properties":{"nodeAffinity":{"description":"Describes node affinity
    scheduling rules for the pod.","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"description":"The
    scheduler will prefer to schedule pods to nodes that satisfy\nthe affinity expressions
    specified by this field, but it may choose\na node that violates one or more of
    the expressions. The node that is\nmost preferred is the one with the greatest
    sum of weights, i.e.\nfor each node that meets all of the scheduling requirements
    (resource\nrequest, requiredDuringScheduling affinity expressions, etc.),\ncompute
    a sum by iterating through the elements of this field and adding\n\"weight\" to
    the sum if the node matches the corresponding matchExpressions; the\nnode(s) with
    the highest sum are the most preferred.","items":{"description":"An empty preferred
    scheduling term matches all objects with implicit weight 0\n(i.e. it''s a no-op).
    A null preferred scheduling term matches no objects (i.e. is also a no-op).","properties":{"preference":{"description":"A
    node selector term, associated with the corresponding weight.","properties":{"matchExpressions":{"description":"A
    list of node selector requirements by node''s labels.","items":{"description":"A
    node selector requirement is a selector that contains values, a key, and an operator\nthat
    relates the key and values.","properties":{"key":{"description":"The label key
    that the selector applies to.","type":"string"},"operator":{"description":"Represents
    a key''s relationship to a set of values.\nValid operators are In, NotIn, Exists,
    DoesNotExist. Gt, and Lt.","type":"string"},"values":{"description":"An array
    of string values. If the operator is In or NotIn,\nthe values array must be non-empty.
    If the operator is Exists or DoesNotExist,\nthe values array must be empty. If
    the operator is Gt or Lt, the values\narray must have a single element, which
    will be interpreted as an integer.\nThis array is replaced during a strategic
    merge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchFields":{"description":"A
    list of node selector requirements by node''s fields.","items":{"description":"A
    node selector requirement is a selector that contains values, a key, and an operator\nthat
    relates the key and values.","properties":{"key":{"description":"The label key
    that the selector applies to.","type":"string"},"operator":{"description":"Represents
    a key''s relationship to a set of values.\nValid operators are In, NotIn, Exists,
    DoesNotExist. Gt, and Lt.","type":"string"},"values":{"description":"An array
    of string values. If the operator is In or NotIn,\nthe values array must be non-empty.
    If the operator is Exists or DoesNotExist,\nthe values array must be empty. If
    the operator is Gt or Lt, the values\narray must have a single element, which
    will be interpreted as an integer.\nThis array is replaced during a strategic
    merge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"}},"type":"object","x-kubernetes-map-type":"atomic"},"weight":{"description":"Weight
    associated with matching the corresponding nodeSelectorTerm, in the range 1-100.","format":"int32","type":"integer"}},"required":["preference","weight"],"type":"object"},"type":"array"},"requiredDuringSchedulingIgnoredDuringExecution":{"description":"If
    the affinity requirements specified by this field are not met at\nscheduling time,
    the pod will not be scheduled onto the node.\nIf the affinity requirements specified
    by this field cease to be met\nat some point during pod execution (e.g. due to
    an update), the system\nmay or may not try to eventually evict the pod from its
    node.","properties":{"nodeSelectorTerms":{"description":"Required. A list of node
    selector terms. The terms are ORed.","items":{"description":"A null or empty node
    selector term matches no objects. The requirements of\nthem are ANDed.\nThe TopologySelectorTerm
    type implements a subset of the NodeSelectorTerm.","properties":{"matchExpressions":{"description":"A
    list of node selector requirements by node''s labels.","items":{"description":"A
    node selector requirement is a selector that contains values, a key, and an operator\nthat
    relates the key and values.","properties":{"key":{"description":"The label key
    that the selector applies to.","type":"string"},"operator":{"description":"Represents
    a key''s relationship to a set of values.\nValid operators are In, NotIn, Exists,
    DoesNotExist. Gt, and Lt.","type":"string"},"values":{"description":"An array
    of string values. If the operator is In or NotIn,\nthe values array must be non-empty.
    If the operator is Exists or DoesNotExist,\nthe values array must be empty. If
    the operator is Gt or Lt, the values\narray must have a single element, which
    will be interpreted as an integer.\nThis array is replaced during a strategic
    merge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchFields":{"description":"A
    list of node selector requirements by node''s fields.","items":{"description":"A
    node selector requirement is a selector that contains values, a key, and an operator\nthat
    relates the key and values.","properties":{"key":{"description":"The label key
    that the selector applies to.","type":"string"},"operator":{"description":"Represents
    a key''s relationship to a set of values.\nValid operators are In, NotIn, Exists,
    DoesNotExist. Gt, and Lt.","type":"string"},"values":{"description":"An array
    of string values. If the operator is In or NotIn,\nthe values array must be non-empty.
    If the operator is Exists or DoesNotExist,\nthe values array must be empty. If
    the operator is Gt or Lt, the values\narray must have a single element, which
    will be interpreted as an integer.\nThis array is replaced during a strategic
    merge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"}},"type":"object","x-kubernetes-map-type":"atomic"},"type":"array"}},"required":["nodeSelectorTerms"],"type":"object","x-kubernetes-map-type":"atomic"}},"type":"object"},"podAffinity":{"description":"Describes
    pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone,
    etc. as some other pod(s)).","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"description":"The
    scheduler will prefer to schedule pods to nodes that satisfy\nthe affinity expressions
    specified by this field, but it may choose\na node that violates one or more of
    the expressions. The node that is\nmost preferred is the one with the greatest
    sum of weights, i.e.\nfor each node that meets all of the scheduling requirements
    (resource\nrequest, requiredDuringScheduling affinity expressions, etc.),\ncompute
    a sum by iterating through the elements of this field and adding\n\"weight\" to
    the sum if the node has pods which matches the corresponding podAffinityTerm;
    the\nnode(s) with the highest sum are the most preferred.","items":{"description":"The
    weights of all of the matched WeightedPodAffinityTerm fields are added per-node
    to find the most preferred node(s)","properties":{"podAffinityTerm":{"description":"Required.
    A pod affinity term, associated with the corresponding weight.","properties":{"labelSelector":{"description":"A
    label query over a set of resources, in this case pods.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaceSelector":{"description":"A
    label query over the set of namespaces that the term applies to.\nThe term is
    applied to the union of the namespaces selected by this field\nand the ones listed
    in the namespaces field.\nnull selector and null or empty namespaces list means
    \"this pod''s namespace\".\nAn empty selector ({}) matches all namespaces.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaces":{"description":"namespaces
    specifies a static list of namespace names that the term applies to.\nThe term
    is applied to the union of the namespaces listed in this field\nand the ones selected
    by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector
    means \"this pod''s namespace\".","items":{"type":"string"},"type":"array"},"topologyKey":{"description":"This
    pod should be co-located (affinity) or not co-located (anti-affinity) with the
    pods matching\nthe labelSelector in the specified namespaces, where co-located
    is defined as running on a node\nwhose value of the label with key topologyKey
    matches that of any node on which any of the\nselected pods is running.\nEmpty
    topologyKey is not allowed.","type":"string"}},"required":["topologyKey"],"type":"object"},"weight":{"description":"weight
    associated with matching the corresponding podAffinityTerm,\nin the range 1-100.","format":"int32","type":"integer"}},"required":["podAffinityTerm","weight"],"type":"object"},"type":"array"},"requiredDuringSchedulingIgnoredDuringExecution":{"description":"If
    the affinity requirements specified by this field are not met at\nscheduling time,
    the pod will not be scheduled onto the node.\nIf the affinity requirements specified
    by this field cease to be met\nat some point during pod execution (e.g. due to
    a pod label update), the\nsystem may or may not try to eventually evict the pod
    from its node.\nWhen there are multiple elements, the lists of nodes corresponding
    to each\npodAffinityTerm are intersected, i.e. all terms must be satisfied.","items":{"description":"Defines
    a set of pods (namely those matching the labelSelector\nrelative to the given
    namespace(s)) that this pod should be\nco-located (affinity) or not co-located
    (anti-affinity) with,\nwhere co-located is defined as running on a node whose
    value of\nthe label with key <topologyKey> matches that of any node on which\na
    pod of the set of pods is running","properties":{"labelSelector":{"description":"A
    label query over a set of resources, in this case pods.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaceSelector":{"description":"A
    label query over the set of namespaces that the term applies to.\nThe term is
    applied to the union of the namespaces selected by this field\nand the ones listed
    in the namespaces field.\nnull selector and null or empty namespaces list means
    \"this pod''s namespace\".\nAn empty selector ({}) matches all namespaces.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaces":{"description":"namespaces
    specifies a static list of namespace names that the term applies to.\nThe term
    is applied to the union of the namespaces listed in this field\nand the ones selected
    by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector
    means \"this pod''s namespace\".","items":{"type":"string"},"type":"array"},"topologyKey":{"description":"This
    pod should be co-located (affinity) or not co-located (anti-affinity) with the
    pods matching\nthe labelSelector in the specified namespaces, where co-located
    is defined as running on a node\nwhose value of the label with key topologyKey
    matches that of any node on which any of the\nselected pods is running.\nEmpty
    topologyKey is not allowed.","type":"string"}},"required":["topologyKey"],"type":"object"},"type":"array"}},"type":"object"},"podAntiAffinity":{"description":"Describes
    pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node,
    zone, etc. as some other pod(s)).","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"description":"The
    scheduler will prefer to schedule pods to nodes that satisfy\nthe anti-affinity
    expressions specified by this field, but it may choose\na node that violates one
    or more of the expressions. The node that is\nmost preferred is the one with the
    greatest sum of weights, i.e.\nfor each node that meets all of the scheduling
    requirements (resource\nrequest, requiredDuringScheduling anti-affinity expressions,
    etc.),\ncompute a sum by iterating through the elements of this field and adding\n\"weight\"
    to the sum if the node has pods which matches the corresponding podAffinityTerm;
    the\nnode(s) with the highest sum are the most preferred.","items":{"description":"The
    weights of all of the matched WeightedPodAffinityTerm fields are added per-node
    to find the most preferred node(s)","properties":{"podAffinityTerm":{"description":"Required.
    A pod affinity term, associated with the corresponding weight.","properties":{"labelSelector":{"description":"A
    label query over a set of resources, in this case pods.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaceSelector":{"description":"A
    label query over the set of namespaces that the term applies to.\nThe term is
    applied to the union of the namespaces selected by this field\nand the ones listed
    in the namespaces field.\nnull selector and null or empty namespaces list means
    \"this pod''s namespace\".\nAn empty selector ({}) matches all namespaces.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaces":{"description":"namespaces
    specifies a static list of namespace names that the term applies to.\nThe term
    is applied to the union of the namespaces listed in this field\nand the ones selected
    by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector
    means \"this pod''s namespace\".","items":{"type":"string"},"type":"array"},"topologyKey":{"description":"This
    pod should be co-located (affinity) or not co-located (anti-affinity) with the
    pods matching\nthe labelSelector in the specified namespaces, where co-located
    is defined as running on a node\nwhose value of the label with key topologyKey
    matches that of any node on which any of the\nselected pods is running.\nEmpty
    topologyKey is not allowed.","type":"string"}},"required":["topologyKey"],"type":"object"},"weight":{"description":"weight
    associated with matching the corresponding podAffinityTerm,\nin the range 1-100.","format":"int32","type":"integer"}},"required":["podAffinityTerm","weight"],"type":"object"},"type":"array"},"requiredDuringSchedulingIgnoredDuringExecution":{"description":"If
    the anti-affinity requirements specified by this field are not met at\nscheduling
    time, the pod will not be scheduled onto the node.\nIf the anti-affinity requirements
    specified by this field cease to be met\nat some point during pod execution (e.g.
    due to a pod label update), the\nsystem may or may not try to eventually evict
    the pod from its node.\nWhen there are multiple elements, the lists of nodes corresponding
    to each\npodAffinityTerm are intersected, i.e. all terms must be satisfied.","items":{"description":"Defines
    a set of pods (namely those matching the labelSelector\nrelative to the given
    namespace(s)) that this pod should be\nco-located (affinity) or not co-located
    (anti-affinity) with,\nwhere co-located is defined as running on a node whose
    value of\nthe label with key <topologyKey> matches that of any node on which\na
    pod of the set of pods is running","properties":{"labelSelector":{"description":"A
    label query over a set of resources, in this case pods.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaceSelector":{"description":"A
    label query over the set of namespaces that the term applies to.\nThe term is
    applied to the union of the namespaces selected by this field\nand the ones listed
    in the namespaces field.\nnull selector and null or empty namespaces list means
    \"this pod''s namespace\".\nAn empty selector ({}) matches all namespaces.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaces":{"description":"namespaces
    specifies a static list of namespace names that the term applies to.\nThe term
    is applied to the union of the namespaces listed in this field\nand the ones selected
    by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector
    means \"this pod''s namespace\".","items":{"type":"string"},"type":"array"},"topologyKey":{"description":"This
    pod should be co-located (affinity) or not co-located (anti-affinity) with the
    pods matching\nthe labelSelector in the specified namespaces, where co-located
    is defined as running on a node\nwhose value of the label with key topologyKey
    matches that of any node on which any of the\nselected pods is running.\nEmpty
    topologyKey is not allowed.","type":"string"}},"required":["topologyKey"],"type":"object"},"type":"array"}},"type":"object"}},"type":"object"},"containers":{"description":"Containers
    is a list of typha containers.\nIf specified, this overrides the specified typha
    Deployment containers.\nIf omitted, the typha Deployment will use its default
    values for its containers.","items":{"description":"TyphaDeploymentContainer is
    a typha Deployment container.","properties":{"name":{"description":"Name is an
    enum which identifies the typha Deployment container by name.\nSupported values
    are: calico-typha","enum":["calico-typha"],"type":"string"},"resources":{"description":"Resources
    allows customization of limits and requests for compute resources such as cpu
    and memory.\nIf specified, this overrides the named typha Deployment container''s
    resources.\nIf omitted, the typha Deployment will use its default value for this
    container''s resources.\nIf used in conjunction with the deprecated ComponentResources,
    then this value takes precedence.","properties":{"claims":{"description":"Claims
    lists the names of resources, defined in spec.resourceClaims,\nthat are used by
    this container.\nThis is an alpha field and requires enabling the\nDynamicResourceAllocation
    feature gate.\nThis field is immutable. It can only be set for containers.","items":{"description":"ResourceClaim
    references one entry in PodSpec.ResourceClaims.","properties":{"name":{"description":"Name
    must match the name of one entry in pod.spec.resourceClaims of\nthe Pod where
    this field is used. It makes that resource available\ninside a container.","type":"string"}},"required":["name"],"type":"object"},"type":"array","x-kubernetes-list-map-keys":["name"],"x-kubernetes-list-type":"map"},"limits":{"additionalProperties":{"anyOf":[{"type":"integer"},{"type":"string"}],"pattern":"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$","x-kubernetes-int-or-string":true},"description":"Limits
    describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/","type":"object"},"requests":{"additionalProperties":{"anyOf":[{"type":"integer"},{"type":"string"}],"pattern":"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$","x-kubernetes-int-or-string":true},"description":"Requests
    describes the minimum amount of compute resources required.\nIf Requests is omitted
    for a container, it defaults to Limits if that is explicitly specified,\notherwise
    to an implementation-defined value. Requests cannot exceed Limits.\nMore info:
    https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/","type":"object"}},"type":"object"}},"required":["name"],"type":"object"},"type":"array"},"initContainers":{"description":"InitContainers
    is a list of typha init containers.\nIf specified, this overrides the specified
    typha Deployment init containers.\nIf omitted, the typha Deployment will use its
    default values for its init containers.","items":{"description":"TyphaDeploymentInitContainer
    is a typha Deployment init container.","properties":{"name":{"description":"Name
    is an enum which identifies the typha Deployment init container by name.\nSupported
    values are: typha-certs-key-cert-provisioner","enum":["typha-certs-key-cert-provisioner"],"type":"string"},"resources":{"description":"Resources
    allows customization of limits and requests for compute resources such as cpu
    and memory.\nIf specified, this overrides the named typha Deployment init container''s
    resources.\nIf omitted, the typha Deployment will use its default value for this
    init container''s resources.\nIf used in conjunction with the deprecated ComponentResources,
    then this value takes precedence.","properties":{"claims":{"description":"Claims
    lists the names of resources, defined in spec.resourceClaims,\nthat are used by
    this container.\nThis is an alpha field and requires enabling the\nDynamicResourceAllocation
    feature gate.\nThis field is immutable. It can only be set for containers.","items":{"description":"ResourceClaim
    references one entry in PodSpec.ResourceClaims.","properties":{"name":{"description":"Name
    must match the name of one entry in pod.spec.resourceClaims of\nthe Pod where
    this field is used. It makes that resource available\ninside a container.","type":"string"}},"required":["name"],"type":"object"},"type":"array","x-kubernetes-list-map-keys":["name"],"x-kubernetes-list-type":"map"},"limits":{"additionalProperties":{"anyOf":[{"type":"integer"},{"type":"string"}],"pattern":"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$","x-kubernetes-int-or-string":true},"description":"Limits
    describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/","type":"object"},"requests":{"additionalProperties":{"anyOf":[{"type":"integer"},{"type":"string"}],"pattern":"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$","x-kubernetes-int-or-string":true},"description":"Requests
    describes the minimum amount of compute resources required.\nIf Requests is omitted
    for a container, it defaults to Limits if that is explicitly specified,\notherwise
    to an implementation-defined value. Requests cannot exceed Limits.\nMore info:
    https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/","type":"object"}},"type":"object"}},"required":["name"],"type":"object"},"type":"array"},"nodeSelector":{"additionalProperties":{"type":"string"},"description":"NodeSelector
    is the calico-typha pod''s scheduling constraints.\nIf specified, each of the
    key/value pairs are added to the calico-typha Deployment nodeSelector provided\nthe
    key does not already exist in the object''s nodeSelector.\nIf omitted, the calico-typha
    Deployment will use its default value for nodeSelector.\nWARNING: Please note
    that this field will modify the default calico-typha Deployment nodeSelector.","type":"object"},"terminationGracePeriodSeconds":{"description":"Optional
    duration in seconds the pod needs to terminate gracefully. May be decreased in
    delete request.\nValue must be non-negative integer. The value zero indicates
    stop immediately via\nthe kill signal (no opportunity to shut down).\nIf this
    value is nil, the default grace period will be used instead.\nThe grace period
    is the duration in seconds after the processes running in the pod are sent\na
    termination signal and the time when the processes are forcibly halted with a
    kill signal.\nSet this value longer than the expected cleanup time for your process.\nDefaults
    to 30 seconds.","format":"int64","type":"integer"},"tolerations":{"description":"Tolerations
    is the typha pod''s tolerations.\nIf specified, this overrides any tolerations
    that may be set on the typha Deployment.\nIf omitted, the typha Deployment will
    use its default value for tolerations.\nWARNING: Please note that this field will
    override the default calico-typha Deployment tolerations.","items":{"description":"The
    pod this Toleration is attached to tolerates any taint that matches\nthe triple
    <key,value,effect> using the matching operator <operator>.","properties":{"effect":{"description":"Effect
    indicates the taint effect to match. Empty means match all taint effects.\nWhen
    specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.","type":"string"},"key":{"description":"Key
    is the taint key that the toleration applies to. Empty means match all taint keys.\nIf
    the key is empty, operator must be Exists; this combination means to match all
    values and all keys.","type":"string"},"operator":{"description":"Operator represents
    a key''s relationship to the value.\nValid operators are Exists and Equal. Defaults
    to Equal.\nExists is equivalent to wildcard for value, so that a pod can\ntolerate
    all taints of a particular category.","type":"string"},"tolerationSeconds":{"description":"TolerationSeconds
    represents the period of time the toleration (which must be\nof effect NoExecute,
    otherwise this field is ignored) tolerates the taint. By default,\nit is not set,
    which means tolerate the taint forever (do not evict). Zero and\nnegative values
    will be treated as 0 (evict immediately) by the system.","format":"int64","type":"integer"},"value":{"description":"Value
    is the taint value the toleration matches to.\nIf the operator is Exists, the
    value should be empty, otherwise just a regular string.","type":"string"}},"type":"object"},"type":"array"},"topologySpreadConstraints":{"description":"TopologySpreadConstraints
    describes how a group of pods ought to spread across topology\ndomains. Scheduler
    will schedule pods in a way which abides by the constraints.\nAll topologySpreadConstraints
    are ANDed.","items":{"description":"TopologySpreadConstraint specifies how to
    spread matching pods among the given topology.","properties":{"labelSelector":{"description":"LabelSelector
    is used to find matching pods.\nPods that match this label selector are counted
    to determine the number of pods\nin their corresponding topology domain.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"matchLabelKeys":{"description":"MatchLabelKeys
    is a set of pod label keys to select the pods over which\nspreading will be calculated.
    The keys are used to lookup values from the\nincoming pod labels, those key-value
    labels are ANDed with labelSelector\nto select the group of existing pods over
    which spreading will be calculated\nfor the incoming pod. The same key is forbidden
    to exist in both MatchLabelKeys and LabelSelector.\nMatchLabelKeys cannot be set
    when LabelSelector isn''t set.\nKeys that don''t exist in the incoming pod labels
    will\nbe ignored. A null or empty list means only match against labelSelector.\nThis
    is a beta field and requires the MatchLabelKeysInPodTopologySpread feature gate
    to be enabled (enabled by default).","items":{"type":"string"},"type":"array","x-kubernetes-list-type":"atomic"},"maxSkew":{"description":"MaxSkew
    describes the degree to which pods may be unevenly distributed.\nWhen `whenUnsatisfiable=DoNotSchedule`,
    it is the maximum permitted difference\nbetween the number of matching pods in
    the target topology and the global minimum.\nThe global minimum is the minimum
    number of matching pods in an eligible domain\nor zero if the number of eligible
    domains is less than MinDomains.\nFor example, in a 3-zone cluster, MaxSkew is
    set to 1, and pods with the same\nlabelSelector spread as 2/2/1:\nIn this case,
    the global minimum is 1.\n| zone1 | zone2 | zone3 |\n|  P P  |  P P  |   P   |\n-
    if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 2/2/2;\nscheduling
    it onto zone1(zone2) would make the ActualSkew(3-1) on zone1(zone2)\nviolate MaxSkew(1).\n-
    if MaxSkew is 2, incoming pod can be scheduled onto any zone.\nWhen `whenUnsatisfiable=ScheduleAnyway`,
    it is used to give higher precedence\nto topologies that satisfy it.\nIt''s a
    required field. Default value is 1 and 0 is not allowed.","format":"int32","type":"integer"},"minDomains":{"description":"MinDomains
    indicates a minimum number of eligible domains.\nWhen the number of eligible domains
    with matching topology keys is less than minDomains,\nPod Topology Spread treats
    \"global minimum\" as 0, and then the calculation of Skew is performed.\nAnd when
    the number of eligible domains with matching topology keys equals or greater than
    minDomains,\nthis value has no effect on scheduling.\nAs a result, when the number
    of eligible domains is less than minDomains,\nscheduler won''t schedule more than
    maxSkew Pods to those domains.\nIf value is nil, the constraint behaves as if
    MinDomains is equal to 1.\nValid values are integers greater than 0.\nWhen value
    is not nil, WhenUnsatisfiable must be DoNotSchedule.\nFor example, in a 3-zone
    cluster, MaxSkew is set to 2, MinDomains is set to 5 and pods with the same\nlabelSelector
    spread as 2/2/2:\n| zone1 | zone2 | zone3 |\n|  P P  |  P P  |  P P  |\nThe number
    of domains is less than 5(MinDomains), so \"global minimum\" is treated as 0.\nIn
    this situation, new pod with the same labelSelector cannot be scheduled,\nbecause
    computed skew will be 3(3 - 0) if new Pod is scheduled to any of the three zones,\nit
    will violate MaxSkew.\nThis is a beta field and requires the MinDomainsInPodTopologySpread
    feature gate to be enabled (enabled by default).","format":"int32","type":"integer"},"nodeAffinityPolicy":{"description":"NodeAffinityPolicy
    indicates how we will treat Pod''s nodeAffinity/nodeSelector\nwhen calculating
    pod topology spread skew. Options are:\n- Honor: only nodes matching nodeAffinity/nodeSelector
    are included in the calculations.\n- Ignore: nodeAffinity/nodeSelector are ignored.
    All nodes are included in the calculations.\nIf this value is nil, the behavior
    is equivalent to the Honor policy.\nThis is a beta-level feature default enabled
    by the NodeInclusionPolicyInPodTopologySpread feature flag.","type":"string"},"nodeTaintsPolicy":{"description":"NodeTaintsPolicy
    indicates how we will treat node taints when calculating\npod topology spread
    skew. Options are:\n- Honor: nodes without taints, along with tainted nodes for
    which the incoming pod\nhas a toleration, are included.\n- Ignore: node taints
    are ignored. All nodes are included.\nIf this value is nil, the behavior is equivalent
    to the Ignore policy.\nThis is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread
    feature flag.","type":"string"},"topologyKey":{"description":"TopologyKey is the
    key of node labels. Nodes that have a label with this key\nand identical values
    are considered to be in the same topology.\nWe consider each <key, value> as a
    \"bucket\", and try to put balanced number\nof pods into each bucket.\nWe define
    a domain as a particular instance of a topology.\nAlso, we define an eligible
    domain as a domain whose nodes meet the requirements of\nnodeAffinityPolicy and
    nodeTaintsPolicy.\ne.g. If TopologyKey is \"kubernetes.io/hostname\", each Node
    is a domain of that topology.\nAnd, if TopologyKey is \"topology.kubernetes.io/zone\",
    each zone is a domain of that topology.\nIt''s a required field.","type":"string"},"whenUnsatisfiable":{"description":"WhenUnsatisfiable
    indicates how to deal with a pod if it doesn''t satisfy\nthe spread constraint.\n-
    DoNotSchedule (default) tells the scheduler not to schedule it.\n- ScheduleAnyway
    tells the scheduler to schedule the pod in any location,\n  but giving higher
    precedence to topologies that would help reduce the\n  skew.\nA constraint is
    considered \"Unsatisfiable\" for an incoming pod\nif and only if every possible
    node assignment for that pod would violate\n\"MaxSkew\" on some topology.\nFor
    example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same\nlabelSelector
    spread as 3/1/1:\n| zone1 | zone2 | zone3 |\n| P P P |   P   |   P   |\nIf WhenUnsatisfiable
    is set to DoNotSchedule, incoming pod can only be scheduled\nto zone2(zone3) to
    become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies\nMaxSkew(1).
    In other words, the cluster can still be imbalanced, but scheduler\nwon''t make
    it *more* imbalanced.\nIt''s a required field.","type":"string"}},"required":["maxSkew","topologyKey","whenUnsatisfiable"],"type":"object"},"type":"array"}},"type":"object"}},"type":"object"}},"type":"object"}},"type":"object"},"typhaMetricsPort":{"description":"TyphaMetricsPort
    specifies which port calico/typha serves prometheus metrics on. By default, metrics
    are not enabled.","format":"int32","type":"integer"},"variant":{"description":"Variant
    is the product to install - one of Calico or TigeraSecureEnterprise\nDefault:
    Calico","enum":["Calico","TigeraSecureEnterprise"],"type":"string"},"windowsNodes":{"description":"Windows
    Configuration","properties":{"cniBinDir":{"description":"CNIBinDir is the path
    to the CNI binaries directory on Windows, it must match what is used as ''bin_dir''
    under\n[plugins]\n  [plugins.\"io.containerd.grpc.v1.cri\"]\n    [plugins.\"io.containerd.grpc.v1.cri\".cni]\non
    the containerd ''config.toml'' file on the Windows nodes.","type":"string"},"cniConfigDir":{"description":"CNIConfigDir
    is the path to the CNI configuration directory on Windows, it must match what
    is used as ''conf_dir'' under\n[plugins]\n  [plugins.\"io.containerd.grpc.v1.cri\"]\n    [plugins.\"io.containerd.grpc.v1.cri\".cni]\non
    the containerd ''config.toml'' file on the Windows nodes.","type":"string"},"cniLogDir":{"description":"CNILogDir
    is the path to the Calico CNI logs directory on Windows.","type":"string"},"vxlanAdapter":{"description":"VXLANAdapter
    is the Network Adapter used for VXLAN, leave blank for primary NIC","type":"string"},"vxlanMACPrefix":{"description":"VXLANMACPrefix
    is the prefix used when generating MAC addresses for virtual NICs","pattern":"^[0-9A-Fa-f]{2}-[0-9A-Fa-f]{2}$","type":"string"}},"type":"object"}},"type":"object"},"status":{"description":"Most
    recently observed state for the Calico or Calico Enterprise installation.","properties":{"calicoVersion":{"description":"CalicoVersion
    shows the current running version of calico.\nCalicoVersion along with Variant
    is needed to know the exact\nversion deployed.","type":"string"},"computed":{"description":"Computed
    is the final installation including overlaid resources.","properties":{"azure":{"description":"Azure
    is used to configure azure provider specific options.","properties":{"policyMode":{"default":"Default","description":"PolicyMode
    determines whether the \"control-plane\" label is applied to namespaces. It offers
    two options: Default and Manual.\nThe Default option adds the \"control-plane\"
    label to the required namespaces.\nThe Manual option does not apply the \"control-plane\"
    label to any namespace.\nDefault: Default","enum":["Default","Manual"],"type":"string"}},"type":"object"},"calicoKubeControllersDeployment":{"description":"CalicoKubeControllersDeployment
    configures the calico-kube-controllers Deployment. If used in\nconjunction with
    the deprecated ComponentResources, then these overrides take precedence.","properties":{"metadata":{"description":"Metadata
    is a subset of a Kubernetes object''s metadata that is added to the Deployment.","properties":{"annotations":{"additionalProperties":{"type":"string"},"description":"Annotations
    is a map of arbitrary non-identifying metadata. Each of these\nkey/value pairs
    are added to the object''s annotations provided the key does not\nalready exist
    in the object''s annotations.","type":"object"},"labels":{"additionalProperties":{"type":"string"},"description":"Labels
    is a map of string keys and values that may match replicaset and\nservice selectors.
    Each of these key/value pairs are added to the\nobject''s labels provided the
    key does not already exist in the object''s labels.","type":"object"}},"type":"object"},"spec":{"description":"Spec
    is the specification of the calico-kube-controllers Deployment.","properties":{"minReadySeconds":{"description":"MinReadySeconds
    is the minimum number of seconds for which a newly created Deployment pod should\nbe
    ready without any of its container crashing, for it to be considered available.\nIf
    specified, this overrides any minReadySeconds value that may be set on the calico-kube-controllers
    Deployment.\nIf omitted, the calico-kube-controllers Deployment will use its default
    value for minReadySeconds.","format":"int32","maximum":2147483647,"minimum":0,"type":"integer"},"template":{"description":"Template
    describes the calico-kube-controllers Deployment pod that will be created.","properties":{"metadata":{"description":"Metadata
    is a subset of a Kubernetes object''s metadata that is added to\nthe pod''s metadata.","properties":{"annotations":{"additionalProperties":{"type":"string"},"description":"Annotations
    is a map of arbitrary non-identifying metadata. Each of these\nkey/value pairs
    are added to the object''s annotations provided the key does not\nalready exist
    in the object''s annotations.","type":"object"},"labels":{"additionalProperties":{"type":"string"},"description":"Labels
    is a map of string keys and values that may match replicaset and\nservice selectors.
    Each of these key/value pairs are added to the\nobject''s labels provided the
    key does not already exist in the object''s labels.","type":"object"}},"type":"object"},"spec":{"description":"Spec
    is the calico-kube-controllers Deployment''s PodSpec.","properties":{"affinity":{"description":"Affinity
    is a group of affinity scheduling rules for the calico-kube-controllers pods.\nIf
    specified, this overrides any affinity that may be set on the calico-kube-controllers
    Deployment.\nIf omitted, the calico-kube-controllers Deployment will use its default
    value for affinity.\nWARNING: Please note that this field will override the default
    calico-kube-controllers Deployment affinity.","properties":{"nodeAffinity":{"description":"Describes
    node affinity scheduling rules for the pod.","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"description":"The
    scheduler will prefer to schedule pods to nodes that satisfy\nthe affinity expressions
    specified by this field, but it may choose\na node that violates one or more of
    the expressions. The node that is\nmost preferred is the one with the greatest
    sum of weights, i.e.\nfor each node that meets all of the scheduling requirements
    (resource\nrequest, requiredDuringScheduling affinity expressions, etc.),\ncompute
    a sum by iterating through the elements of this field and adding\n\"weight\" to
    the sum if the node matches the corresponding matchExpressions; the\nnode(s) with
    the highest sum are the most preferred.","items":{"description":"An empty preferred
    scheduling term matches all objects with implicit weight 0\n(i.e. it''s a no-op).
    A null preferred scheduling term matches no objects (i.e. is also a no-op).","properties":{"preference":{"description":"A
    node selector term, associated with the corresponding weight.","properties":{"matchExpressions":{"description":"A
    list of node selector requirements by node''s labels.","items":{"description":"A
    node selector requirement is a selector that contains values, a key, and an operator\nthat
    relates the key and values.","properties":{"key":{"description":"The label key
    that the selector applies to.","type":"string"},"operator":{"description":"Represents
    a key''s relationship to a set of values.\nValid operators are In, NotIn, Exists,
    DoesNotExist. Gt, and Lt.","type":"string"},"values":{"description":"An array
    of string values. If the operator is In or NotIn,\nthe values array must be non-empty.
    If the operator is Exists or DoesNotExist,\nthe values array must be empty. If
    the operator is Gt or Lt, the values\narray must have a single element, which
    will be interpreted as an integer.\nThis array is replaced during a strategic
    merge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchFields":{"description":"A
    list of node selector requirements by node''s fields.","items":{"description":"A
    node selector requirement is a selector that contains values, a key, and an operator\nthat
    relates the key and values.","properties":{"key":{"description":"The label key
    that the selector applies to.","type":"string"},"operator":{"description":"Represents
    a key''s relationship to a set of values.\nValid operators are In, NotIn, Exists,
    DoesNotExist. Gt, and Lt.","type":"string"},"values":{"description":"An array
    of string values. If the operator is In or NotIn,\nthe values array must be non-empty.
    If the operator is Exists or DoesNotExist,\nthe values array must be empty. If
    the operator is Gt or Lt, the values\narray must have a single element, which
    will be interpreted as an integer.\nThis array is replaced during a strategic
    merge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"}},"type":"object","x-kubernetes-map-type":"atomic"},"weight":{"description":"Weight
    associated with matching the corresponding nodeSelectorTerm, in the range 1-100.","format":"int32","type":"integer"}},"required":["preference","weight"],"type":"object"},"type":"array"},"requiredDuringSchedulingIgnoredDuringExecution":{"description":"If
    the affinity requirements specified by this field are not met at\nscheduling time,
    the pod will not be scheduled onto the node.\nIf the affinity requirements specified
    by this field cease to be met\nat some point during pod execution (e.g. due to
    an update), the system\nmay or may not try to eventually evict the pod from its
    node.","properties":{"nodeSelectorTerms":{"description":"Required. A list of node
    selector terms. The terms are ORed.","items":{"description":"A null or empty node
    selector term matches no objects. The requirements of\nthem are ANDed.\nThe TopologySelectorTerm
    type implements a subset of the NodeSelectorTerm.","properties":{"matchExpressions":{"description":"A
    list of node selector requirements by node''s labels.","items":{"description":"A
    node selector requirement is a selector that contains values, a key, and an operator\nthat
    relates the key and values.","properties":{"key":{"description":"The label key
    that the selector applies to.","type":"string"},"operator":{"description":"Represents
    a key''s relationship to a set of values.\nValid operators are In, NotIn, Exists,
    DoesNotExist. Gt, and Lt.","type":"string"},"values":{"description":"An array
    of string values. If the operator is In or NotIn,\nthe values array must be non-empty.
    If the operator is Exists or DoesNotExist,\nthe values array must be empty. If
    the operator is Gt or Lt, the values\narray must have a single element, which
    will be interpreted as an integer.\nThis array is replaced during a strategic
    merge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchFields":{"description":"A
    list of node selector requirements by node''s fields.","items":{"description":"A
    node selector requirement is a selector that contains values, a key, and an operator\nthat
    relates the key and values.","properties":{"key":{"description":"The label key
    that the selector applies to.","type":"string"},"operator":{"description":"Represents
    a key''s relationship to a set of values.\nValid operators are In, NotIn, Exists,
    DoesNotExist. Gt, and Lt.","type":"string"},"values":{"description":"An array
    of string values. If the operator is In or NotIn,\nthe values array must be non-empty.
    If the operator is Exists or DoesNotExist,\nthe values array must be empty. If
    the operator is Gt or Lt, the values\narray must have a single element, which
    will be interpreted as an integer.\nThis array is replaced during a strategic
    merge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"}},"type":"object","x-kubernetes-map-type":"atomic"},"type":"array"}},"required":["nodeSelectorTerms"],"type":"object","x-kubernetes-map-type":"atomic"}},"type":"object"},"podAffinity":{"description":"Describes
    pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone,
    etc. as some other pod(s)).","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"description":"The
    scheduler will prefer to schedule pods to nodes that satisfy\nthe affinity expressions
    specified by this field, but it may choose\na node that violates one or more of
    the expressions. The node that is\nmost preferred is the one with the greatest
    sum of weights, i.e.\nfor each node that meets all of the scheduling requirements
    (resource\nrequest, requiredDuringScheduling affinity expressions, etc.),\ncompute
    a sum by iterating through the elements of this field and adding\n\"weight\" to
    the sum if the node has pods which matches the corresponding podAffinityTerm;
    the\nnode(s) with the highest sum are the most preferred.","items":{"description":"The
    weights of all of the matched WeightedPodAffinityTerm fields are added per-node
    to find the most preferred node(s)","properties":{"podAffinityTerm":{"description":"Required.
    A pod affinity term, associated with the corresponding weight.","properties":{"labelSelector":{"description":"A
    label query over a set of resources, in this case pods.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaceSelector":{"description":"A
    label query over the set of namespaces that the term applies to.\nThe term is
    applied to the union of the namespaces selected by this field\nand the ones listed
    in the namespaces field.\nnull selector and null or empty namespaces list means
    \"this pod''s namespace\".\nAn empty selector ({}) matches all namespaces.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaces":{"description":"namespaces
    specifies a static list of namespace names that the term applies to.\nThe term
    is applied to the union of the namespaces listed in this field\nand the ones selected
    by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector
    means \"this pod''s namespace\".","items":{"type":"string"},"type":"array"},"topologyKey":{"description":"This
    pod should be co-located (affinity) or not co-located (anti-affinity) with the
    pods matching\nthe labelSelector in the specified namespaces, where co-located
    is defined as running on a node\nwhose value of the label with key topologyKey
    matches that of any node on which any of the\nselected pods is running.\nEmpty
    topologyKey is not allowed.","type":"string"}},"required":["topologyKey"],"type":"object"},"weight":{"description":"weight
    associated with matching the corresponding podAffinityTerm,\nin the range 1-100.","format":"int32","type":"integer"}},"required":["podAffinityTerm","weight"],"type":"object"},"type":"array"},"requiredDuringSchedulingIgnoredDuringExecution":{"description":"If
    the affinity requirements specified by this field are not met at\nscheduling time,
    the pod will not be scheduled onto the node.\nIf the affinity requirements specified
    by this field cease to be met\nat some point during pod execution (e.g. due to
    a pod label update), the\nsystem may or may not try to eventually evict the pod
    from its node.\nWhen there are multiple elements, the lists of nodes corresponding
    to each\npodAffinityTerm are intersected, i.e. all terms must be satisfied.","items":{"description":"Defines
    a set of pods (namely those matching the labelSelector\nrelative to the given
    namespace(s)) that this pod should be\nco-located (affinity) or not co-located
    (anti-affinity) with,\nwhere co-located is defined as running on a node whose
    value of\nthe label with key <topologyKey> matches that of any node on which\na
    pod of the set of pods is running","properties":{"labelSelector":{"description":"A
    label query over a set of resources, in this case pods.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaceSelector":{"description":"A
    label query over the set of namespaces that the term applies to.\nThe term is
    applied to the union of the namespaces selected by this field\nand the ones listed
    in the namespaces field.\nnull selector and null or empty namespaces list means
    \"this pod''s namespace\".\nAn empty selector ({}) matches all namespaces.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaces":{"description":"namespaces
    specifies a static list of namespace names that the term applies to.\nThe term
    is applied to the union of the namespaces listed in this field\nand the ones selected
    by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector
    means \"this pod''s namespace\".","items":{"type":"string"},"type":"array"},"topologyKey":{"description":"This
    pod should be co-located (affinity) or not co-located (anti-affinity) with the
    pods matching\nthe labelSelector in the specified namespaces, where co-located
    is defined as running on a node\nwhose value of the label with key topologyKey
    matches that of any node on which any of the\nselected pods is running.\nEmpty
    topologyKey is not allowed.","type":"string"}},"required":["topologyKey"],"type":"object"},"type":"array"}},"type":"object"},"podAntiAffinity":{"description":"Describes
    pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node,
    zone, etc. as some other pod(s)).","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"description":"The
    scheduler will prefer to schedule pods to nodes that satisfy\nthe anti-affinity
    expressions specified by this field, but it may choose\na node that violates one
    or more of the expressions. The node that is\nmost preferred is the one with the
    greatest sum of weights, i.e.\nfor each node that meets all of the scheduling
    requirements (resource\nrequest, requiredDuringScheduling anti-affinity expressions,
    etc.),\ncompute a sum by iterating through the elements of this field and adding\n\"weight\"
    to the sum if the node has pods which matches the corresponding podAffinityTerm;
    the\nnode(s) with the highest sum are the most preferred.","items":{"description":"The
    weights of all of the matched WeightedPodAffinityTerm fields are added per-node
    to find the most preferred node(s)","properties":{"podAffinityTerm":{"description":"Required.
    A pod affinity term, associated with the corresponding weight.","properties":{"labelSelector":{"description":"A
    label query over a set of resources, in this case pods.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaceSelector":{"description":"A
    label query over the set of namespaces that the term applies to.\nThe term is
    applied to the union of the namespaces selected by this field\nand the ones listed
    in the namespaces field.\nnull selector and null or empty namespaces list means
    \"this pod''s namespace\".\nAn empty selector ({}) matches all namespaces.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaces":{"description":"namespaces
    specifies a static list of namespace names that the term applies to.\nThe term
    is applied to the union of the namespaces listed in this field\nand the ones selected
    by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector
    means \"this pod''s namespace\".","items":{"type":"string"},"type":"array"},"topologyKey":{"description":"This
    pod should be co-located (affinity) or not co-located (anti-affinity) with the
    pods matching\nthe labelSelector in the specified namespaces, where co-located
    is defined as running on a node\nwhose value of the label with key topologyKey
    matches that of any node on which any of the\nselected pods is running.\nEmpty
    topologyKey is not allowed.","type":"string"}},"required":["topologyKey"],"type":"object"},"weight":{"description":"weight
    associated with matching the corresponding podAffinityTerm,\nin the range 1-100.","format":"int32","type":"integer"}},"required":["podAffinityTerm","weight"],"type":"object"},"type":"array"},"requiredDuringSchedulingIgnoredDuringExecution":{"description":"If
    the anti-affinity requirements specified by this field are not met at\nscheduling
    time, the pod will not be scheduled onto the node.\nIf the anti-affinity requirements
    specified by this field cease to be met\nat some point during pod execution (e.g.
    due to a pod label update), the\nsystem may or may not try to eventually evict
    the pod from its node.\nWhen there are multiple elements, the lists of nodes corresponding
    to each\npodAffinityTerm are intersected, i.e. all terms must be satisfied.","items":{"description":"Defines
    a set of pods (namely those matching the labelSelector\nrelative to the given
    namespace(s)) that this pod should be\nco-located (affinity) or not co-located
    (anti-affinity) with,\nwhere co-located is defined as running on a node whose
    value of\nthe label with key <topologyKey> matches that of any node on which\na
    pod of the set of pods is running","properties":{"labelSelector":{"description":"A
    label query over a set of resources, in this case pods.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaceSelector":{"description":"A
    label query over the set of namespaces that the term applies to.\nThe term is
    applied to the union of the namespaces selected by this field\nand the ones listed
    in the namespaces field.\nnull selector and null or empty namespaces list means
    \"this pod''s namespace\".\nAn empty selector ({}) matches all namespaces.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaces":{"description":"namespaces
    specifies a static list of namespace names that the term applies to.\nThe term
    is applied to the union of the namespaces listed in this field\nand the ones selected
    by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector
    means \"this pod''s namespace\".","items":{"type":"string"},"type":"array"},"topologyKey":{"description":"This
    pod should be co-located (affinity) or not co-located (anti-affinity) with the
    pods matching\nthe labelSelector in the specified namespaces, where co-located
    is defined as running on a node\nwhose value of the label with key topologyKey
    matches that of any node on which any of the\nselected pods is running.\nEmpty
    topologyKey is not allowed.","type":"string"}},"required":["topologyKey"],"type":"object"},"type":"array"}},"type":"object"}},"type":"object"},"containers":{"description":"Containers
    is a list of calico-kube-controllers containers.\nIf specified, this overrides
    the specified calico-kube-controllers Deployment containers.\nIf omitted, the
    calico-kube-controllers Deployment will use its default values for its containers.","items":{"description":"CalicoKubeControllersDeploymentContainer
    is a calico-kube-controllers Deployment container.","properties":{"name":{"description":"Name
    is an enum which identifies the calico-kube-controllers Deployment container by
    name.\nSupported values are: calico-kube-controllers, es-calico-kube-controllers","enum":["calico-kube-controllers","es-calico-kube-controllers"],"type":"string"},"resources":{"description":"Resources
    allows customization of limits and requests for compute resources such as cpu
    and memory.\nIf specified, this overrides the named calico-kube-controllers Deployment
    container''s resources.\nIf omitted, the calico-kube-controllers Deployment will
    use its default value for this container''s resources.\nIf used in conjunction
    with the deprecated ComponentResources, then this value takes precedence.","properties":{"claims":{"description":"Claims
    lists the names of resources, defined in spec.resourceClaims,\nthat are used by
    this container.\nThis is an alpha field and requires enabling the\nDynamicResourceAllocation
    feature gate.\nThis field is immutable. It can only be set for containers.","items":{"description":"ResourceClaim
    references one entry in PodSpec.ResourceClaims.","properties":{"name":{"description":"Name
    must match the name of one entry in pod.spec.resourceClaims of\nthe Pod where
    this field is used. It makes that resource available\ninside a container.","type":"string"}},"required":["name"],"type":"object"},"type":"array","x-kubernetes-list-map-keys":["name"],"x-kubernetes-list-type":"map"},"limits":{"additionalProperties":{"anyOf":[{"type":"integer"},{"type":"string"}],"pattern":"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$","x-kubernetes-int-or-string":true},"description":"Limits
    describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/","type":"object"},"requests":{"additionalProperties":{"anyOf":[{"type":"integer"},{"type":"string"}],"pattern":"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$","x-kubernetes-int-or-string":true},"description":"Requests
    describes the minimum amount of compute resources required.\nIf Requests is omitted
    for a container, it defaults to Limits if that is explicitly specified,\notherwise
    to an implementation-defined value. Requests cannot exceed Limits.\nMore info:
    https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/","type":"object"}},"type":"object"}},"required":["name"],"type":"object"},"type":"array"},"nodeSelector":{"additionalProperties":{"type":"string"},"description":"NodeSelector
    is the calico-kube-controllers pod''s scheduling constraints.\nIf specified, each
    of the key/value pairs are added to the calico-kube-controllers Deployment nodeSelector
    provided\nthe key does not already exist in the object''s nodeSelector.\nIf used
    in conjunction with ControlPlaneNodeSelector, that nodeSelector is set on the
    calico-kube-controllers Deployment\nand each of this field''s key/value pairs
    are added to the calico-kube-controllers Deployment nodeSelector provided\nthe
    key does not already exist in the object''s nodeSelector.\nIf omitted, the calico-kube-controllers
    Deployment will use its default value for nodeSelector.\nWARNING: Please note
    that this field will modify the default calico-kube-controllers Deployment nodeSelector.","type":"object"},"tolerations":{"description":"Tolerations
    is the calico-kube-controllers pod''s tolerations.\nIf specified, this overrides
    any tolerations that may be set on the calico-kube-controllers Deployment.\nIf
    omitted, the calico-kube-controllers Deployment will use its default value for
    tolerations.\nWARNING: Please note that this field will override the default calico-kube-controllers
    Deployment tolerations.","items":{"description":"The pod this Toleration is attached
    to tolerates any taint that matches\nthe triple <key,value,effect> using the matching
    operator <operator>.","properties":{"effect":{"description":"Effect indicates
    the taint effect to match. Empty means match all taint effects.\nWhen specified,
    allowed values are NoSchedule, PreferNoSchedule and NoExecute.","type":"string"},"key":{"description":"Key
    is the taint key that the toleration applies to. Empty means match all taint keys.\nIf
    the key is empty, operator must be Exists; this combination means to match all
    values and all keys.","type":"string"},"operator":{"description":"Operator represents
    a key''s relationship to the value.\nValid operators are Exists and Equal. Defaults
    to Equal.\nExists is equivalent to wildcard for value, so that a pod can\ntolerate
    all taints of a particular category.","type":"string"},"tolerationSeconds":{"description":"TolerationSeconds
    represents the period of time the toleration (which must be\nof effect NoExecute,
    otherwise this field is ignored) tolerates the taint. By default,\nit is not set,
    which means tolerate the taint forever (do not evict). Zero and\nnegative values
    will be treated as 0 (evict immediately) by the system.","format":"int64","type":"integer"},"value":{"description":"Value
    is the taint value the toleration matches to.\nIf the operator is Exists, the
    value should be empty, otherwise just a regular string.","type":"string"}},"type":"object"},"type":"array"}},"type":"object"}},"type":"object"}},"type":"object"}},"type":"object"},"calicoNetwork":{"description":"CalicoNetwork
    specifies networking configuration options for Calico.","properties":{"bgp":{"description":"BGP
    configures whether or not to enable Calico''s BGP capabilities.","enum":["Enabled","Disabled"],"type":"string"},"containerIPForwarding":{"description":"ContainerIPForwarding
    configures whether ip forwarding will be enabled for containers in the CNI configuration.\nDefault:
    Disabled","enum":["Enabled","Disabled"],"type":"string"},"hostPorts":{"description":"HostPorts
    configures whether or not Calico will support Kubernetes HostPorts. Valid only
    when using the Calico CNI plugin.\nDefault: Enabled","enum":["Enabled","Disabled"],"type":"string"},"ipPools":{"description":"IPPools
    contains a list of IP pools to manage. If nil, a single IP pool\nwill be defaulted.
    If an empty list is provided, the operator will not create any IP pools and will
    instead\nwait for IP pools to be created out-of-band.\nIP pools in this list will
    be reconciled by the operator and should not be modified out-of-band.","items":{"properties":{"allowedUses":{"description":"AllowedUse
    controls what the IP pool will be used for.  If not specified or empty, defaults
    to\n[\"Tunnel\", \"Workload\"] for back-compatibility","items":{"type":"string"},"type":"array"},"blockSize":{"description":"BlockSize
    specifies the CIDR prefex length to use when allocating per-node IP blocks from\nthe
    main IP pool CIDR.\nDefault: 26 (IPv4), 122 (IPv6)","format":"int32","type":"integer"},"cidr":{"description":"CIDR
    contains the address range for the IP Pool in classless inter-domain routing format.","type":"string"},"disableBGPExport":{"default":false,"description":"DisableBGPExport
    specifies whether routes from this IP pool''s CIDR are exported over BGP.\nDefault:
    false","type":"boolean"},"disableNewAllocations":{"description":"DisableNewAllocations
    specifies whether or not new IP allocations are allowed from this pool.\nThis
    is useful when you want to prevent new pods from receiving IP addresses from this
    pool, without\nimpacting any existing pods that have already been assigned addresses
    from this pool.","type":"boolean"},"encapsulation":{"description":"Encapsulation
    specifies the encapsulation type that will be used with\nthe IP Pool.\nDefault:
    IPIP","enum":["IPIPCrossSubnet","IPIP","VXLAN","VXLANCrossSubnet","None"],"type":"string"},"name":{"description":"Name
    is the name of the IP pool. If omitted, this will be generated.","type":"string"},"natOutgoing":{"description":"NATOutgoing
    specifies if NAT will be enabled or disabled for outgoing traffic.\nDefault: Enabled","enum":["Enabled","Disabled"],"type":"string"},"nodeSelector":{"description":"NodeSelector
    specifies the node selector that will be set for the IP Pool.\nDefault: ''all()''","type":"string"}},"required":["cidr"],"type":"object"},"maxItems":25,"type":"array"},"linuxDataplane":{"description":"LinuxDataplane
    is used to select the dataplane used for Linux nodes. In particular, it\ncauses
    the operator to add required mounts and environment variables for the particular
    dataplane.\nIf not specified, iptables mode is used.\nDefault: Iptables","enum":["Iptables","BPF","VPP","Nftables"],"type":"string"},"linuxPolicySetupTimeoutSeconds":{"description":"LinuxPolicySetupTimeoutSeconds
    delays new pods from running containers\nuntil their policy has been programmed
    in the dataplane.\nThe specified delay defines the maximum amount of time\nthat
    the Calico CNI plugin will wait for policy to be programmed.\nOnly applies to
    pods created on Linux nodes.\n* A value of 0 disables pod startup delays.\nDefault:
    0","format":"int32","type":"integer"},"mtu":{"description":"MTU specifies the
    maximum transmission unit to use on the pod network.\nIf not specified, Calico
    will perform MTU auto-detection based on the cluster network.","format":"int32","type":"integer"},"multiInterfaceMode":{"description":"MultiInterfaceMode
    configures what will configure multiple interface per pod. Only valid for Calico
    Enterprise installations\nusing the Calico CNI plugin.\nDefault: None","enum":["None","Multus"],"type":"string"},"nodeAddressAutodetectionV4":{"description":"NodeAddressAutodetectionV4
    specifies an approach to automatically detect node IPv4 addresses. If not specified,\nwill
    use default auto-detection settings to acquire an IPv4 address for each node.","properties":{"canReach":{"description":"CanReach
    enables IP auto-detection based on which source address on the node is used to
    reach the\nspecified IP or domain.","type":"string"},"cidrs":{"description":"CIDRS
    enables IP auto-detection based on which addresses on the nodes are within\none
    of the provided CIDRs.","items":{"type":"string"},"type":"array"},"firstFound":{"description":"FirstFound
    uses default interface matching parameters to select an interface, performing
    best-effort\nfiltering based on well-known interface names.","type":"boolean"},"interface":{"description":"Interface
    enables IP auto-detection based on interfaces that match the given regex.","type":"string"},"kubernetes":{"description":"Kubernetes
    configures Calico to detect node addresses based on the Kubernetes API.","enum":["NodeInternalIP"],"type":"string"},"skipInterface":{"description":"SkipInterface
    enables IP auto-detection based on interfaces that do not match\nthe given regex.","type":"string"}},"type":"object"},"nodeAddressAutodetectionV6":{"description":"NodeAddressAutodetectionV6
    specifies an approach to automatically detect node IPv6 addresses. If not specified,\nIPv6
    addresses will not be auto-detected.","properties":{"canReach":{"description":"CanReach
    enables IP auto-detection based on which source address on the node is used to
    reach the\nspecified IP or domain.","type":"string"},"cidrs":{"description":"CIDRS
    enables IP auto-detection based on which addresses on the nodes are within\none
    of the provided CIDRs.","items":{"type":"string"},"type":"array"},"firstFound":{"description":"FirstFound
    uses default interface matching parameters to select an interface, performing
    best-effort\nfiltering based on well-known interface names.","type":"boolean"},"interface":{"description":"Interface
    enables IP auto-detection based on interfaces that match the given regex.","type":"string"},"kubernetes":{"description":"Kubernetes
    configures Calico to detect node addresses based on the Kubernetes API.","enum":["NodeInternalIP"],"type":"string"},"skipInterface":{"description":"SkipInterface
    enables IP auto-detection based on interfaces that do not match\nthe given regex.","type":"string"}},"type":"object"},"sysctl":{"description":"Sysctl
    configures sysctl parameters for tuning plugin","items":{"properties":{"key":{"enum":["net.ipv4.tcp_keepalive_intvl","net.ipv4.tcp_keepalive_probes","net.ipv4.tcp_keepalive_time"],"type":"string"},"value":{"type":"string"}},"required":["key","value"],"type":"object"},"type":"array"},"windowsDataplane":{"description":"WindowsDataplane
    is used to select the dataplane used for Windows nodes. In particular, it\ncauses
    the operator to add required mounts and environment variables for the particular
    dataplane.\nIf not specified, it is disabled and the operator will not render
    the Calico Windows nodes daemonset.\nDefault: Disabled","enum":["HNS","Disabled"],"type":"string"}},"type":"object"},"calicoNodeDaemonSet":{"description":"CalicoNodeDaemonSet
    configures the calico-node DaemonSet. If used in\nconjunction with the deprecated
    ComponentResources, then these overrides take precedence.","properties":{"metadata":{"description":"Metadata
    is a subset of a Kubernetes object''s metadata that is added to the DaemonSet.","properties":{"annotations":{"additionalProperties":{"type":"string"},"description":"Annotations
    is a map of arbitrary non-identifying metadata. Each of these\nkey/value pairs
    are added to the object''s annotations provided the key does not\nalready exist
    in the object''s annotations.","type":"object"},"labels":{"additionalProperties":{"type":"string"},"description":"Labels
    is a map of string keys and values that may match replicaset and\nservice selectors.
    Each of these key/value pairs are added to the\nobject''s labels provided the
    key does not already exist in the object''s labels.","type":"object"}},"type":"object"},"spec":{"description":"Spec
    is the specification of the calico-node DaemonSet.","properties":{"minReadySeconds":{"description":"MinReadySeconds
    is the minimum number of seconds for which a newly created DaemonSet pod should\nbe
    ready without any of its container crashing, for it to be considered available.\nIf
    specified, this overrides any minReadySeconds value that may be set on the calico-node
    DaemonSet.\nIf omitted, the calico-node DaemonSet will use its default value for
    minReadySeconds.","format":"int32","maximum":2147483647,"minimum":0,"type":"integer"},"template":{"description":"Template
    describes the calico-node DaemonSet pod that will be created.","properties":{"metadata":{"description":"Metadata
    is a subset of a Kubernetes object''s metadata that is added to\nthe pod''s metadata.","properties":{"annotations":{"additionalProperties":{"type":"string"},"description":"Annotations
    is a map of arbitrary non-identifying metadata. Each of these\nkey/value pairs
    are added to the object''s annotations provided the key does not\nalready exist
    in the object''s annotations.","type":"object"},"labels":{"additionalProperties":{"type":"string"},"description":"Labels
    is a map of string keys and values that may match replicaset and\nservice selectors.
    Each of these key/value pairs are added to the\nobject''s labels provided the
    key does not already exist in the object''s labels.","type":"object"}},"type":"object"},"spec":{"description":"Spec
    is the calico-node DaemonSet''s PodSpec.","properties":{"affinity":{"description":"Affinity
    is a group of affinity scheduling rules for the calico-node pods.\nIf specified,
    this overrides any affinity that may be set on the calico-node DaemonSet.\nIf
    omitted, the calico-node DaemonSet will use its default value for affinity.\nWARNING:
    Please note that this field will override the default calico-node DaemonSet affinity.","properties":{"nodeAffinity":{"description":"Describes
    node affinity scheduling rules for the pod.","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"description":"The
    scheduler will prefer to schedule pods to nodes that satisfy\nthe affinity expressions
    specified by this field, but it may choose\na node that violates one or more of
    the expressions. The node that is\nmost preferred is the one with the greatest
    sum of weights, i.e.\nfor each node that meets all of the scheduling requirements
    (resource\nrequest, requiredDuringScheduling affinity expressions, etc.),\ncompute
    a sum by iterating through the elements of this field and adding\n\"weight\" to
    the sum if the node matches the corresponding matchExpressions; the\nnode(s) with
    the highest sum are the most preferred.","items":{"description":"An empty preferred
    scheduling term matches all objects with implicit weight 0\n(i.e. it''s a no-op).
    A null preferred scheduling term matches no objects (i.e. is also a no-op).","properties":{"preference":{"description":"A
    node selector term, associated with the corresponding weight.","properties":{"matchExpressions":{"description":"A
    list of node selector requirements by node''s labels.","items":{"description":"A
    node selector requirement is a selector that contains values, a key, and an operator\nthat
    relates the key and values.","properties":{"key":{"description":"The label key
    that the selector applies to.","type":"string"},"operator":{"description":"Represents
    a key''s relationship to a set of values.\nValid operators are In, NotIn, Exists,
    DoesNotExist. Gt, and Lt.","type":"string"},"values":{"description":"An array
    of string values. If the operator is In or NotIn,\nthe values array must be non-empty.
    If the operator is Exists or DoesNotExist,\nthe values array must be empty. If
    the operator is Gt or Lt, the values\narray must have a single element, which
    will be interpreted as an integer.\nThis array is replaced during a strategic
    merge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchFields":{"description":"A
    list of node selector requirements by node''s fields.","items":{"description":"A
    node selector requirement is a selector that contains values, a key, and an operator\nthat
    relates the key and values.","properties":{"key":{"description":"The label key
    that the selector applies to.","type":"string"},"operator":{"description":"Represents
    a key''s relationship to a set of values.\nValid operators are In, NotIn, Exists,
    DoesNotExist. Gt, and Lt.","type":"string"},"values":{"description":"An array
    of string values. If the operator is In or NotIn,\nthe values array must be non-empty.
    If the operator is Exists or DoesNotExist,\nthe values array must be empty. If
    the operator is Gt or Lt, the values\narray must have a single element, which
    will be interpreted as an integer.\nThis array is replaced during a strategic
    merge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"}},"type":"object","x-kubernetes-map-type":"atomic"},"weight":{"description":"Weight
    associated with matching the corresponding nodeSelectorTerm, in the range 1-100.","format":"int32","type":"integer"}},"required":["preference","weight"],"type":"object"},"type":"array"},"requiredDuringSchedulingIgnoredDuringExecution":{"description":"If
    the affinity requirements specified by this field are not met at\nscheduling time,
    the pod will not be scheduled onto the node.\nIf the affinity requirements specified
    by this field cease to be met\nat some point during pod execution (e.g. due to
    an update), the system\nmay or may not try to eventually evict the pod from its
    node.","properties":{"nodeSelectorTerms":{"description":"Required. A list of node
    selector terms. The terms are ORed.","items":{"description":"A null or empty node
    selector term matches no objects. The requirements of\nthem are ANDed.\nThe TopologySelectorTerm
    type implements a subset of the NodeSelectorTerm.","properties":{"matchExpressions":{"description":"A
    list of node selector requirements by node''s labels.","items":{"description":"A
    node selector requirement is a selector that contains values, a key, and an operator\nthat
    relates the key and values.","properties":{"key":{"description":"The label key
    that the selector applies to.","type":"string"},"operator":{"description":"Represents
    a key''s relationship to a set of values.\nValid operators are In, NotIn, Exists,
    DoesNotExist. Gt, and Lt.","type":"string"},"values":{"description":"An array
    of string values. If the operator is In or NotIn,\nthe values array must be non-empty.
    If the operator is Exists or DoesNotExist,\nthe values array must be empty. If
    the operator is Gt or Lt, the values\narray must have a single element, which
    will be interpreted as an integer.\nThis array is replaced during a strategic
    merge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchFields":{"description":"A
    list of node selector requirements by node''s fields.","items":{"description":"A
    node selector requirement is a selector that contains values, a key, and an operator\nthat
    relates the key and values.","properties":{"key":{"description":"The label key
    that the selector applies to.","type":"string"},"operator":{"description":"Represents
    a key''s relationship to a set of values.\nValid operators are In, NotIn, Exists,
    DoesNotExist. Gt, and Lt.","type":"string"},"values":{"description":"An array
    of string values. If the operator is In or NotIn,\nthe values array must be non-empty.
    If the operator is Exists or DoesNotExist,\nthe values array must be empty. If
    the operator is Gt or Lt, the values\narray must have a single element, which
    will be interpreted as an integer.\nThis array is replaced during a strategic
    merge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"}},"type":"object","x-kubernetes-map-type":"atomic"},"type":"array"}},"required":["nodeSelectorTerms"],"type":"object","x-kubernetes-map-type":"atomic"}},"type":"object"},"podAffinity":{"description":"Describes
    pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone,
    etc. as some other pod(s)).","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"description":"The
    scheduler will prefer to schedule pods to nodes that satisfy\nthe affinity expressions
    specified by this field, but it may choose\na node that violates one or more of
    the expressions. The node that is\nmost preferred is the one with the greatest
    sum of weights, i.e.\nfor each node that meets all of the scheduling requirements
    (resource\nrequest, requiredDuringScheduling affinity expressions, etc.),\ncompute
    a sum by iterating through the elements of this field and adding\n\"weight\" to
    the sum if the node has pods which matches the corresponding podAffinityTerm;
    the\nnode(s) with the highest sum are the most preferred.","items":{"description":"The
    weights of all of the matched WeightedPodAffinityTerm fields are added per-node
    to find the most preferred node(s)","properties":{"podAffinityTerm":{"description":"Required.
    A pod affinity term, associated with the corresponding weight.","properties":{"labelSelector":{"description":"A
    label query over a set of resources, in this case pods.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaceSelector":{"description":"A
    label query over the set of namespaces that the term applies to.\nThe term is
    applied to the union of the namespaces selected by this field\nand the ones listed
    in the namespaces field.\nnull selector and null or empty namespaces list means
    \"this pod''s namespace\".\nAn empty selector ({}) matches all namespaces.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaces":{"description":"namespaces
    specifies a static list of namespace names that the term applies to.\nThe term
    is applied to the union of the namespaces listed in this field\nand the ones selected
    by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector
    means \"this pod''s namespace\".","items":{"type":"string"},"type":"array"},"topologyKey":{"description":"This
    pod should be co-located (affinity) or not co-located (anti-affinity) with the
    pods matching\nthe labelSelector in the specified namespaces, where co-located
    is defined as running on a node\nwhose value of the label with key topologyKey
    matches that of any node on which any of the\nselected pods is running.\nEmpty
    topologyKey is not allowed.","type":"string"}},"required":["topologyKey"],"type":"object"},"weight":{"description":"weight
    associated with matching the corresponding podAffinityTerm,\nin the range 1-100.","format":"int32","type":"integer"}},"required":["podAffinityTerm","weight"],"type":"object"},"type":"array"},"requiredDuringSchedulingIgnoredDuringExecution":{"description":"If
    the affinity requirements specified by this field are not met at\nscheduling time,
    the pod will not be scheduled onto the node.\nIf the affinity requirements specified
    by this field cease to be met\nat some point during pod execution (e.g. due to
    a pod label update), the\nsystem may or may not try to eventually evict the pod
    from its node.\nWhen there are multiple elements, the lists of nodes corresponding
    to each\npodAffinityTerm are intersected, i.e. all terms must be satisfied.","items":{"description":"Defines
    a set of pods (namely those matching the labelSelector\nrelative to the given
    namespace(s)) that this pod should be\nco-located (affinity) or not co-located
    (anti-affinity) with,\nwhere co-located is defined as running on a node whose
    value of\nthe label with key <topologyKey> matches that of any node on which\na
    pod of the set of pods is running","properties":{"labelSelector":{"description":"A
    label query over a set of resources, in this case pods.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaceSelector":{"description":"A
    label query over the set of namespaces that the term applies to.\nThe term is
    applied to the union of the namespaces selected by this field\nand the ones listed
    in the namespaces field.\nnull selector and null or empty namespaces list means
    \"this pod''s namespace\".\nAn empty selector ({}) matches all namespaces.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaces":{"description":"namespaces
    specifies a static list of namespace names that the term applies to.\nThe term
    is applied to the union of the namespaces listed in this field\nand the ones selected
    by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector
    means \"this pod''s namespace\".","items":{"type":"string"},"type":"array"},"topologyKey":{"description":"This
    pod should be co-located (affinity) or not co-located (anti-affinity) with the
    pods matching\nthe labelSelector in the specified namespaces, where co-located
    is defined as running on a node\nwhose value of the label with key topologyKey
    matches that of any node on which any of the\nselected pods is running.\nEmpty
    topologyKey is not allowed.","type":"string"}},"required":["topologyKey"],"type":"object"},"type":"array"}},"type":"object"},"podAntiAffinity":{"description":"Describes
    pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node,
    zone, etc. as some other pod(s)).","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"description":"The
    scheduler will prefer to schedule pods to nodes that satisfy\nthe anti-affinity
    expressions specified by this field, but it may choose\na node that violates one
    or more of the expressions. The node that is\nmost preferred is the one with the
    greatest sum of weights, i.e.\nfor each node that meets all of the scheduling
    requirements (resource\nrequest, requiredDuringScheduling anti-affinity expressions,
    etc.),\ncompute a sum by iterating through the elements of this field and adding\n\"weight\"
    to the sum if the node has pods which matches the corresponding podAffinityTerm;
    the\nnode(s) with the highest sum are the most preferred.","items":{"description":"The
    weights of all of the matched WeightedPodAffinityTerm fields are added per-node
    to find the most preferred node(s)","properties":{"podAffinityTerm":{"description":"Required.
    A pod affinity term, associated with the corresponding weight.","properties":{"labelSelector":{"description":"A
    label query over a set of resources, in this case pods.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaceSelector":{"description":"A
    label query over the set of namespaces that the term applies to.\nThe term is
    applied to the union of the namespaces selected by this field\nand the ones listed
    in the namespaces field.\nnull selector and null or empty namespaces list means
    \"this pod''s namespace\".\nAn empty selector ({}) matches all namespaces.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaces":{"description":"namespaces
    specifies a static list of namespace names that the term applies to.\nThe term
    is applied to the union of the namespaces listed in this field\nand the ones selected
    by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector
    means \"this pod''s namespace\".","items":{"type":"string"},"type":"array"},"topologyKey":{"description":"This
    pod should be co-located (affinity) or not co-located (anti-affinity) with the
    pods matching\nthe labelSelector in the specified namespaces, where co-located
    is defined as running on a node\nwhose value of the label with key topologyKey
    matches that of any node on which any of the\nselected pods is running.\nEmpty
    topologyKey is not allowed.","type":"string"}},"required":["topologyKey"],"type":"object"},"weight":{"description":"weight
    associated with matching the corresponding podAffinityTerm,\nin the range 1-100.","format":"int32","type":"integer"}},"required":["podAffinityTerm","weight"],"type":"object"},"type":"array"},"requiredDuringSchedulingIgnoredDuringExecution":{"description":"If
    the anti-affinity requirements specified by this field are not met at\nscheduling
    time, the pod will not be scheduled onto the node.\nIf the anti-affinity requirements
    specified by this field cease to be met\nat some point during pod execution (e.g.
    due to a pod label update), the\nsystem may or may not try to eventually evict
    the pod from its node.\nWhen there are multiple elements, the lists of nodes corresponding
    to each\npodAffinityTerm are intersected, i.e. all terms must be satisfied.","items":{"description":"Defines
    a set of pods (namely those matching the labelSelector\nrelative to the given
    namespace(s)) that this pod should be\nco-located (affinity) or not co-located
    (anti-affinity) with,\nwhere co-located is defined as running on a node whose
    value of\nthe label with key <topologyKey> matches that of any node on which\na
    pod of the set of pods is running","properties":{"labelSelector":{"description":"A
    label query over a set of resources, in this case pods.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaceSelector":{"description":"A
    label query over the set of namespaces that the term applies to.\nThe term is
    applied to the union of the namespaces selected by this field\nand the ones listed
    in the namespaces field.\nnull selector and null or empty namespaces list means
    \"this pod''s namespace\".\nAn empty selector ({}) matches all namespaces.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaces":{"description":"namespaces
    specifies a static list of namespace names that the term applies to.\nThe term
    is applied to the union of the namespaces listed in this field\nand the ones selected
    by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector
    means \"this pod''s namespace\".","items":{"type":"string"},"type":"array"},"topologyKey":{"description":"This
    pod should be co-located (affinity) or not co-located (anti-affinity) with the
    pods matching\nthe labelSelector in the specified namespaces, where co-located
    is defined as running on a node\nwhose value of the label with key topologyKey
    matches that of any node on which any of the\nselected pods is running.\nEmpty
    topologyKey is not allowed.","type":"string"}},"required":["topologyKey"],"type":"object"},"type":"array"}},"type":"object"}},"type":"object"},"containers":{"description":"Containers
    is a list of calico-node containers.\nIf specified, this overrides the specified
    calico-node DaemonSet containers.\nIf omitted, the calico-node DaemonSet will
    use its default values for its containers.","items":{"description":"CalicoNodeDaemonSetContainer
    is a calico-node DaemonSet container.","properties":{"name":{"description":"Name
    is an enum which identifies the calico-node DaemonSet container by name.\nSupported
    values are: calico-node","enum":["calico-node"],"type":"string"},"resources":{"description":"Resources
    allows customization of limits and requests for compute resources such as cpu
    and memory.\nIf specified, this overrides the named calico-node DaemonSet container''s
    resources.\nIf omitted, the calico-node DaemonSet will use its default value for
    this container''s resources.\nIf used in conjunction with the deprecated ComponentResources,
    then this value takes precedence.","properties":{"claims":{"description":"Claims
    lists the names of resources, defined in spec.resourceClaims,\nthat are used by
    this container.\nThis is an alpha field and requires enabling the\nDynamicResourceAllocation
    feature gate.\nThis field is immutable. It can only be set for containers.","items":{"description":"ResourceClaim
    references one entry in PodSpec.ResourceClaims.","properties":{"name":{"description":"Name
    must match the name of one entry in pod.spec.resourceClaims of\nthe Pod where
    this field is used. It makes that resource available\ninside a container.","type":"string"}},"required":["name"],"type":"object"},"type":"array","x-kubernetes-list-map-keys":["name"],"x-kubernetes-list-type":"map"},"limits":{"additionalProperties":{"anyOf":[{"type":"integer"},{"type":"string"}],"pattern":"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$","x-kubernetes-int-or-string":true},"description":"Limits
    describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/","type":"object"},"requests":{"additionalProperties":{"anyOf":[{"type":"integer"},{"type":"string"}],"pattern":"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$","x-kubernetes-int-or-string":true},"description":"Requests
    describes the minimum amount of compute resources required.\nIf Requests is omitted
    for a container, it defaults to Limits if that is explicitly specified,\notherwise
    to an implementation-defined value. Requests cannot exceed Limits.\nMore info:
    https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/","type":"object"}},"type":"object"}},"required":["name"],"type":"object"},"type":"array"},"initContainers":{"description":"InitContainers
    is a list of calico-node init containers.\nIf specified, this overrides the specified
    calico-node DaemonSet init containers.\nIf omitted, the calico-node DaemonSet
    will use its default values for its init containers.","items":{"description":"CalicoNodeDaemonSetInitContainer
    is a calico-node DaemonSet init container.","properties":{"name":{"description":"Name
    is an enum which identifies the calico-node DaemonSet init container by name.\nSupported
    values are: install-cni, hostpath-init, flexvol-driver, mount-bpffs, node-certs-key-cert-provisioner,
    calico-node-prometheus-server-tls-key-cert-provisioner","enum":["install-cni","hostpath-init","flexvol-driver","mount-bpffs","node-certs-key-cert-provisioner","calico-node-prometheus-server-tls-key-cert-provisioner"],"type":"string"},"resources":{"description":"Resources
    allows customization of limits and requests for compute resources such as cpu
    and memory.\nIf specified, this overrides the named calico-node DaemonSet init
    container''s resources.\nIf omitted, the calico-node DaemonSet will use its default
    value for this container''s resources.\nIf used in conjunction with the deprecated
    ComponentResources, then this value takes precedence.","properties":{"claims":{"description":"Claims
    lists the names of resources, defined in spec.resourceClaims,\nthat are used by
    this container.\nThis is an alpha field and requires enabling the\nDynamicResourceAllocation
    feature gate.\nThis field is immutable. It can only be set for containers.","items":{"description":"ResourceClaim
    references one entry in PodSpec.ResourceClaims.","properties":{"name":{"description":"Name
    must match the name of one entry in pod.spec.resourceClaims of\nthe Pod where
    this field is used. It makes that resource available\ninside a container.","type":"string"}},"required":["name"],"type":"object"},"type":"array","x-kubernetes-list-map-keys":["name"],"x-kubernetes-list-type":"map"},"limits":{"additionalProperties":{"anyOf":[{"type":"integer"},{"type":"string"}],"pattern":"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$","x-kubernetes-int-or-string":true},"description":"Limits
    describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/","type":"object"},"requests":{"additionalProperties":{"anyOf":[{"type":"integer"},{"type":"string"}],"pattern":"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$","x-kubernetes-int-or-string":true},"description":"Requests
    describes the minimum amount of compute resources required.\nIf Requests is omitted
    for a container, it defaults to Limits if that is explicitly specified,\notherwise
    to an implementation-defined value. Requests cannot exceed Limits.\nMore info:
    https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/","type":"object"}},"type":"object"}},"required":["name"],"type":"object"},"type":"array"},"nodeSelector":{"additionalProperties":{"type":"string"},"description":"NodeSelector
    is the calico-node pod''s scheduling constraints.\nIf specified, each of the key/value
    pairs are added to the calico-node DaemonSet nodeSelector provided\nthe key does
    not already exist in the object''s nodeSelector.\nIf omitted, the calico-node
    DaemonSet will use its default value for nodeSelector.\nWARNING: Please note that
    this field will modify the default calico-node DaemonSet nodeSelector.","type":"object"},"tolerations":{"description":"Tolerations
    is the calico-node pod''s tolerations.\nIf specified, this overrides any tolerations
    that may be set on the calico-node DaemonSet.\nIf omitted, the calico-node DaemonSet
    will use its default value for tolerations.\nWARNING: Please note that this field
    will override the default calico-node DaemonSet tolerations.","items":{"description":"The
    pod this Toleration is attached to tolerates any taint that matches\nthe triple
    <key,value,effect> using the matching operator <operator>.","properties":{"effect":{"description":"Effect
    indicates the taint effect to match. Empty means match all taint effects.\nWhen
    specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.","type":"string"},"key":{"description":"Key
    is the taint key that the toleration applies to. Empty means match all taint keys.\nIf
    the key is empty, operator must be Exists; this combination means to match all
    values and all keys.","type":"string"},"operator":{"description":"Operator represents
    a key''s relationship to the value.\nValid operators are Exists and Equal. Defaults
    to Equal.\nExists is equivalent to wildcard for value, so that a pod can\ntolerate
    all taints of a particular category.","type":"string"},"tolerationSeconds":{"description":"TolerationSeconds
    represents the period of time the toleration (which must be\nof effect NoExecute,
    otherwise this field is ignored) tolerates the taint. By default,\nit is not set,
    which means tolerate the taint forever (do not evict). Zero and\nnegative values
    will be treated as 0 (evict immediately) by the system.","format":"int64","type":"integer"},"value":{"description":"Value
    is the taint value the toleration matches to.\nIf the operator is Exists, the
    value should be empty, otherwise just a regular string.","type":"string"}},"type":"object"},"type":"array"}},"type":"object"}},"type":"object"}},"type":"object"}},"type":"object"},"calicoNodeWindowsDaemonSet":{"description":"CalicoNodeWindowsDaemonSet
    configures the calico-node-windows DaemonSet.","properties":{"metadata":{"description":"Metadata
    is a subset of a Kubernetes object''s metadata that is added to the DaemonSet.","properties":{"annotations":{"additionalProperties":{"type":"string"},"description":"Annotations
    is a map of arbitrary non-identifying metadata. Each of these\nkey/value pairs
    are added to the object''s annotations provided the key does not\nalready exist
    in the object''s annotations.","type":"object"},"labels":{"additionalProperties":{"type":"string"},"description":"Labels
    is a map of string keys and values that may match replicaset and\nservice selectors.
    Each of these key/value pairs are added to the\nobject''s labels provided the
    key does not already exist in the object''s labels.","type":"object"}},"type":"object"},"spec":{"description":"Spec
    is the specification of the calico-node-windows DaemonSet.","properties":{"minReadySeconds":{"description":"MinReadySeconds
    is the minimum number of seconds for which a newly created DaemonSet pod should\nbe
    ready without any of its container crashing, for it to be considered available.\nIf
    specified, this overrides any minReadySeconds value that may be set on the calico-node-windows
    DaemonSet.\nIf omitted, the calico-node-windows DaemonSet will use its default
    value for minReadySeconds.","format":"int32","maximum":2147483647,"minimum":0,"type":"integer"},"template":{"description":"Template
    describes the calico-node-windows DaemonSet pod that will be created.","properties":{"metadata":{"description":"Metadata
    is a subset of a Kubernetes object''s metadata that is added to\nthe pod''s metadata.","properties":{"annotations":{"additionalProperties":{"type":"string"},"description":"Annotations
    is a map of arbitrary non-identifying metadata. Each of these\nkey/value pairs
    are added to the object''s annotations provided the key does not\nalready exist
    in the object''s annotations.","type":"object"},"labels":{"additionalProperties":{"type":"string"},"description":"Labels
    is a map of string keys and values that may match replicaset and\nservice selectors.
    Each of these key/value pairs are added to the\nobject''s labels provided the
    key does not already exist in the object''s labels.","type":"object"}},"type":"object"},"spec":{"description":"Spec
    is the calico-node-windows DaemonSet''s PodSpec.","properties":{"affinity":{"description":"Affinity
    is a group of affinity scheduling rules for the calico-node-windows pods.\nIf
    specified, this overrides any affinity that may be set on the calico-node-windows
    DaemonSet.\nIf omitted, the calico-node-windows DaemonSet will use its default
    value for affinity.\nWARNING: Please note that this field will override the default
    calico-node-windows DaemonSet affinity.","properties":{"nodeAffinity":{"description":"Describes
    node affinity scheduling rules for the pod.","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"description":"The
    scheduler will prefer to schedule pods to nodes that satisfy\nthe affinity expressions
    specified by this field, but it may choose\na node that violates one or more of
    the expressions. The node that is\nmost preferred is the one with the greatest
    sum of weights, i.e.\nfor each node that meets all of the scheduling requirements
    (resource\nrequest, requiredDuringScheduling affinity expressions, etc.),\ncompute
    a sum by iterating through the elements of this field and adding\n\"weight\" to
    the sum if the node matches the corresponding matchExpressions; the\nnode(s) with
    the highest sum are the most preferred.","items":{"description":"An empty preferred
    scheduling term matches all objects with implicit weight 0\n(i.e. it''s a no-op).
    A null preferred scheduling term matches no objects (i.e. is also a no-op).","properties":{"preference":{"description":"A
    node selector term, associated with the corresponding weight.","properties":{"matchExpressions":{"description":"A
    list of node selector requirements by node''s labels.","items":{"description":"A
    node selector requirement is a selector that contains values, a key, and an operator\nthat
    relates the key and values.","properties":{"key":{"description":"The label key
    that the selector applies to.","type":"string"},"operator":{"description":"Represents
    a key''s relationship to a set of values.\nValid operators are In, NotIn, Exists,
    DoesNotExist. Gt, and Lt.","type":"string"},"values":{"description":"An array
    of string values. If the operator is In or NotIn,\nthe values array must be non-empty.
    If the operator is Exists or DoesNotExist,\nthe values array must be empty. If
    the operator is Gt or Lt, the values\narray must have a single element, which
    will be interpreted as an integer.\nThis array is replaced during a strategic
    merge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchFields":{"description":"A
    list of node selector requirements by node''s fields.","items":{"description":"A
    node selector requirement is a selector that contains values, a key, and an operator\nthat
    relates the key and values.","properties":{"key":{"description":"The label key
    that the selector applies to.","type":"string"},"operator":{"description":"Represents
    a key''s relationship to a set of values.\nValid operators are In, NotIn, Exists,
    DoesNotExist. Gt, and Lt.","type":"string"},"values":{"description":"An array
    of string values. If the operator is In or NotIn,\nthe values array must be non-empty.
    If the operator is Exists or DoesNotExist,\nthe values array must be empty. If
    the operator is Gt or Lt, the values\narray must have a single element, which
    will be interpreted as an integer.\nThis array is replaced during a strategic
    merge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"}},"type":"object","x-kubernetes-map-type":"atomic"},"weight":{"description":"Weight
    associated with matching the corresponding nodeSelectorTerm, in the range 1-100.","format":"int32","type":"integer"}},"required":["preference","weight"],"type":"object"},"type":"array"},"requiredDuringSchedulingIgnoredDuringExecution":{"description":"If
    the affinity requirements specified by this field are not met at\nscheduling time,
    the pod will not be scheduled onto the node.\nIf the affinity requirements specified
    by this field cease to be met\nat some point during pod execution (e.g. due to
    an update), the system\nmay or may not try to eventually evict the pod from its
    node.","properties":{"nodeSelectorTerms":{"description":"Required. A list of node
    selector terms. The terms are ORed.","items":{"description":"A null or empty node
    selector term matches no objects. The requirements of\nthem are ANDed.\nThe TopologySelectorTerm
    type implements a subset of the NodeSelectorTerm.","properties":{"matchExpressions":{"description":"A
    list of node selector requirements by node''s labels.","items":{"description":"A
    node selector requirement is a selector that contains values, a key, and an operator\nthat
    relates the key and values.","properties":{"key":{"description":"The label key
    that the selector applies to.","type":"string"},"operator":{"description":"Represents
    a key''s relationship to a set of values.\nValid operators are In, NotIn, Exists,
    DoesNotExist. Gt, and Lt.","type":"string"},"values":{"description":"An array
    of string values. If the operator is In or NotIn,\nthe values array must be non-empty.
    If the operator is Exists or DoesNotExist,\nthe values array must be empty. If
    the operator is Gt or Lt, the values\narray must have a single element, which
    will be interpreted as an integer.\nThis array is replaced during a strategic
    merge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchFields":{"description":"A
    list of node selector requirements by node''s fields.","items":{"description":"A
    node selector requirement is a selector that contains values, a key, and an operator\nthat
    relates the key and values.","properties":{"key":{"description":"The label key
    that the selector applies to.","type":"string"},"operator":{"description":"Represents
    a key''s relationship to a set of values.\nValid operators are In, NotIn, Exists,
    DoesNotExist. Gt, and Lt.","type":"string"},"values":{"description":"An array
    of string values. If the operator is In or NotIn,\nthe values array must be non-empty.
    If the operator is Exists or DoesNotExist,\nthe values array must be empty. If
    the operator is Gt or Lt, the values\narray must have a single element, which
    will be interpreted as an integer.\nThis array is replaced during a strategic
    merge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"}},"type":"object","x-kubernetes-map-type":"atomic"},"type":"array"}},"required":["nodeSelectorTerms"],"type":"object","x-kubernetes-map-type":"atomic"}},"type":"object"},"podAffinity":{"description":"Describes
    pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone,
    etc. as some other pod(s)).","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"description":"The
    scheduler will prefer to schedule pods to nodes that satisfy\nthe affinity expressions
    specified by this field, but it may choose\na node that violates one or more of
    the expressions. The node that is\nmost preferred is the one with the greatest
    sum of weights, i.e.\nfor each node that meets all of the scheduling requirements
    (resource\nrequest, requiredDuringScheduling affinity expressions, etc.),\ncompute
    a sum by iterating through the elements of this field and adding\n\"weight\" to
    the sum if the node has pods which matches the corresponding podAffinityTerm;
    the\nnode(s) with the highest sum are the most preferred.","items":{"description":"The
    weights of all of the matched WeightedPodAffinityTerm fields are added per-node
    to find the most preferred node(s)","properties":{"podAffinityTerm":{"description":"Required.
    A pod affinity term, associated with the corresponding weight.","properties":{"labelSelector":{"description":"A
    label query over a set of resources, in this case pods.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaceSelector":{"description":"A
    label query over the set of namespaces that the term applies to.\nThe term is
    applied to the union of the namespaces selected by this field\nand the ones listed
    in the namespaces field.\nnull selector and null or empty namespaces list means
    \"this pod''s namespace\".\nAn empty selector ({}) matches all namespaces.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaces":{"description":"namespaces
    specifies a static list of namespace names that the term applies to.\nThe term
    is applied to the union of the namespaces listed in this field\nand the ones selected
    by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector
    means \"this pod''s namespace\".","items":{"type":"string"},"type":"array"},"topologyKey":{"description":"This
    pod should be co-located (affinity) or not co-located (anti-affinity) with the
    pods matching\nthe labelSelector in the specified namespaces, where co-located
    is defined as running on a node\nwhose value of the label with key topologyKey
    matches that of any node on which any of the\nselected pods is running.\nEmpty
    topologyKey is not allowed.","type":"string"}},"required":["topologyKey"],"type":"object"},"weight":{"description":"weight
    associated with matching the corresponding podAffinityTerm,\nin the range 1-100.","format":"int32","type":"integer"}},"required":["podAffinityTerm","weight"],"type":"object"},"type":"array"},"requiredDuringSchedulingIgnoredDuringExecution":{"description":"If
    the affinity requirements specified by this field are not met at\nscheduling time,
    the pod will not be scheduled onto the node.\nIf the affinity requirements specified
    by this field cease to be met\nat some point during pod execution (e.g. due to
    a pod label update), the\nsystem may or may not try to eventually evict the pod
    from its node.\nWhen there are multiple elements, the lists of nodes corresponding
    to each\npodAffinityTerm are intersected, i.e. all terms must be satisfied.","items":{"description":"Defines
    a set of pods (namely those matching the labelSelector\nrelative to the given
    namespace(s)) that this pod should be\nco-located (affinity) or not co-located
    (anti-affinity) with,\nwhere co-located is defined as running on a node whose
    value of\nthe label with key <topologyKey> matches that of any node on which\na
    pod of the set of pods is running","properties":{"labelSelector":{"description":"A
    label query over a set of resources, in this case pods.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaceSelector":{"description":"A
    label query over the set of namespaces that the term applies to.\nThe term is
    applied to the union of the namespaces selected by this field\nand the ones listed
    in the namespaces field.\nnull selector and null or empty namespaces list means
    \"this pod''s namespace\".\nAn empty selector ({}) matches all namespaces.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaces":{"description":"namespaces
    specifies a static list of namespace names that the term applies to.\nThe term
    is applied to the union of the namespaces listed in this field\nand the ones selected
    by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector
    means \"this pod''s namespace\".","items":{"type":"string"},"type":"array"},"topologyKey":{"description":"This
    pod should be co-located (affinity) or not co-located (anti-affinity) with the
    pods matching\nthe labelSelector in the specified namespaces, where co-located
    is defined as running on a node\nwhose value of the label with key topologyKey
    matches that of any node on which any of the\nselected pods is running.\nEmpty
    topologyKey is not allowed.","type":"string"}},"required":["topologyKey"],"type":"object"},"type":"array"}},"type":"object"},"podAntiAffinity":{"description":"Describes
    pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node,
    zone, etc. as some other pod(s)).","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"description":"The
    scheduler will prefer to schedule pods to nodes that satisfy\nthe anti-affinity
    expressions specified by this field, but it may choose\na node that violates one
    or more of the expressions. The node that is\nmost preferred is the one with the
    greatest sum of weights, i.e.\nfor each node that meets all of the scheduling
    requirements (resource\nrequest, requiredDuringScheduling anti-affinity expressions,
    etc.),\ncompute a sum by iterating through the elements of this field and adding\n\"weight\"
    to the sum if the node has pods which matches the corresponding podAffinityTerm;
    the\nnode(s) with the highest sum are the most preferred.","items":{"description":"The
    weights of all of the matched WeightedPodAffinityTerm fields are added per-node
    to find the most preferred node(s)","properties":{"podAffinityTerm":{"description":"Required.
    A pod affinity term, associated with the corresponding weight.","properties":{"labelSelector":{"description":"A
    label query over a set of resources, in this case pods.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaceSelector":{"description":"A
    label query over the set of namespaces that the term applies to.\nThe term is
    applied to the union of the namespaces selected by this field\nand the ones listed
    in the namespaces field.\nnull selector and null or empty namespaces list means
    \"this pod''s namespace\".\nAn empty selector ({}) matches all namespaces.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaces":{"description":"namespaces
    specifies a static list of namespace names that the term applies to.\nThe term
    is applied to the union of the namespaces listed in this field\nand the ones selected
    by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector
    means \"this pod''s namespace\".","items":{"type":"string"},"type":"array"},"topologyKey":{"description":"This
    pod should be co-located (affinity) or not co-located (anti-affinity) with the
    pods matching\nthe labelSelector in the specified namespaces, where co-located
    is defined as running on a node\nwhose value of the label with key topologyKey
    matches that of any node on which any of the\nselected pods is running.\nEmpty
    topologyKey is not allowed.","type":"string"}},"required":["topologyKey"],"type":"object"},"weight":{"description":"weight
    associated with matching the corresponding podAffinityTerm,\nin the range 1-100.","format":"int32","type":"integer"}},"required":["podAffinityTerm","weight"],"type":"object"},"type":"array"},"requiredDuringSchedulingIgnoredDuringExecution":{"description":"If
    the anti-affinity requirements specified by this field are not met at\nscheduling
    time, the pod will not be scheduled onto the node.\nIf the anti-affinity requirements
    specified by this field cease to be met\nat some point during pod execution (e.g.
    due to a pod label update), the\nsystem may or may not try to eventually evict
    the pod from its node.\nWhen there are multiple elements, the lists of nodes corresponding
    to each\npodAffinityTerm are intersected, i.e. all terms must be satisfied.","items":{"description":"Defines
    a set of pods (namely those matching the labelSelector\nrelative to the given
    namespace(s)) that this pod should be\nco-located (affinity) or not co-located
    (anti-affinity) with,\nwhere co-located is defined as running on a node whose
    value of\nthe label with key <topologyKey> matches that of any node on which\na
    pod of the set of pods is running","properties":{"labelSelector":{"description":"A
    label query over a set of resources, in this case pods.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaceSelector":{"description":"A
    label query over the set of namespaces that the term applies to.\nThe term is
    applied to the union of the namespaces selected by this field\nand the ones listed
    in the namespaces field.\nnull selector and null or empty namespaces list means
    \"this pod''s namespace\".\nAn empty selector ({}) matches all namespaces.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaces":{"description":"namespaces
    specifies a static list of namespace names that the term applies to.\nThe term
    is applied to the union of the namespaces listed in this field\nand the ones selected
    by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector
    means \"this pod''s namespace\".","items":{"type":"string"},"type":"array"},"topologyKey":{"description":"This
    pod should be co-located (affinity) or not co-located (anti-affinity) with the
    pods matching\nthe labelSelector in the specified namespaces, where co-located
    is defined as running on a node\nwhose value of the label with key topologyKey
    matches that of any node on which any of the\nselected pods is running.\nEmpty
    topologyKey is not allowed.","type":"string"}},"required":["topologyKey"],"type":"object"},"type":"array"}},"type":"object"}},"type":"object"},"containers":{"description":"Containers
    is a list of calico-node-windows containers.\nIf specified, this overrides the
    specified calico-node-windows DaemonSet containers.\nIf omitted, the calico-node-windows
    DaemonSet will use its default values for its containers.","items":{"description":"CalicoNodeWindowsDaemonSetContainer
    is a calico-node-windows DaemonSet container.","properties":{"name":{"description":"Name
    is an enum which identifies the calico-node-windows DaemonSet container by name.\nSupported
    values are: calico-node-windows","enum":["calico-node-windows"],"type":"string"},"resources":{"description":"Resources
    allows customization of limits and requests for compute resources such as cpu
    and memory.\nIf specified, this overrides the named calico-node-windows DaemonSet
    container''s resources.\nIf omitted, the calico-node-windows DaemonSet will use
    its default value for this container''s resources.\nIf used in conjunction with
    the deprecated ComponentResources, then this value takes precedence.","properties":{"claims":{"description":"Claims
    lists the names of resources, defined in spec.resourceClaims,\nthat are used by
    this container.\nThis is an alpha field and requires enabling the\nDynamicResourceAllocation
    feature gate.\nThis field is immutable. It can only be set for containers.","items":{"description":"ResourceClaim
    references one entry in PodSpec.ResourceClaims.","properties":{"name":{"description":"Name
    must match the name of one entry in pod.spec.resourceClaims of\nthe Pod where
    this field is used. It makes that resource available\ninside a container.","type":"string"}},"required":["name"],"type":"object"},"type":"array","x-kubernetes-list-map-keys":["name"],"x-kubernetes-list-type":"map"},"limits":{"additionalProperties":{"anyOf":[{"type":"integer"},{"type":"string"}],"pattern":"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$","x-kubernetes-int-or-string":true},"description":"Limits
    describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/","type":"object"},"requests":{"additionalProperties":{"anyOf":[{"type":"integer"},{"type":"string"}],"pattern":"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$","x-kubernetes-int-or-string":true},"description":"Requests
    describes the minimum amount of compute resources required.\nIf Requests is omitted
    for a container, it defaults to Limits if that is explicitly specified,\notherwise
    to an implementation-defined value. Requests cannot exceed Limits.\nMore info:
    https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/","type":"object"}},"type":"object"}},"required":["name"],"type":"object"},"type":"array"},"initContainers":{"description":"InitContainers
    is a list of calico-node-windows init containers.\nIf specified, this overrides
    the specified calico-node-windows DaemonSet init containers.\nIf omitted, the
    calico-node-windows DaemonSet will use its default values for its init containers.","items":{"description":"CalicoNodeWindowsDaemonSetInitContainer
    is a calico-node-windows DaemonSet init container.","properties":{"name":{"description":"Name
    is an enum which identifies the calico-node-windows DaemonSet init container by
    name.\nSupported values are: install-cni;hostpath-init, flexvol-driver, mount-bpffs,
    node-certs-key-cert-provisioner, calico-node-windows-prometheus-server-tls-key-cert-provisioner","enum":["install-cni","hostpath-init","flexvol-driver","mount-bpffs","node-certs-key-cert-provisioner","calico-node-windows-prometheus-server-tls-key-cert-provisioner"],"type":"string"},"resources":{"description":"Resources
    allows customization of limits and requests for compute resources such as cpu
    and memory.\nIf specified, this overrides the named calico-node-windows DaemonSet
    init container''s resources.\nIf omitted, the calico-node-windows DaemonSet will
    use its default value for this container''s resources.\nIf used in conjunction
    with the deprecated ComponentResources, then this value takes precedence.","properties":{"claims":{"description":"Claims
    lists the names of resources, defined in spec.resourceClaims,\nthat are used by
    this container.\nThis is an alpha field and requires enabling the\nDynamicResourceAllocation
    feature gate.\nThis field is immutable. It can only be set for containers.","items":{"description":"ResourceClaim
    references one entry in PodSpec.ResourceClaims.","properties":{"name":{"description":"Name
    must match the name of one entry in pod.spec.resourceClaims of\nthe Pod where
    this field is used. It makes that resource available\ninside a container.","type":"string"}},"required":["name"],"type":"object"},"type":"array","x-kubernetes-list-map-keys":["name"],"x-kubernetes-list-type":"map"},"limits":{"additionalProperties":{"anyOf":[{"type":"integer"},{"type":"string"}],"pattern":"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$","x-kubernetes-int-or-string":true},"description":"Limits
    describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/","type":"object"},"requests":{"additionalProperties":{"anyOf":[{"type":"integer"},{"type":"string"}],"pattern":"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$","x-kubernetes-int-or-string":true},"description":"Requests
    describes the minimum amount of compute resources required.\nIf Requests is omitted
    for a container, it defaults to Limits if that is explicitly specified,\notherwise
    to an implementation-defined value. Requests cannot exceed Limits.\nMore info:
    https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/","type":"object"}},"type":"object"}},"required":["name"],"type":"object"},"type":"array"},"nodeSelector":{"additionalProperties":{"type":"string"},"description":"NodeSelector
    is the calico-node-windows pod''s scheduling constraints.\nIf specified, each
    of the key/value pairs are added to the calico-node-windows DaemonSet nodeSelector
    provided\nthe key does not already exist in the object''s nodeSelector.\nIf omitted,
    the calico-node-windows DaemonSet will use its default value for nodeSelector.\nWARNING:
    Please note that this field will modify the default calico-node-windows DaemonSet
    nodeSelector.","type":"object"},"tolerations":{"description":"Tolerations is the
    calico-node-windows pod''s tolerations.\nIf specified, this overrides any tolerations
    that may be set on the calico-node-windows DaemonSet.\nIf omitted, the calico-node-windows
    DaemonSet will use its default value for tolerations.\nWARNING: Please note that
    this field will override the default calico-node-windows DaemonSet tolerations.","items":{"description":"The
    pod this Toleration is attached to tolerates any taint that matches\nthe triple
    <key,value,effect> using the matching operator <operator>.","properties":{"effect":{"description":"Effect
    indicates the taint effect to match. Empty means match all taint effects.\nWhen
    specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.","type":"string"},"key":{"description":"Key
    is the taint key that the toleration applies to. Empty means match all taint keys.\nIf
    the key is empty, operator must be Exists; this combination means to match all
    values and all keys.","type":"string"},"operator":{"description":"Operator represents
    a key''s relationship to the value.\nValid operators are Exists and Equal. Defaults
    to Equal.\nExists is equivalent to wildcard for value, so that a pod can\ntolerate
    all taints of a particular category.","type":"string"},"tolerationSeconds":{"description":"TolerationSeconds
    represents the period of time the toleration (which must be\nof effect NoExecute,
    otherwise this field is ignored) tolerates the taint. By default,\nit is not set,
    which means tolerate the taint forever (do not evict). Zero and\nnegative values
    will be treated as 0 (evict immediately) by the system.","format":"int64","type":"integer"},"value":{"description":"Value
    is the taint value the toleration matches to.\nIf the operator is Exists, the
    value should be empty, otherwise just a regular string.","type":"string"}},"type":"object"},"type":"array"}},"type":"object"}},"type":"object"}},"type":"object"}},"type":"object"},"calicoWindowsUpgradeDaemonSet":{"description":"Deprecated.
    The CalicoWindowsUpgradeDaemonSet is deprecated and will be removed from the API
    in the future.\nCalicoWindowsUpgradeDaemonSet configures the calico-windows-upgrade
    DaemonSet.","properties":{"metadata":{"description":"Metadata is a subset of a
    Kubernetes object''s metadata that is added to the Deployment.","properties":{"annotations":{"additionalProperties":{"type":"string"},"description":"Annotations
    is a map of arbitrary non-identifying metadata. Each of these\nkey/value pairs
    are added to the object''s annotations provided the key does not\nalready exist
    in the object''s annotations.","type":"object"},"labels":{"additionalProperties":{"type":"string"},"description":"Labels
    is a map of string keys and values that may match replicaset and\nservice selectors.
    Each of these key/value pairs are added to the\nobject''s labels provided the
    key does not already exist in the object''s labels.","type":"object"}},"type":"object"},"spec":{"description":"Spec
    is the specification of the calico-windows-upgrade DaemonSet.","properties":{"minReadySeconds":{"description":"MinReadySeconds
    is the minimum number of seconds for which a newly created Deployment pod should\nbe
    ready without any of its container crashing, for it to be considered available.\nIf
    specified, this overrides any minReadySeconds value that may be set on the calico-windows-upgrade
    DaemonSet.\nIf omitted, the calico-windows-upgrade DaemonSet will use its default
    value for minReadySeconds.","format":"int32","maximum":2147483647,"minimum":0,"type":"integer"},"template":{"description":"Template
    describes the calico-windows-upgrade DaemonSet pod that will be created.","properties":{"metadata":{"description":"Metadata
    is a subset of a Kubernetes object''s metadata that is added to\nthe pod''s metadata.","properties":{"annotations":{"additionalProperties":{"type":"string"},"description":"Annotations
    is a map of arbitrary non-identifying metadata. Each of these\nkey/value pairs
    are added to the object''s annotations provided the key does not\nalready exist
    in the object''s annotations.","type":"object"},"labels":{"additionalProperties":{"type":"string"},"description":"Labels
    is a map of string keys and values that may match replicaset and\nservice selectors.
    Each of these key/value pairs are added to the\nobject''s labels provided the
    key does not already exist in the object''s labels.","type":"object"}},"type":"object"},"spec":{"description":"Spec
    is the calico-windows-upgrade DaemonSet''s PodSpec.","properties":{"affinity":{"description":"Affinity
    is a group of affinity scheduling rules for the calico-windows-upgrade pods.\nIf
    specified, this overrides any affinity that may be set on the calico-windows-upgrade
    DaemonSet.\nIf omitted, the calico-windows-upgrade DaemonSet will use its default
    value for affinity.\nWARNING: Please note that this field will override the default
    calico-windows-upgrade DaemonSet affinity.","properties":{"nodeAffinity":{"description":"Describes
    node affinity scheduling rules for the pod.","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"description":"The
    scheduler will prefer to schedule pods to nodes that satisfy\nthe affinity expressions
    specified by this field, but it may choose\na node that violates one or more of
    the expressions. The node that is\nmost preferred is the one with the greatest
    sum of weights, i.e.\nfor each node that meets all of the scheduling requirements
    (resource\nrequest, requiredDuringScheduling affinity expressions, etc.),\ncompute
    a sum by iterating through the elements of this field and adding\n\"weight\" to
    the sum if the node matches the corresponding matchExpressions; the\nnode(s) with
    the highest sum are the most preferred.","items":{"description":"An empty preferred
    scheduling term matches all objects with implicit weight 0\n(i.e. it''s a no-op).
    A null preferred scheduling term matches no objects (i.e. is also a no-op).","properties":{"preference":{"description":"A
    node selector term, associated with the corresponding weight.","properties":{"matchExpressions":{"description":"A
    list of node selector requirements by node''s labels.","items":{"description":"A
    node selector requirement is a selector that contains values, a key, and an operator\nthat
    relates the key and values.","properties":{"key":{"description":"The label key
    that the selector applies to.","type":"string"},"operator":{"description":"Represents
    a key''s relationship to a set of values.\nValid operators are In, NotIn, Exists,
    DoesNotExist. Gt, and Lt.","type":"string"},"values":{"description":"An array
    of string values. If the operator is In or NotIn,\nthe values array must be non-empty.
    If the operator is Exists or DoesNotExist,\nthe values array must be empty. If
    the operator is Gt or Lt, the values\narray must have a single element, which
    will be interpreted as an integer.\nThis array is replaced during a strategic
    merge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchFields":{"description":"A
    list of node selector requirements by node''s fields.","items":{"description":"A
    node selector requirement is a selector that contains values, a key, and an operator\nthat
    relates the key and values.","properties":{"key":{"description":"The label key
    that the selector applies to.","type":"string"},"operator":{"description":"Represents
    a key''s relationship to a set of values.\nValid operators are In, NotIn, Exists,
    DoesNotExist. Gt, and Lt.","type":"string"},"values":{"description":"An array
    of string values. If the operator is In or NotIn,\nthe values array must be non-empty.
    If the operator is Exists or DoesNotExist,\nthe values array must be empty. If
    the operator is Gt or Lt, the values\narray must have a single element, which
    will be interpreted as an integer.\nThis array is replaced during a strategic
    merge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"}},"type":"object","x-kubernetes-map-type":"atomic"},"weight":{"description":"Weight
    associated with matching the corresponding nodeSelectorTerm, in the range 1-100.","format":"int32","type":"integer"}},"required":["preference","weight"],"type":"object"},"type":"array"},"requiredDuringSchedulingIgnoredDuringExecution":{"description":"If
    the affinity requirements specified by this field are not met at\nscheduling time,
    the pod will not be scheduled onto the node.\nIf the affinity requirements specified
    by this field cease to be met\nat some point during pod execution (e.g. due to
    an update), the system\nmay or may not try to eventually evict the pod from its
    node.","properties":{"nodeSelectorTerms":{"description":"Required. A list of node
    selector terms. The terms are ORed.","items":{"description":"A null or empty node
    selector term matches no objects. The requirements of\nthem are ANDed.\nThe TopologySelectorTerm
    type implements a subset of the NodeSelectorTerm.","properties":{"matchExpressions":{"description":"A
    list of node selector requirements by node''s labels.","items":{"description":"A
    node selector requirement is a selector that contains values, a key, and an operator\nthat
    relates the key and values.","properties":{"key":{"description":"The label key
    that the selector applies to.","type":"string"},"operator":{"description":"Represents
    a key''s relationship to a set of values.\nValid operators are In, NotIn, Exists,
    DoesNotExist. Gt, and Lt.","type":"string"},"values":{"description":"An array
    of string values. If the operator is In or NotIn,\nthe values array must be non-empty.
    If the operator is Exists or DoesNotExist,\nthe values array must be empty. If
    the operator is Gt or Lt, the values\narray must have a single element, which
    will be interpreted as an integer.\nThis array is replaced during a strategic
    merge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchFields":{"description":"A
    list of node selector requirements by node''s fields.","items":{"description":"A
    node selector requirement is a selector that contains values, a key, and an operator\nthat
    relates the key and values.","properties":{"key":{"description":"The label key
    that the selector applies to.","type":"string"},"operator":{"description":"Represents
    a key''s relationship to a set of values.\nValid operators are In, NotIn, Exists,
    DoesNotExist. Gt, and Lt.","type":"string"},"values":{"description":"An array
    of string values. If the operator is In or NotIn,\nthe values array must be non-empty.
    If the operator is Exists or DoesNotExist,\nthe values array must be empty. If
    the operator is Gt or Lt, the values\narray must have a single element, which
    will be interpreted as an integer.\nThis array is replaced during a strategic
    merge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"}},"type":"object","x-kubernetes-map-type":"atomic"},"type":"array"}},"required":["nodeSelectorTerms"],"type":"object","x-kubernetes-map-type":"atomic"}},"type":"object"},"podAffinity":{"description":"Describes
    pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone,
    etc. as some other pod(s)).","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"description":"The
    scheduler will prefer to schedule pods to nodes that satisfy\nthe affinity expressions
    specified by this field, but it may choose\na node that violates one or more of
    the expressions. The node that is\nmost preferred is the one with the greatest
    sum of weights, i.e.\nfor each node that meets all of the scheduling requirements
    (resource\nrequest, requiredDuringScheduling affinity expressions, etc.),\ncompute
    a sum by iterating through the elements of this field and adding\n\"weight\" to
    the sum if the node has pods which matches the corresponding podAffinityTerm;
    the\nnode(s) with the highest sum are the most preferred.","items":{"description":"The
    weights of all of the matched WeightedPodAffinityTerm fields are added per-node
    to find the most preferred node(s)","properties":{"podAffinityTerm":{"description":"Required.
    A pod affinity term, associated with the corresponding weight.","properties":{"labelSelector":{"description":"A
    label query over a set of resources, in this case pods.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaceSelector":{"description":"A
    label query over the set of namespaces that the term applies to.\nThe term is
    applied to the union of the namespaces selected by this field\nand the ones listed
    in the namespaces field.\nnull selector and null or empty namespaces list means
    \"this pod''s namespace\".\nAn empty selector ({}) matches all namespaces.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaces":{"description":"namespaces
    specifies a static list of namespace names that the term applies to.\nThe term
    is applied to the union of the namespaces listed in this field\nand the ones selected
    by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector
    means \"this pod''s namespace\".","items":{"type":"string"},"type":"array"},"topologyKey":{"description":"This
    pod should be co-located (affinity) or not co-located (anti-affinity) with the
    pods matching\nthe labelSelector in the specified namespaces, where co-located
    is defined as running on a node\nwhose value of the label with key topologyKey
    matches that of any node on which any of the\nselected pods is running.\nEmpty
    topologyKey is not allowed.","type":"string"}},"required":["topologyKey"],"type":"object"},"weight":{"description":"weight
    associated with matching the corresponding podAffinityTerm,\nin the range 1-100.","format":"int32","type":"integer"}},"required":["podAffinityTerm","weight"],"type":"object"},"type":"array"},"requiredDuringSchedulingIgnoredDuringExecution":{"description":"If
    the affinity requirements specified by this field are not met at\nscheduling time,
    the pod will not be scheduled onto the node.\nIf the affinity requirements specified
    by this field cease to be met\nat some point during pod execution (e.g. due to
    a pod label update), the\nsystem may or may not try to eventually evict the pod
    from its node.\nWhen there are multiple elements, the lists of nodes corresponding
    to each\npodAffinityTerm are intersected, i.e. all terms must be satisfied.","items":{"description":"Defines
    a set of pods (namely those matching the labelSelector\nrelative to the given
    namespace(s)) that this pod should be\nco-located (affinity) or not co-located
    (anti-affinity) with,\nwhere co-located is defined as running on a node whose
    value of\nthe label with key <topologyKey> matches that of any node on which\na
    pod of the set of pods is running","properties":{"labelSelector":{"description":"A
    label query over a set of resources, in this case pods.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaceSelector":{"description":"A
    label query over the set of namespaces that the term applies to.\nThe term is
    applied to the union of the namespaces selected by this field\nand the ones listed
    in the namespaces field.\nnull selector and null or empty namespaces list means
    \"this pod''s namespace\".\nAn empty selector ({}) matches all namespaces.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaces":{"description":"namespaces
    specifies a static list of namespace names that the term applies to.\nThe term
    is applied to the union of the namespaces listed in this field\nand the ones selected
    by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector
    means \"this pod''s namespace\".","items":{"type":"string"},"type":"array"},"topologyKey":{"description":"This
    pod should be co-located (affinity) or not co-located (anti-affinity) with the
    pods matching\nthe labelSelector in the specified namespaces, where co-located
    is defined as running on a node\nwhose value of the label with key topologyKey
    matches that of any node on which any of the\nselected pods is running.\nEmpty
    topologyKey is not allowed.","type":"string"}},"required":["topologyKey"],"type":"object"},"type":"array"}},"type":"object"},"podAntiAffinity":{"description":"Describes
    pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node,
    zone, etc. as some other pod(s)).","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"description":"The
    scheduler will prefer to schedule pods to nodes that satisfy\nthe anti-affinity
    expressions specified by this field, but it may choose\na node that violates one
    or more of the expressions. The node that is\nmost preferred is the one with the
    greatest sum of weights, i.e.\nfor each node that meets all of the scheduling
    requirements (resource\nrequest, requiredDuringScheduling anti-affinity expressions,
    etc.),\ncompute a sum by iterating through the elements of this field and adding\n\"weight\"
    to the sum if the node has pods which matches the corresponding podAffinityTerm;
    the\nnode(s) with the highest sum are the most preferred.","items":{"description":"The
    weights of all of the matched WeightedPodAffinityTerm fields are added per-node
    to find the most preferred node(s)","properties":{"podAffinityTerm":{"description":"Required.
    A pod affinity term, associated with the corresponding weight.","properties":{"labelSelector":{"description":"A
    label query over a set of resources, in this case pods.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaceSelector":{"description":"A
    label query over the set of namespaces that the term applies to.\nThe term is
    applied to the union of the namespaces selected by this field\nand the ones listed
    in the namespaces field.\nnull selector and null or empty namespaces list means
    \"this pod''s namespace\".\nAn empty selector ({}) matches all namespaces.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaces":{"description":"namespaces
    specifies a static list of namespace names that the term applies to.\nThe term
    is applied to the union of the namespaces listed in this field\nand the ones selected
    by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector
    means \"this pod''s namespace\".","items":{"type":"string"},"type":"array"},"topologyKey":{"description":"This
    pod should be co-located (affinity) or not co-located (anti-affinity) with the
    pods matching\nthe labelSelector in the specified namespaces, where co-located
    is defined as running on a node\nwhose value of the label with key topologyKey
    matches that of any node on which any of the\nselected pods is running.\nEmpty
    topologyKey is not allowed.","type":"string"}},"required":["topologyKey"],"type":"object"},"weight":{"description":"weight
    associated with matching the corresponding podAffinityTerm,\nin the range 1-100.","format":"int32","type":"integer"}},"required":["podAffinityTerm","weight"],"type":"object"},"type":"array"},"requiredDuringSchedulingIgnoredDuringExecution":{"description":"If
    the anti-affinity requirements specified by this field are not met at\nscheduling
    time, the pod will not be scheduled onto the node.\nIf the anti-affinity requirements
    specified by this field cease to be met\nat some point during pod execution (e.g.
    due to a pod label update), the\nsystem may or may not try to eventually evict
    the pod from its node.\nWhen there are multiple elements, the lists of nodes corresponding
    to each\npodAffinityTerm are intersected, i.e. all terms must be satisfied.","items":{"description":"Defines
    a set of pods (namely those matching the labelSelector\nrelative to the given
    namespace(s)) that this pod should be\nco-located (affinity) or not co-located
    (anti-affinity) with,\nwhere co-located is defined as running on a node whose
    value of\nthe label with key <topologyKey> matches that of any node on which\na
    pod of the set of pods is running","properties":{"labelSelector":{"description":"A
    label query over a set of resources, in this case pods.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaceSelector":{"description":"A
    label query over the set of namespaces that the term applies to.\nThe term is
    applied to the union of the namespaces selected by this field\nand the ones listed
    in the namespaces field.\nnull selector and null or empty namespaces list means
    \"this pod''s namespace\".\nAn empty selector ({}) matches all namespaces.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaces":{"description":"namespaces
    specifies a static list of namespace names that the term applies to.\nThe term
    is applied to the union of the namespaces listed in this field\nand the ones selected
    by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector
    means \"this pod''s namespace\".","items":{"type":"string"},"type":"array"},"topologyKey":{"description":"This
    pod should be co-located (affinity) or not co-located (anti-affinity) with the
    pods matching\nthe labelSelector in the specified namespaces, where co-located
    is defined as running on a node\nwhose value of the label with key topologyKey
    matches that of any node on which any of the\nselected pods is running.\nEmpty
    topologyKey is not allowed.","type":"string"}},"required":["topologyKey"],"type":"object"},"type":"array"}},"type":"object"}},"type":"object"},"containers":{"description":"Containers
    is a list of calico-windows-upgrade containers.\nIf specified, this overrides
    the specified calico-windows-upgrade DaemonSet containers.\nIf omitted, the calico-windows-upgrade
    DaemonSet will use its default values for its containers.","items":{"description":"CalicoWindowsUpgradeDaemonSetContainer
    is a calico-windows-upgrade DaemonSet container.","properties":{"name":{"description":"Name
    is an enum which identifies the calico-windows-upgrade DaemonSet container by
    name.","enum":["calico-windows-upgrade"],"type":"string"},"resources":{"description":"Resources
    allows customization of limits and requests for compute resources such as cpu
    and memory.\nIf specified, this overrides the named calico-windows-upgrade DaemonSet
    container''s resources.\nIf omitted, the calico-windows-upgrade DaemonSet will
    use its default value for this container''s resources.","properties":{"claims":{"description":"Claims
    lists the names of resources, defined in spec.resourceClaims,\nthat are used by
    this container.\nThis is an alpha field and requires enabling the\nDynamicResourceAllocation
    feature gate.\nThis field is immutable. It can only be set for containers.","items":{"description":"ResourceClaim
    references one entry in PodSpec.ResourceClaims.","properties":{"name":{"description":"Name
    must match the name of one entry in pod.spec.resourceClaims of\nthe Pod where
    this field is used. It makes that resource available\ninside a container.","type":"string"}},"required":["name"],"type":"object"},"type":"array","x-kubernetes-list-map-keys":["name"],"x-kubernetes-list-type":"map"},"limits":{"additionalProperties":{"anyOf":[{"type":"integer"},{"type":"string"}],"pattern":"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$","x-kubernetes-int-or-string":true},"description":"Limits
    describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/","type":"object"},"requests":{"additionalProperties":{"anyOf":[{"type":"integer"},{"type":"string"}],"pattern":"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$","x-kubernetes-int-or-string":true},"description":"Requests
    describes the minimum amount of compute resources required.\nIf Requests is omitted
    for a container, it defaults to Limits if that is explicitly specified,\notherwise
    to an implementation-defined value. Requests cannot exceed Limits.\nMore info:
    https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/","type":"object"}},"type":"object"}},"required":["name"],"type":"object"},"type":"array"},"nodeSelector":{"additionalProperties":{"type":"string"},"description":"NodeSelector
    is the calico-windows-upgrade pod''s scheduling constraints.\nIf specified, each
    of the key/value pairs are added to the calico-windows-upgrade DaemonSet nodeSelector
    provided\nthe key does not already exist in the object''s nodeSelector.\nIf omitted,
    the calico-windows-upgrade DaemonSet will use its default value for nodeSelector.\nWARNING:
    Please note that this field will modify the default calico-windows-upgrade DaemonSet
    nodeSelector.","type":"object"},"tolerations":{"description":"Tolerations is the
    calico-windows-upgrade pod''s tolerations.\nIf specified, this overrides any tolerations
    that may be set on the calico-windows-upgrade DaemonSet.\nIf omitted, the calico-windows-upgrade
    DaemonSet will use its default value for tolerations.\nWARNING: Please note that
    this field will override the default calico-windows-upgrade DaemonSet tolerations.","items":{"description":"The
    pod this Toleration is attached to tolerates any taint that matches\nthe triple
    <key,value,effect> using the matching operator <operator>.","properties":{"effect":{"description":"Effect
    indicates the taint effect to match. Empty means match all taint effects.\nWhen
    specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.","type":"string"},"key":{"description":"Key
    is the taint key that the toleration applies to. Empty means match all taint keys.\nIf
    the key is empty, operator must be Exists; this combination means to match all
    values and all keys.","type":"string"},"operator":{"description":"Operator represents
    a key''s relationship to the value.\nValid operators are Exists and Equal. Defaults
    to Equal.\nExists is equivalent to wildcard for value, so that a pod can\ntolerate
    all taints of a particular category.","type":"string"},"tolerationSeconds":{"description":"TolerationSeconds
    represents the period of time the toleration (which must be\nof effect NoExecute,
    otherwise this field is ignored) tolerates the taint. By default,\nit is not set,
    which means tolerate the taint forever (do not evict). Zero and\nnegative values
    will be treated as 0 (evict immediately) by the system.","format":"int64","type":"integer"},"value":{"description":"Value
    is the taint value the toleration matches to.\nIf the operator is Exists, the
    value should be empty, otherwise just a regular string.","type":"string"}},"type":"object"},"type":"array"}},"type":"object"}},"type":"object"}},"type":"object"}},"type":"object"},"certificateManagement":{"description":"CertificateManagement
    configures pods to submit a CertificateSigningRequest to the certificates.k8s.io/v1beta1
    API in order\nto obtain TLS certificates. This feature requires that you bring
    your own CSR signing and approval process, otherwise\npods will be stuck during
    initialization.","properties":{"caCert":{"description":"Certificate of the authority
    that signs the CertificateSigningRequests in PEM format.","format":"byte","type":"string"},"keyAlgorithm":{"description":"Specify
    the algorithm used by pods to generate a key pair that is associated with the
    X.509 certificate request.\nDefault: RSAWithSize2048","enum":["","RSAWithSize2048","RSAWithSize4096","RSAWithSize8192","ECDSAWithCurve256","ECDSAWithCurve384","ECDSAWithCurve521"],"type":"string"},"signatureAlgorithm":{"description":"Specify
    the algorithm used for the signature of the X.509 certificate request.\nDefault:
    SHA256WithRSA","enum":["","SHA256WithRSA","SHA384WithRSA","SHA512WithRSA","ECDSAWithSHA256","ECDSAWithSHA384","ECDSAWithSHA512"],"type":"string"},"signerName":{"description":"When
    a CSR is issued to the certificates.k8s.io API, the signerName is added to the
    request in order to accommodate for clusters\nwith multiple signers.\nMust be
    formatted as: `<my-domain>/<my-signername>`.","type":"string"}},"required":["caCert","signerName"],"type":"object"},"cni":{"description":"CNI
    specifies the CNI that will be used by this installation.","properties":{"ipam":{"description":"IPAM
    specifies the pod IP address management that will be used in the Calico or\nCalico
    Enterprise installation.","properties":{"type":{"description":"Specifies the IPAM
    plugin that will be used in the Calico or Calico Enterprise installation.\n* For
    CNI Plugin Calico, this field defaults to Calico.\n* For CNI Plugin GKE, this
    field defaults to HostLocal.\n* For CNI Plugin AzureVNET, this field defaults
    to AzureVNET.\n* For CNI Plugin AmazonVPC, this field defaults to AmazonVPC.\nThe
    IPAM plugin is installed and configured only if the CNI plugin is set to Calico,\nfor
    all other values of the CNI plugin the plugin binaries and CNI config is a dependency\nthat
    is expected to be installed separately.\nDefault: Calico","enum":["Calico","HostLocal","AmazonVPC","AzureVNET"],"type":"string"}},"required":["type"],"type":"object"},"type":{"description":"Specifies
    the CNI plugin that will be used in the Calico or Calico Enterprise installation.\n*
    For KubernetesProvider GKE, this field defaults to GKE.\n* For KubernetesProvider
    AKS, this field defaults to AzureVNET.\n* For KubernetesProvider EKS, this field
    defaults to AmazonVPC.\n* If aws-node daemonset exists in kube-system when the
    Installation resource is created, this field defaults to AmazonVPC.\n* For all
    other cases this field defaults to Calico.\nFor the value Calico, the CNI plugin
    binaries and CNI config will be installed as part of deployment,\nfor all other
    values the CNI plugin binaries and CNI config is a dependency that is expected\nto
    be installed separately.\nDefault: Calico","enum":["Calico","GKE","AmazonVPC","AzureVNET"],"type":"string"}},"required":["type"],"type":"object"},"componentResources":{"description":"Deprecated.
    Please use CalicoNodeDaemonSet, TyphaDeployment, and KubeControllersDeployment.\nComponentResources
    can be used to customize the resource requirements for each component.\nNode,
    Typha, and KubeControllers are supported for installations.","items":{"description":"Deprecated.
    Please use component resource config fields in Installation.Spec instead.\nThe
    ComponentResource struct associates a ResourceRequirements with a component by
    name","properties":{"componentName":{"description":"ComponentName is an enum which
    identifies the component","enum":["Node","Typha","KubeControllers"],"type":"string"},"resourceRequirements":{"description":"ResourceRequirements
    allows customization of limits and requests for compute resources such as cpu
    and memory.","properties":{"claims":{"description":"Claims lists the names of
    resources, defined in spec.resourceClaims,\nthat are used by this container.\nThis
    is an alpha field and requires enabling the\nDynamicResourceAllocation feature
    gate.\nThis field is immutable. It can only be set for containers.","items":{"description":"ResourceClaim
    references one entry in PodSpec.ResourceClaims.","properties":{"name":{"description":"Name
    must match the name of one entry in pod.spec.resourceClaims of\nthe Pod where
    this field is used. It makes that resource available\ninside a container.","type":"string"}},"required":["name"],"type":"object"},"type":"array","x-kubernetes-list-map-keys":["name"],"x-kubernetes-list-type":"map"},"limits":{"additionalProperties":{"anyOf":[{"type":"integer"},{"type":"string"}],"pattern":"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$","x-kubernetes-int-or-string":true},"description":"Limits
    describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/","type":"object"},"requests":{"additionalProperties":{"anyOf":[{"type":"integer"},{"type":"string"}],"pattern":"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$","x-kubernetes-int-or-string":true},"description":"Requests
    describes the minimum amount of compute resources required.\nIf Requests is omitted
    for a container, it defaults to Limits if that is explicitly specified,\notherwise
    to an implementation-defined value. Requests cannot exceed Limits.\nMore info:
    https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/","type":"object"}},"type":"object"}},"required":["componentName","resourceRequirements"],"type":"object"},"type":"array"},"controlPlaneNodeSelector":{"additionalProperties":{"type":"string"},"description":"ControlPlaneNodeSelector
    is used to select control plane nodes on which to run Calico\ncomponents. This
    is globally applied to all resources created by the operator excluding daemonsets.","type":"object"},"controlPlaneReplicas":{"description":"ControlPlaneReplicas
    defines how many replicas of the control plane core components will be deployed.\nThis
    field applies to all control plane components that support High Availability.
    Defaults to 2.","format":"int32","type":"integer"},"controlPlaneTolerations":{"description":"ControlPlaneTolerations
    specify tolerations which are then globally applied to all resources\ncreated
    by the operator.","items":{"description":"The pod this Toleration is attached
    to tolerates any taint that matches\nthe triple <key,value,effect> using the matching
    operator <operator>.","properties":{"effect":{"description":"Effect indicates
    the taint effect to match. Empty means match all taint effects.\nWhen specified,
    allowed values are NoSchedule, PreferNoSchedule and NoExecute.","type":"string"},"key":{"description":"Key
    is the taint key that the toleration applies to. Empty means match all taint keys.\nIf
    the key is empty, operator must be Exists; this combination means to match all
    values and all keys.","type":"string"},"operator":{"description":"Operator represents
    a key''s relationship to the value.\nValid operators are Exists and Equal. Defaults
    to Equal.\nExists is equivalent to wildcard for value, so that a pod can\ntolerate
    all taints of a particular category.","type":"string"},"tolerationSeconds":{"description":"TolerationSeconds
    represents the period of time the toleration (which must be\nof effect NoExecute,
    otherwise this field is ignored) tolerates the taint. By default,\nit is not set,
    which means tolerate the taint forever (do not evict). Zero and\nnegative values
    will be treated as 0 (evict immediately) by the system.","format":"int64","type":"integer"},"value":{"description":"Value
    is the taint value the toleration matches to.\nIf the operator is Exists, the
    value should be empty, otherwise just a regular string.","type":"string"}},"type":"object"},"type":"array"},"csiNodeDriverDaemonSet":{"description":"CSINodeDriverDaemonSet
    configures the csi-node-driver DaemonSet.","properties":{"metadata":{"description":"Metadata
    is a subset of a Kubernetes object''s metadata that is added to the DaemonSet.","properties":{"annotations":{"additionalProperties":{"type":"string"},"description":"Annotations
    is a map of arbitrary non-identifying metadata. Each of these\nkey/value pairs
    are added to the object''s annotations provided the key does not\nalready exist
    in the object''s annotations.","type":"object"},"labels":{"additionalProperties":{"type":"string"},"description":"Labels
    is a map of string keys and values that may match replicaset and\nservice selectors.
    Each of these key/value pairs are added to the\nobject''s labels provided the
    key does not already exist in the object''s labels.","type":"object"}},"type":"object"},"spec":{"description":"Spec
    is the specification of the csi-node-driver DaemonSet.","properties":{"minReadySeconds":{"description":"MinReadySeconds
    is the minimum number of seconds for which a newly created DaemonSet pod should\nbe
    ready without any of its container crashing, for it to be considered available.\nIf
    specified, this overrides any minReadySeconds value that may be set on the csi-node-driver
    DaemonSet.\nIf omitted, the csi-node-driver DaemonSet will use its default value
    for minReadySeconds.","format":"int32","maximum":2147483647,"minimum":0,"type":"integer"},"template":{"description":"Template
    describes the csi-node-driver DaemonSet pod that will be created.","properties":{"metadata":{"description":"Metadata
    is a subset of a Kubernetes object''s metadata that is added to\nthe pod''s metadata.","properties":{"annotations":{"additionalProperties":{"type":"string"},"description":"Annotations
    is a map of arbitrary non-identifying metadata. Each of these\nkey/value pairs
    are added to the object''s annotations provided the key does not\nalready exist
    in the object''s annotations.","type":"object"},"labels":{"additionalProperties":{"type":"string"},"description":"Labels
    is a map of string keys and values that may match replicaset and\nservice selectors.
    Each of these key/value pairs are added to the\nobject''s labels provided the
    key does not already exist in the object''s labels.","type":"object"}},"type":"object"},"spec":{"description":"Spec
    is the csi-node-driver DaemonSet''s PodSpec.","properties":{"affinity":{"description":"Affinity
    is a group of affinity scheduling rules for the csi-node-driver pods.\nIf specified,
    this overrides any affinity that may be set on the csi-node-driver DaemonSet.\nIf
    omitted, the csi-node-driver DaemonSet will use its default value for affinity.\nWARNING:
    Please note that this field will override the default csi-node-driver DaemonSet
    affinity.","properties":{"nodeAffinity":{"description":"Describes node affinity
    scheduling rules for the pod.","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"description":"The
    scheduler will prefer to schedule pods to nodes that satisfy\nthe affinity expressions
    specified by this field, but it may choose\na node that violates one or more of
    the expressions. The node that is\nmost preferred is the one with the greatest
    sum of weights, i.e.\nfor each node that meets all of the scheduling requirements
    (resource\nrequest, requiredDuringScheduling affinity expressions, etc.),\ncompute
    a sum by iterating through the elements of this field and adding\n\"weight\" to
    the sum if the node matches the corresponding matchExpressions; the\nnode(s) with
    the highest sum are the most preferred.","items":{"description":"An empty preferred
    scheduling term matches all objects with implicit weight 0\n(i.e. it''s a no-op).
    A null preferred scheduling term matches no objects (i.e. is also a no-op).","properties":{"preference":{"description":"A
    node selector term, associated with the corresponding weight.","properties":{"matchExpressions":{"description":"A
    list of node selector requirements by node''s labels.","items":{"description":"A
    node selector requirement is a selector that contains values, a key, and an operator\nthat
    relates the key and values.","properties":{"key":{"description":"The label key
    that the selector applies to.","type":"string"},"operator":{"description":"Represents
    a key''s relationship to a set of values.\nValid operators are In, NotIn, Exists,
    DoesNotExist. Gt, and Lt.","type":"string"},"values":{"description":"An array
    of string values. If the operator is In or NotIn,\nthe values array must be non-empty.
    If the operator is Exists or DoesNotExist,\nthe values array must be empty. If
    the operator is Gt or Lt, the values\narray must have a single element, which
    will be interpreted as an integer.\nThis array is replaced during a strategic
    merge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchFields":{"description":"A
    list of node selector requirements by node''s fields.","items":{"description":"A
    node selector requirement is a selector that contains values, a key, and an operator\nthat
    relates the key and values.","properties":{"key":{"description":"The label key
    that the selector applies to.","type":"string"},"operator":{"description":"Represents
    a key''s relationship to a set of values.\nValid operators are In, NotIn, Exists,
    DoesNotExist. Gt, and Lt.","type":"string"},"values":{"description":"An array
    of string values. If the operator is In or NotIn,\nthe values array must be non-empty.
    If the operator is Exists or DoesNotExist,\nthe values array must be empty. If
    the operator is Gt or Lt, the values\narray must have a single element, which
    will be interpreted as an integer.\nThis array is replaced during a strategic
    merge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"}},"type":"object","x-kubernetes-map-type":"atomic"},"weight":{"description":"Weight
    associated with matching the corresponding nodeSelectorTerm, in the range 1-100.","format":"int32","type":"integer"}},"required":["preference","weight"],"type":"object"},"type":"array"},"requiredDuringSchedulingIgnoredDuringExecution":{"description":"If
    the affinity requirements specified by this field are not met at\nscheduling time,
    the pod will not be scheduled onto the node.\nIf the affinity requirements specified
    by this field cease to be met\nat some point during pod execution (e.g. due to
    an update), the system\nmay or may not try to eventually evict the pod from its
    node.","properties":{"nodeSelectorTerms":{"description":"Required. A list of node
    selector terms. The terms are ORed.","items":{"description":"A null or empty node
    selector term matches no objects. The requirements of\nthem are ANDed.\nThe TopologySelectorTerm
    type implements a subset of the NodeSelectorTerm.","properties":{"matchExpressions":{"description":"A
    list of node selector requirements by node''s labels.","items":{"description":"A
    node selector requirement is a selector that contains values, a key, and an operator\nthat
    relates the key and values.","properties":{"key":{"description":"The label key
    that the selector applies to.","type":"string"},"operator":{"description":"Represents
    a key''s relationship to a set of values.\nValid operators are In, NotIn, Exists,
    DoesNotExist. Gt, and Lt.","type":"string"},"values":{"description":"An array
    of string values. If the operator is In or NotIn,\nthe values array must be non-empty.
    If the operator is Exists or DoesNotExist,\nthe values array must be empty. If
    the operator is Gt or Lt, the values\narray must have a single element, which
    will be interpreted as an integer.\nThis array is replaced during a strategic
    merge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchFields":{"description":"A
    list of node selector requirements by node''s fields.","items":{"description":"A
    node selector requirement is a selector that contains values, a key, and an operator\nthat
    relates the key and values.","properties":{"key":{"description":"The label key
    that the selector applies to.","type":"string"},"operator":{"description":"Represents
    a key''s relationship to a set of values.\nValid operators are In, NotIn, Exists,
    DoesNotExist. Gt, and Lt.","type":"string"},"values":{"description":"An array
    of string values. If the operator is In or NotIn,\nthe values array must be non-empty.
    If the operator is Exists or DoesNotExist,\nthe values array must be empty. If
    the operator is Gt or Lt, the values\narray must have a single element, which
    will be interpreted as an integer.\nThis array is replaced during a strategic
    merge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"}},"type":"object","x-kubernetes-map-type":"atomic"},"type":"array"}},"required":["nodeSelectorTerms"],"type":"object","x-kubernetes-map-type":"atomic"}},"type":"object"},"podAffinity":{"description":"Describes
    pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone,
    etc. as some other pod(s)).","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"description":"The
    scheduler will prefer to schedule pods to nodes that satisfy\nthe affinity expressions
    specified by this field, but it may choose\na node that violates one or more of
    the expressions. The node that is\nmost preferred is the one with the greatest
    sum of weights, i.e.\nfor each node that meets all of the scheduling requirements
    (resource\nrequest, requiredDuringScheduling affinity expressions, etc.),\ncompute
    a sum by iterating through the elements of this field and adding\n\"weight\" to
    the sum if the node has pods which matches the corresponding podAffinityTerm;
    the\nnode(s) with the highest sum are the most preferred.","items":{"description":"The
    weights of all of the matched WeightedPodAffinityTerm fields are added per-node
    to find the most preferred node(s)","properties":{"podAffinityTerm":{"description":"Required.
    A pod affinity term, associated with the corresponding weight.","properties":{"labelSelector":{"description":"A
    label query over a set of resources, in this case pods.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaceSelector":{"description":"A
    label query over the set of namespaces that the term applies to.\nThe term is
    applied to the union of the namespaces selected by this field\nand the ones listed
    in the namespaces field.\nnull selector and null or empty namespaces list means
    \"this pod''s namespace\".\nAn empty selector ({}) matches all namespaces.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaces":{"description":"namespaces
    specifies a static list of namespace names that the term applies to.\nThe term
    is applied to the union of the namespaces listed in this field\nand the ones selected
    by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector
    means \"this pod''s namespace\".","items":{"type":"string"},"type":"array"},"topologyKey":{"description":"This
    pod should be co-located (affinity) or not co-located (anti-affinity) with the
    pods matching\nthe labelSelector in the specified namespaces, where co-located
    is defined as running on a node\nwhose value of the label with key topologyKey
    matches that of any node on which any of the\nselected pods is running.\nEmpty
    topologyKey is not allowed.","type":"string"}},"required":["topologyKey"],"type":"object"},"weight":{"description":"weight
    associated with matching the corresponding podAffinityTerm,\nin the range 1-100.","format":"int32","type":"integer"}},"required":["podAffinityTerm","weight"],"type":"object"},"type":"array"},"requiredDuringSchedulingIgnoredDuringExecution":{"description":"If
    the affinity requirements specified by this field are not met at\nscheduling time,
    the pod will not be scheduled onto the node.\nIf the affinity requirements specified
    by this field cease to be met\nat some point during pod execution (e.g. due to
    a pod label update), the\nsystem may or may not try to eventually evict the pod
    from its node.\nWhen there are multiple elements, the lists of nodes corresponding
    to each\npodAffinityTerm are intersected, i.e. all terms must be satisfied.","items":{"description":"Defines
    a set of pods (namely those matching the labelSelector\nrelative to the given
    namespace(s)) that this pod should be\nco-located (affinity) or not co-located
    (anti-affinity) with,\nwhere co-located is defined as running on a node whose
    value of\nthe label with key <topologyKey> matches that of any node on which\na
    pod of the set of pods is running","properties":{"labelSelector":{"description":"A
    label query over a set of resources, in this case pods.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaceSelector":{"description":"A
    label query over the set of namespaces that the term applies to.\nThe term is
    applied to the union of the namespaces selected by this field\nand the ones listed
    in the namespaces field.\nnull selector and null or empty namespaces list means
    \"this pod''s namespace\".\nAn empty selector ({}) matches all namespaces.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaces":{"description":"namespaces
    specifies a static list of namespace names that the term applies to.\nThe term
    is applied to the union of the namespaces listed in this field\nand the ones selected
    by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector
    means \"this pod''s namespace\".","items":{"type":"string"},"type":"array"},"topologyKey":{"description":"This
    pod should be co-located (affinity) or not co-located (anti-affinity) with the
    pods matching\nthe labelSelector in the specified namespaces, where co-located
    is defined as running on a node\nwhose value of the label with key topologyKey
    matches that of any node on which any of the\nselected pods is running.\nEmpty
    topologyKey is not allowed.","type":"string"}},"required":["topologyKey"],"type":"object"},"type":"array"}},"type":"object"},"podAntiAffinity":{"description":"Describes
    pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node,
    zone, etc. as some other pod(s)).","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"description":"The
    scheduler will prefer to schedule pods to nodes that satisfy\nthe anti-affinity
    expressions specified by this field, but it may choose\na node that violates one
    or more of the expressions. The node that is\nmost preferred is the one with the
    greatest sum of weights, i.e.\nfor each node that meets all of the scheduling
    requirements (resource\nrequest, requiredDuringScheduling anti-affinity expressions,
    etc.),\ncompute a sum by iterating through the elements of this field and adding\n\"weight\"
    to the sum if the node has pods which matches the corresponding podAffinityTerm;
    the\nnode(s) with the highest sum are the most preferred.","items":{"description":"The
    weights of all of the matched WeightedPodAffinityTerm fields are added per-node
    to find the most preferred node(s)","properties":{"podAffinityTerm":{"description":"Required.
    A pod affinity term, associated with the corresponding weight.","properties":{"labelSelector":{"description":"A
    label query over a set of resources, in this case pods.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaceSelector":{"description":"A
    label query over the set of namespaces that the term applies to.\nThe term is
    applied to the union of the namespaces selected by this field\nand the ones listed
    in the namespaces field.\nnull selector and null or empty namespaces list means
    \"this pod''s namespace\".\nAn empty selector ({}) matches all namespaces.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaces":{"description":"namespaces
    specifies a static list of namespace names that the term applies to.\nThe term
    is applied to the union of the namespaces listed in this field\nand the ones selected
    by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector
    means \"this pod''s namespace\".","items":{"type":"string"},"type":"array"},"topologyKey":{"description":"This
    pod should be co-located (affinity) or not co-located (anti-affinity) with the
    pods matching\nthe labelSelector in the specified namespaces, where co-located
    is defined as running on a node\nwhose value of the label with key topologyKey
    matches that of any node on which any of the\nselected pods is running.\nEmpty
    topologyKey is not allowed.","type":"string"}},"required":["topologyKey"],"type":"object"},"weight":{"description":"weight
    associated with matching the corresponding podAffinityTerm,\nin the range 1-100.","format":"int32","type":"integer"}},"required":["podAffinityTerm","weight"],"type":"object"},"type":"array"},"requiredDuringSchedulingIgnoredDuringExecution":{"description":"If
    the anti-affinity requirements specified by this field are not met at\nscheduling
    time, the pod will not be scheduled onto the node.\nIf the anti-affinity requirements
    specified by this field cease to be met\nat some point during pod execution (e.g.
    due to a pod label update), the\nsystem may or may not try to eventually evict
    the pod from its node.\nWhen there are multiple elements, the lists of nodes corresponding
    to each\npodAffinityTerm are intersected, i.e. all terms must be satisfied.","items":{"description":"Defines
    a set of pods (namely those matching the labelSelector\nrelative to the given
    namespace(s)) that this pod should be\nco-located (affinity) or not co-located
    (anti-affinity) with,\nwhere co-located is defined as running on a node whose
    value of\nthe label with key <topologyKey> matches that of any node on which\na
    pod of the set of pods is running","properties":{"labelSelector":{"description":"A
    label query over a set of resources, in this case pods.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaceSelector":{"description":"A
    label query over the set of namespaces that the term applies to.\nThe term is
    applied to the union of the namespaces selected by this field\nand the ones listed
    in the namespaces field.\nnull selector and null or empty namespaces list means
    \"this pod''s namespace\".\nAn empty selector ({}) matches all namespaces.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaces":{"description":"namespaces
    specifies a static list of namespace names that the term applies to.\nThe term
    is applied to the union of the namespaces listed in this field\nand the ones selected
    by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector
    means \"this pod''s namespace\".","items":{"type":"string"},"type":"array"},"topologyKey":{"description":"This
    pod should be co-located (affinity) or not co-located (anti-affinity) with the
    pods matching\nthe labelSelector in the specified namespaces, where co-located
    is defined as running on a node\nwhose value of the label with key topologyKey
    matches that of any node on which any of the\nselected pods is running.\nEmpty
    topologyKey is not allowed.","type":"string"}},"required":["topologyKey"],"type":"object"},"type":"array"}},"type":"object"}},"type":"object"},"containers":{"description":"Containers
    is a list of csi-node-driver containers.\nIf specified, this overrides the specified
    csi-node-driver DaemonSet containers.\nIf omitted, the csi-node-driver DaemonSet
    will use its default values for its containers.","items":{"description":"CSINodeDriverDaemonSetContainer
    is a csi-node-driver DaemonSet container.","properties":{"name":{"description":"Name
    is an enum which identifies the csi-node-driver DaemonSet container by name.\nSupported
    values are: calico-csi, csi-node-driver-registrar.","enum":["calico-csi","csi-node-driver-registrar","csi-node-driver"],"type":"string"},"resources":{"description":"Resources
    allows customization of limits and requests for compute resources such as cpu
    and memory.\nIf specified, this overrides the named csi-node-driver DaemonSet
    container''s resources.\nIf omitted, the csi-node-driver DaemonSet will use its
    default value for this container''s resources.","properties":{"claims":{"description":"Claims
    lists the names of resources, defined in spec.resourceClaims,\nthat are used by
    this container.\nThis is an alpha field and requires enabling the\nDynamicResourceAllocation
    feature gate.\nThis field is immutable. It can only be set for containers.","items":{"description":"ResourceClaim
    references one entry in PodSpec.ResourceClaims.","properties":{"name":{"description":"Name
    must match the name of one entry in pod.spec.resourceClaims of\nthe Pod where
    this field is used. It makes that resource available\ninside a container.","type":"string"}},"required":["name"],"type":"object"},"type":"array","x-kubernetes-list-map-keys":["name"],"x-kubernetes-list-type":"map"},"limits":{"additionalProperties":{"anyOf":[{"type":"integer"},{"type":"string"}],"pattern":"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$","x-kubernetes-int-or-string":true},"description":"Limits
    describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/","type":"object"},"requests":{"additionalProperties":{"anyOf":[{"type":"integer"},{"type":"string"}],"pattern":"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$","x-kubernetes-int-or-string":true},"description":"Requests
    describes the minimum amount of compute resources required.\nIf Requests is omitted
    for a container, it defaults to Limits if that is explicitly specified,\notherwise
    to an implementation-defined value. Requests cannot exceed Limits.\nMore info:
    https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/","type":"object"}},"type":"object"}},"required":["name"],"type":"object"},"type":"array"},"nodeSelector":{"additionalProperties":{"type":"string"},"description":"NodeSelector
    is the csi-node-driver pod''s scheduling constraints.\nIf specified, each of the
    key/value pairs are added to the csi-node-driver DaemonSet nodeSelector provided\nthe
    key does not already exist in the object''s nodeSelector.\nIf omitted, the csi-node-driver
    DaemonSet will use its default value for nodeSelector.\nWARNING: Please note that
    this field will modify the default csi-node-driver DaemonSet nodeSelector.","type":"object"},"tolerations":{"description":"Tolerations
    is the csi-node-driver pod''s tolerations.\nIf specified, this overrides any tolerations
    that may be set on the csi-node-driver DaemonSet.\nIf omitted, the csi-node-driver
    DaemonSet will use its default value for tolerations.\nWARNING: Please note that
    this field will override the default csi-node-driver DaemonSet tolerations.","items":{"description":"The
    pod this Toleration is attached to tolerates any taint that matches\nthe triple
    <key,value,effect> using the matching operator <operator>.","properties":{"effect":{"description":"Effect
    indicates the taint effect to match. Empty means match all taint effects.\nWhen
    specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.","type":"string"},"key":{"description":"Key
    is the taint key that the toleration applies to. Empty means match all taint keys.\nIf
    the key is empty, operator must be Exists; this combination means to match all
    values and all keys.","type":"string"},"operator":{"description":"Operator represents
    a key''s relationship to the value.\nValid operators are Exists and Equal. Defaults
    to Equal.\nExists is equivalent to wildcard for value, so that a pod can\ntolerate
    all taints of a particular category.","type":"string"},"tolerationSeconds":{"description":"TolerationSeconds
    represents the period of time the toleration (which must be\nof effect NoExecute,
    otherwise this field is ignored) tolerates the taint. By default,\nit is not set,
    which means tolerate the taint forever (do not evict). Zero and\nnegative values
    will be treated as 0 (evict immediately) by the system.","format":"int64","type":"integer"},"value":{"description":"Value
    is the taint value the toleration matches to.\nIf the operator is Exists, the
    value should be empty, otherwise just a regular string.","type":"string"}},"type":"object"},"type":"array"}},"type":"object"}},"type":"object"}},"type":"object"}},"type":"object"},"fipsMode":{"description":"FIPSMode
    uses images and features only that are using FIPS 140-2 validated cryptographic
    modules and standards.\nDefault: Disabled","enum":["Enabled","Disabled"],"type":"string"},"flexVolumePath":{"description":"FlexVolumePath
    optionally specifies a custom path for FlexVolume. If not specified, FlexVolume
    will be\nenabled by default. If set to ''None'', FlexVolume will be disabled.
    The default is based on the\nkubernetesProvider.","type":"string"},"imagePath":{"description":"ImagePath
    allows for the path part of an image to be specified. If specified\nthen the specified
    value will be used as the image path for each image. If not specified\nor empty,
    the default for each image will be used.\nA special case value, UseDefault, is
    supported to explicitly specify the default\nimage path will be used for each
    image.\nImage format:\n   `<registry><imagePath>/<imagePrefix><imageName>:<image-tag>`\nThis
    option allows configuring the `<imagePath>` portion of the above format.","type":"string"},"imagePrefix":{"description":"ImagePrefix
    allows for the prefix part of an image to be specified. If specified\nthen the
    given value will be used as a prefix on each image. If not specified\nor empty,
    no prefix will be used.\nA special case value, UseDefault, is supported to explicitly
    specify the default\nimage prefix will be used for each image.\nImage format:\n   `<registry><imagePath>/<imagePrefix><imageName>:<image-tag>`\nThis
    option allows configuring the `<imagePrefix>` portion of the above format.","type":"string"},"imagePullSecrets":{"description":"ImagePullSecrets
    is an array of references to container registry pull secrets to use. These are\napplied
    to all images to be pulled.","items":{"description":"LocalObjectReference contains
    enough information to let you locate the\nreferenced object inside the same namespace.","properties":{"name":{"description":"Name
    of the referent.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names\nTODO:
    Add other useful fields. apiVersion, kind, uid?","type":"string"}},"type":"object","x-kubernetes-map-type":"atomic"},"type":"array"},"kubeletVolumePluginPath":{"description":"KubeletVolumePluginPath
    optionally specifies enablement of Calico CSI plugin. If not specified,\nCSI will
    be enabled by default. If set to ''None'', CSI will be disabled.\nDefault: /var/lib/kubelet","type":"string"},"kubernetesProvider":{"description":"KubernetesProvider
    specifies a particular provider of the Kubernetes platform and enables provider-specific
    configuration.\nIf the specified value is empty, the Operator will attempt to
    automatically determine the current provider.\nIf the specified value is not empty,
    the Operator will still attempt auto-detection, but\nwill additionally compare
    the auto-detected value to the specified value to confirm they match.","enum":["","EKS","GKE","AKS","OpenShift","DockerEnterprise","RKE2","TKG"],"type":"string"},"logging":{"description":"Logging
    Configuration for Components","properties":{"cni":{"description":"Customized logging
    specification for calico-cni plugin","properties":{"logFileMaxAgeDays":{"description":"Default:
    30 (days)","format":"int32","type":"integer"},"logFileMaxCount":{"description":"Default:
    10","format":"int32","type":"integer"},"logFileMaxSize":{"anyOf":[{"type":"integer"},{"type":"string"}],"description":"Default:
    100Mi","pattern":"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$","x-kubernetes-int-or-string":true},"logSeverity":{"description":"Default:
    Info","enum":["Error","Warning","Debug","Info"],"type":"string"}},"type":"object"}},"type":"object"},"nodeMetricsPort":{"description":"NodeMetricsPort
    specifies which port calico/node serves prometheus metrics on. By default, metrics
    are not enabled.\nIf specified, this overrides any FelixConfiguration resources
    which may exist. If omitted, then\nprometheus metrics may still be configured
    through FelixConfiguration.","format":"int32","type":"integer"},"nodeUpdateStrategy":{"description":"NodeUpdateStrategy
    can be used to customize the desired update strategy, such as the MaxUnavailable\nfield.","properties":{"rollingUpdate":{"description":"Rolling
    update config params. Present only if type = \"RollingUpdate\".\n---\nTODO: Update
    this to follow our convention for oneOf, whatever we decide it\nto be. Same as
    Deployment `strategy.rollingUpdate`.\nSee https://github.com/kubernetes/kubernetes/issues/35345","properties":{"maxSurge":{"anyOf":[{"type":"integer"},{"type":"string"}],"description":"The
    maximum number of nodes with an existing available DaemonSet pod that\ncan have
    an updated DaemonSet pod during during an update.\nValue can be an absolute number
    (ex: 5) or a percentage of desired pods (ex: 10%).\nThis can not be 0 if MaxUnavailable
    is 0.\nAbsolute number is calculated from percentage by rounding up to a minimum
    of 1.\nDefault value is 0.\nExample: when this is set to 30%, at most 30% of the
    total number of nodes\nthat should be running the daemon pod (i.e. status.desiredNumberScheduled)\ncan
    have their a new pod created before the old pod is marked as deleted.\nThe update
    starts by launching new pods on 30% of nodes. Once an updated\npod is available
    (Ready for at least minReadySeconds) the old DaemonSet pod\non that node is marked
    deleted. If the old pod becomes unavailable for any\nreason (Ready transitions
    to false, is evicted, or is drained) an updated\npod is immediatedly created on
    that node without considering surge limits.\nAllowing surge implies the possibility
    that the resources consumed by the\ndaemonset on any given node can double if
    the readiness check fails, and\nso resource intensive daemonsets should take into
    account that they may\ncause evictions during disruption.","x-kubernetes-int-or-string":true},"maxUnavailable":{"anyOf":[{"type":"integer"},{"type":"string"}],"description":"The
    maximum number of DaemonSet pods that can be unavailable during the\nupdate. Value
    can be an absolute number (ex: 5) or a percentage of total\nnumber of DaemonSet
    pods at the start of the update (ex: 10%). Absolute\nnumber is calculated from
    percentage by rounding up.\nThis cannot be 0 if MaxSurge is 0\nDefault value is
    1.\nExample: when this is set to 30%, at most 30% of the total number of nodes\nthat
    should be running the daemon pod (i.e. status.desiredNumberScheduled)\ncan have
    their pods stopped for an update at any given time. The update\nstarts by stopping
    at most 30% of those DaemonSet pods and then brings\nup new DaemonSet pods in
    their place. Once the new pods are available,\nit then proceeds onto other DaemonSet
    pods, thus ensuring that at least\n70% of original number of DaemonSet pods are
    available at all times during\nthe update.","x-kubernetes-int-or-string":true}},"type":"object"},"type":{"description":"Type
    of daemon set update. Can be \"RollingUpdate\" or \"OnDelete\". Default is RollingUpdate.","type":"string"}},"type":"object"},"nonPrivileged":{"description":"NonPrivileged
    configures Calico to be run in non-privileged containers as non-root users where
    possible.","type":"string"},"registry":{"description":"Registry is the default
    Docker registry used for component Docker images.\nIf specified then the given
    value must end with a slash character (`/`) and all images will be pulled from
    this registry.\nIf not specified then the default registries will be used. A special
    case value, UseDefault, is\nsupported to explicitly specify the default registries
    will be used.\nImage format:\n   `<registry><imagePath>/<imagePrefix><imageName>:<image-tag>`\nThis
    option allows configuring the `<registry>` portion of the above format.","type":"string"},"serviceCIDRs":{"description":"Kubernetes
    Service CIDRs. Specifying this is required when using Calico for Windows.","items":{"type":"string"},"type":"array"},"typhaAffinity":{"description":"Deprecated.
    Please use Installation.Spec.TyphaDeployment instead.\nTyphaAffinity allows configuration
    of node affinity characteristics for Typha pods.","properties":{"nodeAffinity":{"description":"NodeAffinity
    describes node affinity scheduling rules for typha.","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"description":"The
    scheduler will prefer to schedule pods to nodes that satisfy\nthe affinity expressions
    specified by this field, but it may choose\na node that violates one or more of
    the expressions.","items":{"description":"An empty preferred scheduling term matches
    all objects with implicit weight 0\n(i.e. it''s a no-op). A null preferred scheduling
    term matches no objects (i.e. is also a no-op).","properties":{"preference":{"description":"A
    node selector term, associated with the corresponding weight.","properties":{"matchExpressions":{"description":"A
    list of node selector requirements by node''s labels.","items":{"description":"A
    node selector requirement is a selector that contains values, a key, and an operator\nthat
    relates the key and values.","properties":{"key":{"description":"The label key
    that the selector applies to.","type":"string"},"operator":{"description":"Represents
    a key''s relationship to a set of values.\nValid operators are In, NotIn, Exists,
    DoesNotExist. Gt, and Lt.","type":"string"},"values":{"description":"An array
    of string values. If the operator is In or NotIn,\nthe values array must be non-empty.
    If the operator is Exists or DoesNotExist,\nthe values array must be empty. If
    the operator is Gt or Lt, the values\narray must have a single element, which
    will be interpreted as an integer.\nThis array is replaced during a strategic
    merge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchFields":{"description":"A
    list of node selector requirements by node''s fields.","items":{"description":"A
    node selector requirement is a selector that contains values, a key, and an operator\nthat
    relates the key and values.","properties":{"key":{"description":"The label key
    that the selector applies to.","type":"string"},"operator":{"description":"Represents
    a key''s relationship to a set of values.\nValid operators are In, NotIn, Exists,
    DoesNotExist. Gt, and Lt.","type":"string"},"values":{"description":"An array
    of string values. If the operator is In or NotIn,\nthe values array must be non-empty.
    If the operator is Exists or DoesNotExist,\nthe values array must be empty. If
    the operator is Gt or Lt, the values\narray must have a single element, which
    will be interpreted as an integer.\nThis array is replaced during a strategic
    merge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"}},"type":"object","x-kubernetes-map-type":"atomic"},"weight":{"description":"Weight
    associated with matching the corresponding nodeSelectorTerm, in the range 1-100.","format":"int32","type":"integer"}},"required":["preference","weight"],"type":"object"},"type":"array"},"requiredDuringSchedulingIgnoredDuringExecution":{"description":"WARNING:
    Please note that if the affinity requirements specified by this field are not
    met at\nscheduling time, the pod will NOT be scheduled onto the node.\nThere is
    no fallback to another affinity rules with this setting.\nThis may cause networking
    disruption or even catastrophic failure!\nPreferredDuringSchedulingIgnoredDuringExecution
    should be used for affinity\nunless there is a specific well understood reason
    to use RequiredDuringSchedulingIgnoredDuringExecution and\nyou can guarantee that
    the RequiredDuringSchedulingIgnoredDuringExecution will always have sufficient
    nodes to satisfy the requirement.\nNOTE: RequiredDuringSchedulingIgnoredDuringExecution
    is set by default for AKS nodes,\nto avoid scheduling Typhas on virtual-nodes.\nIf
    the affinity requirements specified by this field cease to be met\nat some point
    during pod execution (e.g. due to an update), the system\nmay or may not try to
    eventually evict the pod from its node.","properties":{"nodeSelectorTerms":{"description":"Required.
    A list of node selector terms. The terms are ORed.","items":{"description":"A
    null or empty node selector term matches no objects. The requirements of\nthem
    are ANDed.\nThe TopologySelectorTerm type implements a subset of the NodeSelectorTerm.","properties":{"matchExpressions":{"description":"A
    list of node selector requirements by node''s labels.","items":{"description":"A
    node selector requirement is a selector that contains values, a key, and an operator\nthat
    relates the key and values.","properties":{"key":{"description":"The label key
    that the selector applies to.","type":"string"},"operator":{"description":"Represents
    a key''s relationship to a set of values.\nValid operators are In, NotIn, Exists,
    DoesNotExist. Gt, and Lt.","type":"string"},"values":{"description":"An array
    of string values. If the operator is In or NotIn,\nthe values array must be non-empty.
    If the operator is Exists or DoesNotExist,\nthe values array must be empty. If
    the operator is Gt or Lt, the values\narray must have a single element, which
    will be interpreted as an integer.\nThis array is replaced during a strategic
    merge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchFields":{"description":"A
    list of node selector requirements by node''s fields.","items":{"description":"A
    node selector requirement is a selector that contains values, a key, and an operator\nthat
    relates the key and values.","properties":{"key":{"description":"The label key
    that the selector applies to.","type":"string"},"operator":{"description":"Represents
    a key''s relationship to a set of values.\nValid operators are In, NotIn, Exists,
    DoesNotExist. Gt, and Lt.","type":"string"},"values":{"description":"An array
    of string values. If the operator is In or NotIn,\nthe values array must be non-empty.
    If the operator is Exists or DoesNotExist,\nthe values array must be empty. If
    the operator is Gt or Lt, the values\narray must have a single element, which
    will be interpreted as an integer.\nThis array is replaced during a strategic
    merge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"}},"type":"object","x-kubernetes-map-type":"atomic"},"type":"array"}},"required":["nodeSelectorTerms"],"type":"object","x-kubernetes-map-type":"atomic"}},"type":"object"}},"type":"object"},"typhaDeployment":{"description":"TyphaDeployment
    configures the typha Deployment. If used in conjunction with the deprecated\nComponentResources
    or TyphaAffinity, then these overrides take precedence.","properties":{"metadata":{"description":"Metadata
    is a subset of a Kubernetes object''s metadata that is added to the Deployment.","properties":{"annotations":{"additionalProperties":{"type":"string"},"description":"Annotations
    is a map of arbitrary non-identifying metadata. Each of these\nkey/value pairs
    are added to the object''s annotations provided the key does not\nalready exist
    in the object''s annotations.","type":"object"},"labels":{"additionalProperties":{"type":"string"},"description":"Labels
    is a map of string keys and values that may match replicaset and\nservice selectors.
    Each of these key/value pairs are added to the\nobject''s labels provided the
    key does not already exist in the object''s labels.","type":"object"}},"type":"object"},"spec":{"description":"Spec
    is the specification of the typha Deployment.","properties":{"minReadySeconds":{"description":"MinReadySeconds
    is the minimum number of seconds for which a newly created Deployment pod should\nbe
    ready without any of its container crashing, for it to be considered available.\nIf
    specified, this overrides any minReadySeconds value that may be set on the typha
    Deployment.\nIf omitted, the typha Deployment will use its default value for minReadySeconds.","format":"int32","maximum":2147483647,"minimum":0,"type":"integer"},"strategy":{"description":"The
    deployment strategy to use to replace existing pods with new ones.","properties":{"rollingUpdate":{"description":"Rolling
    update config params. Present only if DeploymentStrategyType =\nRollingUpdate.\nto
    be.","properties":{"maxSurge":{"anyOf":[{"type":"integer"},{"type":"string"}],"description":"The
    maximum number of pods that can be scheduled above the desired number of\npods.\nValue
    can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).\nThis
    can not be 0 if MaxUnavailable is 0.\nAbsolute number is calculated from percentage
    by rounding up.\nDefaults to 25%.\nExample: when this is set to 30%, the new ReplicaSet
    can be scaled up immediately when\nthe rolling update starts, such that the total
    number of old and new pods do not exceed\n130% of desired pods. Once old pods
    have been killed,\nnew ReplicaSet can be scaled up further, ensuring that total
    number of pods running\nat any time during the update is at most 130% of desired
    pods.","x-kubernetes-int-or-string":true},"maxUnavailable":{"anyOf":[{"type":"integer"},{"type":"string"}],"description":"The
    maximum number of pods that can be unavailable during the update.\nValue can be
    an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).\nAbsolute
    number is calculated from percentage by rounding down.\nThis can not be 0 if MaxSurge
    is 0.\nDefaults to 25%.\nExample: when this is set to 30%, the old ReplicaSet
    can be scaled down to 70% of desired pods\nimmediately when the rolling update
    starts. Once new pods are ready, old ReplicaSet\ncan be scaled down further, followed
    by scaling up the new ReplicaSet, ensuring\nthat the total number of pods available
    at all times during the update is at\nleast 70% of desired pods.","x-kubernetes-int-or-string":true}},"type":"object"}},"type":"object"},"template":{"description":"Template
    describes the typha Deployment pod that will be created.","properties":{"metadata":{"description":"Metadata
    is a subset of a Kubernetes object''s metadata that is added to\nthe pod''s metadata.","properties":{"annotations":{"additionalProperties":{"type":"string"},"description":"Annotations
    is a map of arbitrary non-identifying metadata. Each of these\nkey/value pairs
    are added to the object''s annotations provided the key does not\nalready exist
    in the object''s annotations.","type":"object"},"labels":{"additionalProperties":{"type":"string"},"description":"Labels
    is a map of string keys and values that may match replicaset and\nservice selectors.
    Each of these key/value pairs are added to the\nobject''s labels provided the
    key does not already exist in the object''s labels.","type":"object"}},"type":"object"},"spec":{"description":"Spec
    is the typha Deployment''s PodSpec.","properties":{"affinity":{"description":"Affinity
    is a group of affinity scheduling rules for the typha pods.\nIf specified, this
    overrides any affinity that may be set on the typha Deployment.\nIf omitted, the
    typha Deployment will use its default value for affinity.\nIf used in conjunction
    with the deprecated TyphaAffinity, then this value takes precedence.\nWARNING:
    Please note that this field will override the default calico-typha Deployment
    affinity.","properties":{"nodeAffinity":{"description":"Describes node affinity
    scheduling rules for the pod.","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"description":"The
    scheduler will prefer to schedule pods to nodes that satisfy\nthe affinity expressions
    specified by this field, but it may choose\na node that violates one or more of
    the expressions. The node that is\nmost preferred is the one with the greatest
    sum of weights, i.e.\nfor each node that meets all of the scheduling requirements
    (resource\nrequest, requiredDuringScheduling affinity expressions, etc.),\ncompute
    a sum by iterating through the elements of this field and adding\n\"weight\" to
    the sum if the node matches the corresponding matchExpressions; the\nnode(s) with
    the highest sum are the most preferred.","items":{"description":"An empty preferred
    scheduling term matches all objects with implicit weight 0\n(i.e. it''s a no-op).
    A null preferred scheduling term matches no objects (i.e. is also a no-op).","properties":{"preference":{"description":"A
    node selector term, associated with the corresponding weight.","properties":{"matchExpressions":{"description":"A
    list of node selector requirements by node''s labels.","items":{"description":"A
    node selector requirement is a selector that contains values, a key, and an operator\nthat
    relates the key and values.","properties":{"key":{"description":"The label key
    that the selector applies to.","type":"string"},"operator":{"description":"Represents
    a key''s relationship to a set of values.\nValid operators are In, NotIn, Exists,
    DoesNotExist. Gt, and Lt.","type":"string"},"values":{"description":"An array
    of string values. If the operator is In or NotIn,\nthe values array must be non-empty.
    If the operator is Exists or DoesNotExist,\nthe values array must be empty. If
    the operator is Gt or Lt, the values\narray must have a single element, which
    will be interpreted as an integer.\nThis array is replaced during a strategic
    merge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchFields":{"description":"A
    list of node selector requirements by node''s fields.","items":{"description":"A
    node selector requirement is a selector that contains values, a key, and an operator\nthat
    relates the key and values.","properties":{"key":{"description":"The label key
    that the selector applies to.","type":"string"},"operator":{"description":"Represents
    a key''s relationship to a set of values.\nValid operators are In, NotIn, Exists,
    DoesNotExist. Gt, and Lt.","type":"string"},"values":{"description":"An array
    of string values. If the operator is In or NotIn,\nthe values array must be non-empty.
    If the operator is Exists or DoesNotExist,\nthe values array must be empty. If
    the operator is Gt or Lt, the values\narray must have a single element, which
    will be interpreted as an integer.\nThis array is replaced during a strategic
    merge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"}},"type":"object","x-kubernetes-map-type":"atomic"},"weight":{"description":"Weight
    associated with matching the corresponding nodeSelectorTerm, in the range 1-100.","format":"int32","type":"integer"}},"required":["preference","weight"],"type":"object"},"type":"array"},"requiredDuringSchedulingIgnoredDuringExecution":{"description":"If
    the affinity requirements specified by this field are not met at\nscheduling time,
    the pod will not be scheduled onto the node.\nIf the affinity requirements specified
    by this field cease to be met\nat some point during pod execution (e.g. due to
    an update), the system\nmay or may not try to eventually evict the pod from its
    node.","properties":{"nodeSelectorTerms":{"description":"Required. A list of node
    selector terms. The terms are ORed.","items":{"description":"A null or empty node
    selector term matches no objects. The requirements of\nthem are ANDed.\nThe TopologySelectorTerm
    type implements a subset of the NodeSelectorTerm.","properties":{"matchExpressions":{"description":"A
    list of node selector requirements by node''s labels.","items":{"description":"A
    node selector requirement is a selector that contains values, a key, and an operator\nthat
    relates the key and values.","properties":{"key":{"description":"The label key
    that the selector applies to.","type":"string"},"operator":{"description":"Represents
    a key''s relationship to a set of values.\nValid operators are In, NotIn, Exists,
    DoesNotExist. Gt, and Lt.","type":"string"},"values":{"description":"An array
    of string values. If the operator is In or NotIn,\nthe values array must be non-empty.
    If the operator is Exists or DoesNotExist,\nthe values array must be empty. If
    the operator is Gt or Lt, the values\narray must have a single element, which
    will be interpreted as an integer.\nThis array is replaced during a strategic
    merge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchFields":{"description":"A
    list of node selector requirements by node''s fields.","items":{"description":"A
    node selector requirement is a selector that contains values, a key, and an operator\nthat
    relates the key and values.","properties":{"key":{"description":"The label key
    that the selector applies to.","type":"string"},"operator":{"description":"Represents
    a key''s relationship to a set of values.\nValid operators are In, NotIn, Exists,
    DoesNotExist. Gt, and Lt.","type":"string"},"values":{"description":"An array
    of string values. If the operator is In or NotIn,\nthe values array must be non-empty.
    If the operator is Exists or DoesNotExist,\nthe values array must be empty. If
    the operator is Gt or Lt, the values\narray must have a single element, which
    will be interpreted as an integer.\nThis array is replaced during a strategic
    merge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"}},"type":"object","x-kubernetes-map-type":"atomic"},"type":"array"}},"required":["nodeSelectorTerms"],"type":"object","x-kubernetes-map-type":"atomic"}},"type":"object"},"podAffinity":{"description":"Describes
    pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone,
    etc. as some other pod(s)).","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"description":"The
    scheduler will prefer to schedule pods to nodes that satisfy\nthe affinity expressions
    specified by this field, but it may choose\na node that violates one or more of
    the expressions. The node that is\nmost preferred is the one with the greatest
    sum of weights, i.e.\nfor each node that meets all of the scheduling requirements
    (resource\nrequest, requiredDuringScheduling affinity expressions, etc.),\ncompute
    a sum by iterating through the elements of this field and adding\n\"weight\" to
    the sum if the node has pods which matches the corresponding podAffinityTerm;
    the\nnode(s) with the highest sum are the most preferred.","items":{"description":"The
    weights of all of the matched WeightedPodAffinityTerm fields are added per-node
    to find the most preferred node(s)","properties":{"podAffinityTerm":{"description":"Required.
    A pod affinity term, associated with the corresponding weight.","properties":{"labelSelector":{"description":"A
    label query over a set of resources, in this case pods.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaceSelector":{"description":"A
    label query over the set of namespaces that the term applies to.\nThe term is
    applied to the union of the namespaces selected by this field\nand the ones listed
    in the namespaces field.\nnull selector and null or empty namespaces list means
    \"this pod''s namespace\".\nAn empty selector ({}) matches all namespaces.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaces":{"description":"namespaces
    specifies a static list of namespace names that the term applies to.\nThe term
    is applied to the union of the namespaces listed in this field\nand the ones selected
    by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector
    means \"this pod''s namespace\".","items":{"type":"string"},"type":"array"},"topologyKey":{"description":"This
    pod should be co-located (affinity) or not co-located (anti-affinity) with the
    pods matching\nthe labelSelector in the specified namespaces, where co-located
    is defined as running on a node\nwhose value of the label with key topologyKey
    matches that of any node on which any of the\nselected pods is running.\nEmpty
    topologyKey is not allowed.","type":"string"}},"required":["topologyKey"],"type":"object"},"weight":{"description":"weight
    associated with matching the corresponding podAffinityTerm,\nin the range 1-100.","format":"int32","type":"integer"}},"required":["podAffinityTerm","weight"],"type":"object"},"type":"array"},"requiredDuringSchedulingIgnoredDuringExecution":{"description":"If
    the affinity requirements specified by this field are not met at\nscheduling time,
    the pod will not be scheduled onto the node.\nIf the affinity requirements specified
    by this field cease to be met\nat some point during pod execution (e.g. due to
    a pod label update), the\nsystem may or may not try to eventually evict the pod
    from its node.\nWhen there are multiple elements, the lists of nodes corresponding
    to each\npodAffinityTerm are intersected, i.e. all terms must be satisfied.","items":{"description":"Defines
    a set of pods (namely those matching the labelSelector\nrelative to the given
    namespace(s)) that this pod should be\nco-located (affinity) or not co-located
    (anti-affinity) with,\nwhere co-located is defined as running on a node whose
    value of\nthe label with key <topologyKey> matches that of any node on which\na
    pod of the set of pods is running","properties":{"labelSelector":{"description":"A
    label query over a set of resources, in this case pods.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaceSelector":{"description":"A
    label query over the set of namespaces that the term applies to.\nThe term is
    applied to the union of the namespaces selected by this field\nand the ones listed
    in the namespaces field.\nnull selector and null or empty namespaces list means
    \"this pod''s namespace\".\nAn empty selector ({}) matches all namespaces.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaces":{"description":"namespaces
    specifies a static list of namespace names that the term applies to.\nThe term
    is applied to the union of the namespaces listed in this field\nand the ones selected
    by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector
    means \"this pod''s namespace\".","items":{"type":"string"},"type":"array"},"topologyKey":{"description":"This
    pod should be co-located (affinity) or not co-located (anti-affinity) with the
    pods matching\nthe labelSelector in the specified namespaces, where co-located
    is defined as running on a node\nwhose value of the label with key topologyKey
    matches that of any node on which any of the\nselected pods is running.\nEmpty
    topologyKey is not allowed.","type":"string"}},"required":["topologyKey"],"type":"object"},"type":"array"}},"type":"object"},"podAntiAffinity":{"description":"Describes
    pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node,
    zone, etc. as some other pod(s)).","properties":{"preferredDuringSchedulingIgnoredDuringExecution":{"description":"The
    scheduler will prefer to schedule pods to nodes that satisfy\nthe anti-affinity
    expressions specified by this field, but it may choose\na node that violates one
    or more of the expressions. The node that is\nmost preferred is the one with the
    greatest sum of weights, i.e.\nfor each node that meets all of the scheduling
    requirements (resource\nrequest, requiredDuringScheduling anti-affinity expressions,
    etc.),\ncompute a sum by iterating through the elements of this field and adding\n\"weight\"
    to the sum if the node has pods which matches the corresponding podAffinityTerm;
    the\nnode(s) with the highest sum are the most preferred.","items":{"description":"The
    weights of all of the matched WeightedPodAffinityTerm fields are added per-node
    to find the most preferred node(s)","properties":{"podAffinityTerm":{"description":"Required.
    A pod affinity term, associated with the corresponding weight.","properties":{"labelSelector":{"description":"A
    label query over a set of resources, in this case pods.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaceSelector":{"description":"A
    label query over the set of namespaces that the term applies to.\nThe term is
    applied to the union of the namespaces selected by this field\nand the ones listed
    in the namespaces field.\nnull selector and null or empty namespaces list means
    \"this pod''s namespace\".\nAn empty selector ({}) matches all namespaces.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaces":{"description":"namespaces
    specifies a static list of namespace names that the term applies to.\nThe term
    is applied to the union of the namespaces listed in this field\nand the ones selected
    by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector
    means \"this pod''s namespace\".","items":{"type":"string"},"type":"array"},"topologyKey":{"description":"This
    pod should be co-located (affinity) or not co-located (anti-affinity) with the
    pods matching\nthe labelSelector in the specified namespaces, where co-located
    is defined as running on a node\nwhose value of the label with key topologyKey
    matches that of any node on which any of the\nselected pods is running.\nEmpty
    topologyKey is not allowed.","type":"string"}},"required":["topologyKey"],"type":"object"},"weight":{"description":"weight
    associated with matching the corresponding podAffinityTerm,\nin the range 1-100.","format":"int32","type":"integer"}},"required":["podAffinityTerm","weight"],"type":"object"},"type":"array"},"requiredDuringSchedulingIgnoredDuringExecution":{"description":"If
    the anti-affinity requirements specified by this field are not met at\nscheduling
    time, the pod will not be scheduled onto the node.\nIf the anti-affinity requirements
    specified by this field cease to be met\nat some point during pod execution (e.g.
    due to a pod label update), the\nsystem may or may not try to eventually evict
    the pod from its node.\nWhen there are multiple elements, the lists of nodes corresponding
    to each\npodAffinityTerm are intersected, i.e. all terms must be satisfied.","items":{"description":"Defines
    a set of pods (namely those matching the labelSelector\nrelative to the given
    namespace(s)) that this pod should be\nco-located (affinity) or not co-located
    (anti-affinity) with,\nwhere co-located is defined as running on a node whose
    value of\nthe label with key <topologyKey> matches that of any node on which\na
    pod of the set of pods is running","properties":{"labelSelector":{"description":"A
    label query over a set of resources, in this case pods.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaceSelector":{"description":"A
    label query over the set of namespaces that the term applies to.\nThe term is
    applied to the union of the namespaces selected by this field\nand the ones listed
    in the namespaces field.\nnull selector and null or empty namespaces list means
    \"this pod''s namespace\".\nAn empty selector ({}) matches all namespaces.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"namespaces":{"description":"namespaces
    specifies a static list of namespace names that the term applies to.\nThe term
    is applied to the union of the namespaces listed in this field\nand the ones selected
    by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector
    means \"this pod''s namespace\".","items":{"type":"string"},"type":"array"},"topologyKey":{"description":"This
    pod should be co-located (affinity) or not co-located (anti-affinity) with the
    pods matching\nthe labelSelector in the specified namespaces, where co-located
    is defined as running on a node\nwhose value of the label with key topologyKey
    matches that of any node on which any of the\nselected pods is running.\nEmpty
    topologyKey is not allowed.","type":"string"}},"required":["topologyKey"],"type":"object"},"type":"array"}},"type":"object"}},"type":"object"},"containers":{"description":"Containers
    is a list of typha containers.\nIf specified, this overrides the specified typha
    Deployment containers.\nIf omitted, the typha Deployment will use its default
    values for its containers.","items":{"description":"TyphaDeploymentContainer is
    a typha Deployment container.","properties":{"name":{"description":"Name is an
    enum which identifies the typha Deployment container by name.\nSupported values
    are: calico-typha","enum":["calico-typha"],"type":"string"},"resources":{"description":"Resources
    allows customization of limits and requests for compute resources such as cpu
    and memory.\nIf specified, this overrides the named typha Deployment container''s
    resources.\nIf omitted, the typha Deployment will use its default value for this
    container''s resources.\nIf used in conjunction with the deprecated ComponentResources,
    then this value takes precedence.","properties":{"claims":{"description":"Claims
    lists the names of resources, defined in spec.resourceClaims,\nthat are used by
    this container.\nThis is an alpha field and requires enabling the\nDynamicResourceAllocation
    feature gate.\nThis field is immutable. It can only be set for containers.","items":{"description":"ResourceClaim
    references one entry in PodSpec.ResourceClaims.","properties":{"name":{"description":"Name
    must match the name of one entry in pod.spec.resourceClaims of\nthe Pod where
    this field is used. It makes that resource available\ninside a container.","type":"string"}},"required":["name"],"type":"object"},"type":"array","x-kubernetes-list-map-keys":["name"],"x-kubernetes-list-type":"map"},"limits":{"additionalProperties":{"anyOf":[{"type":"integer"},{"type":"string"}],"pattern":"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$","x-kubernetes-int-or-string":true},"description":"Limits
    describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/","type":"object"},"requests":{"additionalProperties":{"anyOf":[{"type":"integer"},{"type":"string"}],"pattern":"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$","x-kubernetes-int-or-string":true},"description":"Requests
    describes the minimum amount of compute resources required.\nIf Requests is omitted
    for a container, it defaults to Limits if that is explicitly specified,\notherwise
    to an implementation-defined value. Requests cannot exceed Limits.\nMore info:
    https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/","type":"object"}},"type":"object"}},"required":["name"],"type":"object"},"type":"array"},"initContainers":{"description":"InitContainers
    is a list of typha init containers.\nIf specified, this overrides the specified
    typha Deployment init containers.\nIf omitted, the typha Deployment will use its
    default values for its init containers.","items":{"description":"TyphaDeploymentInitContainer
    is a typha Deployment init container.","properties":{"name":{"description":"Name
    is an enum which identifies the typha Deployment init container by name.\nSupported
    values are: typha-certs-key-cert-provisioner","enum":["typha-certs-key-cert-provisioner"],"type":"string"},"resources":{"description":"Resources
    allows customization of limits and requests for compute resources such as cpu
    and memory.\nIf specified, this overrides the named typha Deployment init container''s
    resources.\nIf omitted, the typha Deployment will use its default value for this
    init container''s resources.\nIf used in conjunction with the deprecated ComponentResources,
    then this value takes precedence.","properties":{"claims":{"description":"Claims
    lists the names of resources, defined in spec.resourceClaims,\nthat are used by
    this container.\nThis is an alpha field and requires enabling the\nDynamicResourceAllocation
    feature gate.\nThis field is immutable. It can only be set for containers.","items":{"description":"ResourceClaim
    references one entry in PodSpec.ResourceClaims.","properties":{"name":{"description":"Name
    must match the name of one entry in pod.spec.resourceClaims of\nthe Pod where
    this field is used. It makes that resource available\ninside a container.","type":"string"}},"required":["name"],"type":"object"},"type":"array","x-kubernetes-list-map-keys":["name"],"x-kubernetes-list-type":"map"},"limits":{"additionalProperties":{"anyOf":[{"type":"integer"},{"type":"string"}],"pattern":"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$","x-kubernetes-int-or-string":true},"description":"Limits
    describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/","type":"object"},"requests":{"additionalProperties":{"anyOf":[{"type":"integer"},{"type":"string"}],"pattern":"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$","x-kubernetes-int-or-string":true},"description":"Requests
    describes the minimum amount of compute resources required.\nIf Requests is omitted
    for a container, it defaults to Limits if that is explicitly specified,\notherwise
    to an implementation-defined value. Requests cannot exceed Limits.\nMore info:
    https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/","type":"object"}},"type":"object"}},"required":["name"],"type":"object"},"type":"array"},"nodeSelector":{"additionalProperties":{"type":"string"},"description":"NodeSelector
    is the calico-typha pod''s scheduling constraints.\nIf specified, each of the
    key/value pairs are added to the calico-typha Deployment nodeSelector provided\nthe
    key does not already exist in the object''s nodeSelector.\nIf omitted, the calico-typha
    Deployment will use its default value for nodeSelector.\nWARNING: Please note
    that this field will modify the default calico-typha Deployment nodeSelector.","type":"object"},"terminationGracePeriodSeconds":{"description":"Optional
    duration in seconds the pod needs to terminate gracefully. May be decreased in
    delete request.\nValue must be non-negative integer. The value zero indicates
    stop immediately via\nthe kill signal (no opportunity to shut down).\nIf this
    value is nil, the default grace period will be used instead.\nThe grace period
    is the duration in seconds after the processes running in the pod are sent\na
    termination signal and the time when the processes are forcibly halted with a
    kill signal.\nSet this value longer than the expected cleanup time for your process.\nDefaults
    to 30 seconds.","format":"int64","type":"integer"},"tolerations":{"description":"Tolerations
    is the typha pod''s tolerations.\nIf specified, this overrides any tolerations
    that may be set on the typha Deployment.\nIf omitted, the typha Deployment will
    use its default value for tolerations.\nWARNING: Please note that this field will
    override the default calico-typha Deployment tolerations.","items":{"description":"The
    pod this Toleration is attached to tolerates any taint that matches\nthe triple
    <key,value,effect> using the matching operator <operator>.","properties":{"effect":{"description":"Effect
    indicates the taint effect to match. Empty means match all taint effects.\nWhen
    specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.","type":"string"},"key":{"description":"Key
    is the taint key that the toleration applies to. Empty means match all taint keys.\nIf
    the key is empty, operator must be Exists; this combination means to match all
    values and all keys.","type":"string"},"operator":{"description":"Operator represents
    a key''s relationship to the value.\nValid operators are Exists and Equal. Defaults
    to Equal.\nExists is equivalent to wildcard for value, so that a pod can\ntolerate
    all taints of a particular category.","type":"string"},"tolerationSeconds":{"description":"TolerationSeconds
    represents the period of time the toleration (which must be\nof effect NoExecute,
    otherwise this field is ignored) tolerates the taint. By default,\nit is not set,
    which means tolerate the taint forever (do not evict). Zero and\nnegative values
    will be treated as 0 (evict immediately) by the system.","format":"int64","type":"integer"},"value":{"description":"Value
    is the taint value the toleration matches to.\nIf the operator is Exists, the
    value should be empty, otherwise just a regular string.","type":"string"}},"type":"object"},"type":"array"},"topologySpreadConstraints":{"description":"TopologySpreadConstraints
    describes how a group of pods ought to spread across topology\ndomains. Scheduler
    will schedule pods in a way which abides by the constraints.\nAll topologySpreadConstraints
    are ANDed.","items":{"description":"TopologySpreadConstraint specifies how to
    spread matching pods among the given topology.","properties":{"labelSelector":{"description":"LabelSelector
    is used to find matching pods.\nPods that match this label selector are counted
    to determine the number of pods\nin their corresponding topology domain.","properties":{"matchExpressions":{"description":"matchExpressions
    is a list of label selector requirements. The requirements are ANDed.","items":{"description":"A
    label selector requirement is a selector that contains values, a key, and an operator
    that\nrelates the key and values.","properties":{"key":{"description":"key is
    the label key that the selector applies to.","type":"string"},"operator":{"description":"operator
    represents a key''s relationship to a set of values.\nValid operators are In,
    NotIn, Exists and DoesNotExist.","type":"string"},"values":{"description":"values
    is an array of string values. If the operator is In or NotIn,\nthe values array
    must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array
    must be empty. This array is replaced during a strategic\nmerge patch.","items":{"type":"string"},"type":"array"}},"required":["key","operator"],"type":"object"},"type":"array"},"matchLabels":{"additionalProperties":{"type":"string"},"description":"matchLabels
    is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is
    equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator
    is \"In\", and the values array contains only \"value\". The requirements are
    ANDed.","type":"object"}},"type":"object","x-kubernetes-map-type":"atomic"},"matchLabelKeys":{"description":"MatchLabelKeys
    is a set of pod label keys to select the pods over which\nspreading will be calculated.
    The keys are used to lookup values from the\nincoming pod labels, those key-value
    labels are ANDed with labelSelector\nto select the group of existing pods over
    which spreading will be calculated\nfor the incoming pod. The same key is forbidden
    to exist in both MatchLabelKeys and LabelSelector.\nMatchLabelKeys cannot be set
    when LabelSelector isn''t set.\nKeys that don''t exist in the incoming pod labels
    will\nbe ignored. A null or empty list means only match against labelSelector.\nThis
    is a beta field and requires the MatchLabelKeysInPodTopologySpread feature gate
    to be enabled (enabled by default).","items":{"type":"string"},"type":"array","x-kubernetes-list-type":"atomic"},"maxSkew":{"description":"MaxSkew
    describes the degree to which pods may be unevenly distributed.\nWhen `whenUnsatisfiable=DoNotSchedule`,
    it is the maximum permitted difference\nbetween the number of matching pods in
    the target topology and the global minimum.\nThe global minimum is the minimum
    number of matching pods in an eligible domain\nor zero if the number of eligible
    domains is less than MinDomains.\nFor example, in a 3-zone cluster, MaxSkew is
    set to 1, and pods with the same\nlabelSelector spread as 2/2/1:\nIn this case,
    the global minimum is 1.\n| zone1 | zone2 | zone3 |\n|  P P  |  P P  |   P   |\n-
    if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 2/2/2;\nscheduling
    it onto zone1(zone2) would make the ActualSkew(3-1) on zone1(zone2)\nviolate MaxSkew(1).\n-
    if MaxSkew is 2, incoming pod can be scheduled onto any zone.\nWhen `whenUnsatisfiable=ScheduleAnyway`,
    it is used to give higher precedence\nto topologies that satisfy it.\nIt''s a
    required field. Default value is 1 and 0 is not allowed.","format":"int32","type":"integer"},"minDomains":{"description":"MinDomains
    indicates a minimum number of eligible domains.\nWhen the number of eligible domains
    with matching topology keys is less than minDomains,\nPod Topology Spread treats
    \"global minimum\" as 0, and then the calculation of Skew is performed.\nAnd when
    the number of eligible domains with matching topology keys equals or greater than
    minDomains,\nthis value has no effect on scheduling.\nAs a result, when the number
    of eligible domains is less than minDomains,\nscheduler won''t schedule more than
    maxSkew Pods to those domains.\nIf value is nil, the constraint behaves as if
    MinDomains is equal to 1.\nValid values are integers greater than 0.\nWhen value
    is not nil, WhenUnsatisfiable must be DoNotSchedule.\nFor example, in a 3-zone
    cluster, MaxSkew is set to 2, MinDomains is set to 5 and pods with the same\nlabelSelector
    spread as 2/2/2:\n| zone1 | zone2 | zone3 |\n|  P P  |  P P  |  P P  |\nThe number
    of domains is less than 5(MinDomains), so \"global minimum\" is treated as 0.\nIn
    this situation, new pod with the same labelSelector cannot be scheduled,\nbecause
    computed skew will be 3(3 - 0) if new Pod is scheduled to any of the three zones,\nit
    will violate MaxSkew.\nThis is a beta field and requires the MinDomainsInPodTopologySpread
    feature gate to be enabled (enabled by default).","format":"int32","type":"integer"},"nodeAffinityPolicy":{"description":"NodeAffinityPolicy
    indicates how we will treat Pod''s nodeAffinity/nodeSelector\nwhen calculating
    pod topology spread skew. Options are:\n- Honor: only nodes matching nodeAffinity/nodeSelector
    are included in the calculations.\n- Ignore: nodeAffinity/nodeSelector are ignored.
    All nodes are included in the calculations.\nIf this value is nil, the behavior
    is equivalent to the Honor policy.\nThis is a beta-level feature default enabled
    by the NodeInclusionPolicyInPodTopologySpread feature flag.","type":"string"},"nodeTaintsPolicy":{"description":"NodeTaintsPolicy
    indicates how we will treat node taints when calculating\npod topology spread
    skew. Options are:\n- Honor: nodes without taints, along with tainted nodes for
    which the incoming pod\nhas a toleration, are included.\n- Ignore: node taints
    are ignored. All nodes are included.\nIf this value is nil, the behavior is equivalent
    to the Ignore policy.\nThis is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread
    feature flag.","type":"string"},"topologyKey":{"description":"TopologyKey is the
    key of node labels. Nodes that have a label with this key\nand identical values
    are considered to be in the same topology.\nWe consider each <key, value> as a
    \"bucket\", and try to put balanced number\nof pods into each bucket.\nWe define
    a domain as a particular instance of a topology.\nAlso, we define an eligible
    domain as a domain whose nodes meet the requirements of\nnodeAffinityPolicy and
    nodeTaintsPolicy.\ne.g. If TopologyKey is \"kubernetes.io/hostname\", each Node
    is a domain of that topology.\nAnd, if TopologyKey is \"topology.kubernetes.io/zone\",
    each zone is a domain of that topology.\nIt''s a required field.","type":"string"},"whenUnsatisfiable":{"description":"WhenUnsatisfiable
    indicates how to deal with a pod if it doesn''t satisfy\nthe spread constraint.\n-
    DoNotSchedule (default) tells the scheduler not to schedule it.\n- ScheduleAnyway
    tells the scheduler to schedule the pod in any location,\n  but giving higher
    precedence to topologies that would help reduce the\n  skew.\nA constraint is
    considered \"Unsatisfiable\" for an incoming pod\nif and only if every possible
    node assignment for that pod would violate\n\"MaxSkew\" on some topology.\nFor
    example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same\nlabelSelector
    spread as 3/1/1:\n| zone1 | zone2 | zone3 |\n| P P P |   P   |   P   |\nIf WhenUnsatisfiable
    is set to DoNotSchedule, incoming pod can only be scheduled\nto zone2(zone3) to
    become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies\nMaxSkew(1).
    In other words, the cluster can still be imbalanced, but scheduler\nwon''t make
    it *more* imbalanced.\nIt''s a required field.","type":"string"}},"required":["maxSkew","topologyKey","whenUnsatisfiable"],"type":"object"},"type":"array"}},"type":"object"}},"type":"object"}},"type":"object"}},"type":"object"},"typhaMetricsPort":{"description":"TyphaMetricsPort
    specifies which port calico/typha serves prometheus metrics on. By default, metrics
    are not enabled.","format":"int32","type":"integer"},"variant":{"description":"Variant
    is the product to install - one of Calico or TigeraSecureEnterprise\nDefault:
    Calico","enum":["Calico","TigeraSecureEnterprise"],"type":"string"},"windowsNodes":{"description":"Windows
    Configuration","properties":{"cniBinDir":{"description":"CNIBinDir is the path
    to the CNI binaries directory on Windows, it must match what is used as ''bin_dir''
    under\n[plugins]\n  [plugins.\"io.containerd.grpc.v1.cri\"]\n    [plugins.\"io.containerd.grpc.v1.cri\".cni]\non
    the containerd ''config.toml'' file on the Windows nodes.","type":"string"},"cniConfigDir":{"description":"CNIConfigDir
    is the path to the CNI configuration directory on Windows, it must match what
    is used as ''conf_dir'' under\n[plugins]\n  [plugins.\"io.containerd.grpc.v1.cri\"]\n    [plugins.\"io.containerd.grpc.v1.cri\".cni]\non
    the containerd ''config.toml'' file on the Windows nodes.","type":"string"},"cniLogDir":{"description":"CNILogDir
    is the path to the Calico CNI logs directory on Windows.","type":"string"},"vxlanAdapter":{"description":"VXLANAdapter
    is the Network Adapter used for VXLAN, leave blank for primary NIC","type":"string"},"vxlanMACPrefix":{"description":"VXLANMACPrefix
    is the prefix used when generating MAC addresses for virtual NICs","pattern":"^[0-9A-Fa-f]{2}-[0-9A-Fa-f]{2}$","type":"string"}},"type":"object"}},"type":"object"},"conditions":{"description":"Conditions
    represents the latest observed set of conditions for the component. A component
    may be one or more of\nReady, Progressing, Degraded or other customer types.","items":{"description":"Condition
    contains details for one aspect of the current state of this API Resource.\n---\nThis
    struct is intended for direct use as an array at the field path .status.conditions.  For
    example,\n\n\n\ttype FooStatus struct{\n\t    // Represents the observations of
    a foo''s current state.\n\t    // Known .status.conditions.type are: \"Available\",
    \"Progressing\", and \"Degraded\"\n\t    // +patchMergeKey=type\n\t    // +patchStrategy=merge\n\t    //
    +listType=map\n\t    // +listMapKey=type\n\t    Conditions []metav1.Condition
    `json:\"conditions,omitempty\" patchStrategy:\"merge\" patchMergeKey:\"type\"
    protobuf:\"bytes,1,rep,name=conditions\"`\n\n\n\t    // other fields\n\t}","properties":{"lastTransitionTime":{"description":"lastTransitionTime
    is the last time the condition transitioned from one status to another.\nThis
    should be when the underlying condition changed.  If that is not known, then using
    the time when the API field changed is acceptable.","format":"date-time","type":"string"},"message":{"description":"message
    is a human readable message indicating details about the transition.\nThis may
    be an empty string.","maxLength":32768,"type":"string"},"observedGeneration":{"description":"observedGeneration
    represents the .metadata.generation that the condition was set based upon.\nFor
    instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration
    is 9, the condition is out of date\nwith respect to the current state of the instance.","format":"int64","minimum":0,"type":"integer"},"reason":{"description":"reason
    contains a programmatic identifier indicating the reason for the condition''s
    last transition.\nProducers of specific condition types may define expected values
    and meanings for this field,\nand whether the values are considered a guaranteed
    API.\nThe value should be a CamelCase string.\nThis field may not be empty.","maxLength":1024,"minLength":1,"pattern":"^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$","type":"string"},"status":{"description":"status
    of the condition, one of True, False, Unknown.","enum":["True","False","Unknown"],"type":"string"},"type":{"description":"type
    of condition in CamelCase or in foo.example.com/CamelCase.\n---\nMany .condition.type
    values are consistent across resources like Available, but because arbitrary conditions
    can be\nuseful (see .node.status.conditions), the ability to deconflict is important.\nThe
    regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)","maxLength":316,"pattern":"^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$","type":"string"}},"required":["lastTransitionTime","message","reason","status","type"],"type":"object"},"type":"array"},"imageSet":{"description":"ImageSet
    is the name of the ImageSet being used, if there is an ImageSet\nthat is being
    used. If an ImageSet is not being used then this will not be set.","type":"string"},"mtu":{"description":"MTU
    is the most recently observed value for pod network MTU. This may be an explicitly\nconfigured
    value, or based on Calico''s native auto-detetion.","format":"int32","type":"integer"},"variant":{"description":"Variant
    is the most recently observed installed variant - one of Calico or TigeraSecureEnterprise","enum":["Calico","TigeraSecureEnterprise"],"type":"string"}},"type":"object"}},"type":"object"}},"served":true,"storage":true,"subresources":{"status":{}}}]}},{"apiVersion":"apiextensions.k8s.io/v1","kind":"CustomResourceDefinition","metadata":{"annotations":{"controller-gen.kubebuilder.io/version":"v0.14.0"},"name":"tigerastatuses.operator.tigera.io"},"spec":{"group":"operator.tigera.io","names":{"kind":"TigeraStatus","listKind":"TigeraStatusList","plural":"tigerastatuses","singular":"tigerastatus"},"scope":"Cluster","versions":[{"additionalPrinterColumns":[{"description":"Whether
    the component running and stable.","jsonPath":".status.conditions[?(@.type==''Available'')].status","name":"Available","type":"string"},{"description":"Whether
    the component is processing changes.","jsonPath":".status.conditions[?(@.type==''Progressing'')].status","name":"Progressing","type":"string"},{"description":"Whether
    the component is degraded.","jsonPath":".status.conditions[?(@.type==''Degraded'')].status","name":"Degraded","type":"string"},{"description":"The
    time the component''s Available status last changed.","jsonPath":".status.conditions[?(@.type==''Available'')].lastTransitionTime","name":"Since","type":"date"}],"name":"v1","schema":{"openAPIV3Schema":{"description":"TigeraStatus
    represents the most recently observed status for Calico or a Calico Enterprise
    functional area.","properties":{"apiVersion":{"description":"APIVersion defines
    the versioned schema of this representation of an object.\nServers should convert
    recognized schemas to the latest internal value, and\nmay reject unrecognized
    values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","type":"string"},"kind":{"description":"Kind
    is a string value representing the REST resource this object represents.\nServers
    may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn
    CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","type":"string"},"metadata":{"type":"object"},"spec":{"description":"TigeraStatusSpec
    defines the desired state of TigeraStatus","type":"object"},"status":{"description":"TigeraStatusStatus
    defines the observed state of TigeraStatus","properties":{"conditions":{"description":"Conditions
    represents the latest observed set of conditions for this component. A component
    may be one or more of\nAvailable, Progressing, or Degraded.","items":{"description":"TigeraStatusCondition
    represents a condition attached to a particular component.","properties":{"lastTransitionTime":{"description":"The
    timestamp representing the start time for the current status.","format":"date-time","type":"string"},"message":{"description":"Optionally,
    a detailed message providing additional context.","type":"string"},"observedGeneration":{"description":"observedGeneration
    represents the generation that the condition was set based upon.\nFor instance,
    if generation is currently 12, but the .status.conditions[x].observedGeneration
    is 9, the condition is out of date\nwith respect to the current state of the instance.","format":"int64","type":"integer"},"reason":{"description":"A
    brief reason explaining the condition.","type":"string"},"status":{"description":"The
    status of the condition. May be True, False, or Unknown.","type":"string"},"type":{"description":"The
    type of condition. May be Available, Progressing, or Degraded.","type":"string"}},"required":["lastTransitionTime","status","type"],"type":"object"},"type":"array"}},"required":["conditions"],"type":"object"}},"type":"object"}},"served":true,"storage":true,"subresources":{"status":{}}}]}},{"apiVersion":"v1","imagePullSecrets":[],"kind":"ServiceAccount","metadata":{"labels":{"k8s-app":"tigera-operator"},"name":"tigera-operator","namespace":"tigera-operator"}},{"apiVersion":"rbac.authorization.k8s.io/v1","kind":"ClusterRole","metadata":{"labels":{"k8s-app":"tigera-operator"},"name":"tigera-operator"},"rules":[{"apiGroups":[""],"resources":["namespaces","pods","podtemplates","services","endpoints","events","configmaps","secrets","serviceaccounts"],"verbs":["create","get","list","update","delete","watch"]},{"apiGroups":[""],"resources":["resourcequotas"],"verbs":["list","get","watch"]},{"apiGroups":[""],"resourceNames":["calico-critical-pods","tigera-critical-pods"],"resources":["resourcequotas"],"verbs":["create","get","list","update","delete","watch"]},{"apiGroups":[""],"resources":["nodes"],"verbs":["get","patch","list","watch"]},{"apiGroups":["rbac.authorization.k8s.io"],"resources":["clusterroles","clusterrolebindings","rolebindings","roles"],"verbs":["create","get","list","update","delete","watch","bind","escalate"]},{"apiGroups":["apps"],"resources":["deployments","daemonsets","statefulsets"],"verbs":["create","get","list","patch","update","delete","watch"]},{"apiGroups":["apps"],"resourceNames":["tigera-operator"],"resources":["deployments/finalizers"],"verbs":["update"]},{"apiGroups":["operator.tigera.io"],"resources":["apiservers/finalizers","installations","installations/status","installations/finalizers","tigerastatuses","tigerastatuses/status","tigerastatuses/finalizers","apiservers","apiservers/status","imagesets"],"verbs":["get","list","update","patch","watch"]},{"apiGroups":["operator.tigera.io"],"resources":["tigerastatuses"],"verbs":["create","delete"]},{"apiGroups":["operator.tigera.io"],"resources":["installations","apiservers"],"verbs":["delete"]},{"apiGroups":["networking.k8s.io"],"resources":["networkpolicies"],"verbs":["create","update","delete","get","list","watch"]},{"apiGroups":["crd.projectcalico.org"],"resources":["felixconfigurations","ippools"],"verbs":["create","patch","list","get","watch"]},{"apiGroups":["crd.projectcalico.org"],"resources":["kubecontrollersconfigurations","bgpconfigurations"],"verbs":["get","list","watch"]},{"apiGroups":["projectcalico.org"],"resources":["ippools"],"verbs":["create","update","delete","patch","get","list","watch"]},{"apiGroups":["projectcalico.org"],"resources":["ipamconfigurations"],"verbs":["get","list","watch"]},{"apiGroups":["scheduling.k8s.io"],"resources":["priorityclasses"],"verbs":["create","get","list","update","delete","watch"]},{"apiGroups":["policy"],"resources":["poddisruptionbudgets"],"verbs":["create","get","list","update","delete","watch"]},{"apiGroups":["apiregistration.k8s.io"],"resources":["apiservices"],"verbs":["list","watch","create","update"]},{"apiGroups":["admissionregistration.k8s.io"],"resources":["mutatingwebhookconfigurations"],"verbs":["delete"]},{"apiGroups":["coordination.k8s.io"],"resources":["leases"],"verbs":["create","get","list","update","delete","watch"]},{"apiGroups":["storage.k8s.io"],"resources":["csidrivers"],"verbs":["list","watch","update","get","create","delete"]},{"apiGroups":["certificates.k8s.io"],"resources":["certificatesigningrequests"],"verbs":["list","watch"]},{"apiGroups":["policy"],"resourceNames":["tigera-operator"],"resources":["podsecuritypolicies"],"verbs":["use"]},{"apiGroups":["policy"],"resources":["podsecuritypolicies"],"verbs":["get","list","watch","create","update","delete"]},{"apiGroups":["projectcalico.org"],"resourceNames":["allow-tigera.*"],"resources":["tier.networkpolicies","tier.globalnetworkpolicies"],"verbs":["list","watch","get","create","update","delete"]},{"apiGroups":["projectcalico.org"],"resourceNames":["allow-tigera"],"resources":["tiers"],"verbs":["get","delete","update"]},{"apiGroups":["projectcalico.org"],"resources":["tiers"],"verbs":["create","list","watch"]}]},{"apiVersion":"rbac.authorization.k8s.io/v1","kind":"ClusterRoleBinding","metadata":{"labels":{"k8s-app":"tigera-operator"},"name":"tigera-operator"},"roleRef":{"apiGroup":"rbac.authorization.k8s.io","kind":"ClusterRole","name":"tigera-operator"},"subjects":[{"kind":"ServiceAccount","name":"tigera-operator","namespace":"tigera-operator"}]},{"apiVersion":"apps/v1","kind":"Deployment","metadata":{"labels":{"k8s-app":"tigera-operator"},"name":"tigera-operator","namespace":"tigera-operator"},"spec":{"replicas":1,"selector":{"matchLabels":{"name":"tigera-operator"}},"template":{"metadata":{"labels":{"k8s-app":"tigera-operator","name":"tigera-operator"}},"spec":{"containers":[{"command":["operator"],"env":[{"name":"WATCH_NAMESPACE","value":""},{"name":"POD_NAME","valueFrom":{"fieldRef":{"fieldPath":"metadata.name"}}},{"name":"OPERATOR_NAME","value":"tigera-operator"},{"name":"TIGERA_OPERATOR_INIT_IMAGE_VERSION","value":"v1.36.9"}],"envFrom":[{"configMapRef":{"name":"kubernetes-services-endpoint","optional":true}}],"image":"quay.io/tigera/operator:v1.36.9","imagePullPolicy":"IfNotPresent","name":"tigera-operator","volumeMounts":[{"mountPath":"/var/lib/calico","name":"var-lib-calico","readOnly":true}]}],"dnsPolicy":"ClusterFirstWithHostNet","hostNetwork":true,"nodeSelector":{"kubernetes.io/os":"linux"},"serviceAccountName":"tigera-operator","terminationGracePeriodSeconds":60,"tolerations":[{"effect":"NoExecute","operator":"Exists"},{"effect":"NoSchedule","operator":"Exists"}],"volumes":[{"hostPath":{"path":"/var/lib/calico"},"name":"var-lib-calico"}]}}}},{"apiVersion":"operator.tigera.io/v1","kind":"APIServer","metadata":{"name":"default","namespace":"tigera-operator"},"spec":{}}]

    '
kind: ConfigMap
metadata:
  creationTimestamp: null
  labels:
    cluster.x-k8s.io/provider: runtime-extension-caren
    clusterctl.cluster.x-k8s.io: ''
  name: tigera-operator
  namespace: cluster-api
---
apiVersion: v1
data:
  cilium.json: '[{"apiVersion":"v1","kind":"Namespace","metadata":{"labels":{"app.kubernetes.io/part-of":"cilium"},"name":"kube-system"}},{"apiVersion":"v1","kind":"ServiceAccount","metadata":{"name":"cilium","namespace":"kube-system"}},{"apiVersion":"v1","kind":"ServiceAccount","metadata":{"name":"cilium-envoy","namespace":"kube-system"}},{"apiVersion":"v1","kind":"ServiceAccount","metadata":{"name":"cilium-operator","namespace":"kube-system"}},{"apiVersion":"v1","data":{"agent-not-ready-taint-key":"node.cilium.io/agent-not-ready","arping-refresh-period":"30s","auto-direct-node-routes":"false","bpf-distributed-lru":"false","bpf-events-drop-enabled":"true","bpf-events-policy-verdict-enabled":"true","bpf-events-trace-enabled":"true","bpf-lb-acceleration":"disabled","bpf-lb-algorithm-annotation":"false","bpf-lb-external-clusterip":"false","bpf-lb-map-max":"65536","bpf-lb-mode-annotation":"false","bpf-lb-sock":"false","bpf-lb-sock-hostns-only":"true","bpf-lb-source-range-all-types":"false","bpf-map-dynamic-size-ratio":"0.0025","bpf-policy-map-max":"16384","bpf-root":"/sys/fs/bpf","cgroup-root":"/run/cilium/cgroupv2","cilium-endpoint-gc-interval":"5m0s","cluster-id":"0","cluster-name":"default","clustermesh-enable-endpoint-sync":"false","clustermesh-enable-mcs-api":"false","cni-chaining-mode":"portmap","cni-exclusive":"false","cni-log-file":"/var/run/cilium/cilium-cni.log","custom-cni-conf":"false","datapath-mode":"veth","debug":"false","debug-verbose":"","default-lb-service-ipam":"lbipam","direct-routing-skip-unreachable":"false","dnsproxy-socket-linger-timeout":"10","egress-gateway-reconciliation-trigger-interval":"1s","enable-auto-protect-node-port-range":"true","enable-bpf-clock-probe":"false","enable-endpoint-health-checking":"true","enable-endpoint-lockdown-on-policy-overflow":"false","enable-experimental-lb":"false","enable-health-check-loadbalancer-ip":"false","enable-health-check-nodeport":"true","enable-health-checking":"true","enable-host-legacy-routing":"true","enable-hubble":"false","enable-internal-traffic-policy":"true","enable-ipv4":"true","enable-ipv4-big-tcp":"false","enable-ipv4-masquerade":"true","enable-ipv6":"false","enable-ipv6-big-tcp":"false","enable-ipv6-masquerade":"true","enable-k8s-networkpolicy":"true","enable-k8s-terminating-endpoint":"true","enable-l2-neigh-discovery":"true","enable-l7-proxy":"true","enable-lb-ipam":"true","enable-local-redirect-policy":"false","enable-masquerade-to-route-source":"false","enable-metrics":"true","enable-node-port":"false","enable-node-selector-labels":"false","enable-non-default-deny-policies":"true","enable-policy":"default","enable-policy-secrets-sync":"true","enable-runtime-device-detection":"true","enable-sctp":"false","enable-source-ip-verification":"true","enable-svc-source-range-check":"true","enable-tcx":"true","enable-vtep":"false","enable-well-known-identities":"false","enable-xt-socket-fallback":"true","envoy-access-log-buffer-size":"4096","envoy-base-id":"0","envoy-keep-cap-netbindservice":"false","external-envoy-proxy":"true","health-check-icmp-failure-threshold":"3","http-retry-count":"3","identity-allocation-mode":"crd","identity-gc-interval":"15m0s","identity-heartbeat-timeout":"30m0s","install-no-conntrack-iptables-rules":"false","ipam":"kubernetes","ipam-cilium-node-update-rate":"15s","iptables-random-fully":"false","k8s-require-ipv4-pod-cidr":"false","k8s-require-ipv6-pod-cidr":"false","kube-proxy-replacement":"false","kube-proxy-replacement-healthz-bind-address":"","max-connected-clusters":"255","mesh-auth-enabled":"true","mesh-auth-gc-interval":"5m0s","mesh-auth-queue-size":"1024","mesh-auth-rotated-identities-queue-size":"1024","monitor-aggregation":"medium","monitor-aggregation-flags":"all","monitor-aggregation-interval":"5s","nat-map-stats-entries":"32","nat-map-stats-interval":"30s","node-port-bind-protection":"true","nodeport-addresses":"","nodes-gc-interval":"5m0s","operator-api-serve-addr":"127.0.0.1:9234","operator-prometheus-serve-addr":":9963","policy-cidr-match-mode":"","policy-secrets-namespace":"cilium-secrets","policy-secrets-only-from-secrets-namespace":"true","preallocate-bpf-maps":"false","procfs":"/host/proc","proxy-connect-timeout":"2","proxy-idle-timeout-seconds":"60","proxy-initial-fetch-timeout":"30","proxy-max-concurrent-retries":"128","proxy-max-connection-duration-seconds":"0","proxy-max-requests-per-connection":"0","proxy-xff-num-trusted-hops-egress":"0","proxy-xff-num-trusted-hops-ingress":"0","remove-cilium-node-taints":"true","routing-mode":"tunnel","service-no-backend-response":"reject","set-cilium-is-up-condition":"true","set-cilium-node-taints":"true","synchronize-k8s-nodes":"true","tofqdns-dns-reject-response-code":"refused","tofqdns-enable-dns-compression":"true","tofqdns-endpoint-max-ip-per-hostname":"1000","tofqdns-idle-connection-grace-period":"0s","tofqdns-max-deferred-connection-deletes":"10000","tofqdns-proxy-response-max-delay":"100ms","tunnel-protocol":"vxlan","tunnel-source-port-range":"0-0","unmanaged-pod-watcher-interval":"15","vtep-cidr":"","vtep-endpoint":"","vtep-mac":"","vtep-mask":"","write-cni-conf-when-ready":"/host/etc/cni/net.d/05-cilium.conflist"},"kind":"ConfigMap","metadata":{"name":"cilium-config","namespace":"kube-system"}},{"apiVersion":"v1","data":{"bootstrap-config.json":"{\"admin\":{\"address\":{\"pipe\":{\"path\":\"/var/run/cilium/envoy/sockets/admin.sock\"}}},\"applicationLogConfig\":{\"logFormat\":{\"textFormat\":\"[%Y-%m-%d
    %T.%e][%t][%l][%n] [%g:%#] %v\"}},\"bootstrapExtensions\":[{\"name\":\"envoy.bootstrap.internal_listener\",\"typedConfig\":{\"@type\":\"type.googleapis.com/envoy.extensions.bootstrap.internal_listener.v3.InternalListener\"}}],\"dynamicResources\":{\"cdsConfig\":{\"apiConfigSource\":{\"apiType\":\"GRPC\",\"grpcServices\":[{\"envoyGrpc\":{\"clusterName\":\"xds-grpc-cilium\"}}],\"setNodeOnFirstMessageOnly\":true,\"transportApiVersion\":\"V3\"},\"initialFetchTimeout\":\"30s\",\"resourceApiVersion\":\"V3\"},\"ldsConfig\":{\"apiConfigSource\":{\"apiType\":\"GRPC\",\"grpcServices\":[{\"envoyGrpc\":{\"clusterName\":\"xds-grpc-cilium\"}}],\"setNodeOnFirstMessageOnly\":true,\"transportApiVersion\":\"V3\"},\"initialFetchTimeout\":\"30s\",\"resourceApiVersion\":\"V3\"}},\"node\":{\"cluster\":\"ingress-cluster\",\"id\":\"host~127.0.0.1~no-id~localdomain\"},\"overloadManager\":{\"resourceMonitors\":[{\"name\":\"envoy.resource_monitors.global_downstream_max_connections\",\"typedConfig\":{\"@type\":\"type.googleapis.com/envoy.extensions.resource_monitors.downstream_connections.v3.DownstreamConnectionsConfig\",\"max_active_downstream_connections\":\"50000\"}}]},\"staticResources\":{\"clusters\":[{\"circuitBreakers\":{\"thresholds\":[{\"maxRetries\":128}]},\"cleanupInterval\":\"2.500s\",\"connectTimeout\":\"2s\",\"lbPolicy\":\"CLUSTER_PROVIDED\",\"name\":\"ingress-cluster\",\"type\":\"ORIGINAL_DST\",\"typedExtensionProtocolOptions\":{\"envoy.extensions.upstreams.http.v3.HttpProtocolOptions\":{\"@type\":\"type.googleapis.com/envoy.extensions.upstreams.http.v3.HttpProtocolOptions\",\"commonHttpProtocolOptions\":{\"idleTimeout\":\"60s\",\"maxConnectionDuration\":\"0s\",\"maxRequestsPerConnection\":0},\"useDownstreamProtocolConfig\":{}}}},{\"circuitBreakers\":{\"thresholds\":[{\"maxRetries\":128}]},\"cleanupInterval\":\"2.500s\",\"connectTimeout\":\"2s\",\"lbPolicy\":\"CLUSTER_PROVIDED\",\"name\":\"egress-cluster-tls\",\"transportSocket\":{\"name\":\"cilium.tls_wrapper\",\"typedConfig\":{\"@type\":\"type.googleapis.com/cilium.UpstreamTlsWrapperContext\"}},\"type\":\"ORIGINAL_DST\",\"typedExtensionProtocolOptions\":{\"envoy.extensions.upstreams.http.v3.HttpProtocolOptions\":{\"@type\":\"type.googleapis.com/envoy.extensions.upstreams.http.v3.HttpProtocolOptions\",\"commonHttpProtocolOptions\":{\"idleTimeout\":\"60s\",\"maxConnectionDuration\":\"0s\",\"maxRequestsPerConnection\":0},\"upstreamHttpProtocolOptions\":{},\"useDownstreamProtocolConfig\":{}}}},{\"circuitBreakers\":{\"thresholds\":[{\"maxRetries\":128}]},\"cleanupInterval\":\"2.500s\",\"connectTimeout\":\"2s\",\"lbPolicy\":\"CLUSTER_PROVIDED\",\"name\":\"egress-cluster\",\"type\":\"ORIGINAL_DST\",\"typedExtensionProtocolOptions\":{\"envoy.extensions.upstreams.http.v3.HttpProtocolOptions\":{\"@type\":\"type.googleapis.com/envoy.extensions.upstreams.http.v3.HttpProtocolOptions\",\"commonHttpProtocolOptions\":{\"idleTimeout\":\"60s\",\"maxConnectionDuration\":\"0s\",\"maxRequestsPerConnection\":0},\"useDownstreamProtocolConfig\":{}}}},{\"circuitBreakers\":{\"thresholds\":[{\"maxRetries\":128}]},\"cleanupInterval\":\"2.500s\",\"connectTimeout\":\"2s\",\"lbPolicy\":\"CLUSTER_PROVIDED\",\"name\":\"ingress-cluster-tls\",\"transportSocket\":{\"name\":\"cilium.tls_wrapper\",\"typedConfig\":{\"@type\":\"type.googleapis.com/cilium.UpstreamTlsWrapperContext\"}},\"type\":\"ORIGINAL_DST\",\"typedExtensionProtocolOptions\":{\"envoy.extensions.upstreams.http.v3.HttpProtocolOptions\":{\"@type\":\"type.googleapis.com/envoy.extensions.upstreams.http.v3.HttpProtocolOptions\",\"commonHttpProtocolOptions\":{\"idleTimeout\":\"60s\",\"maxConnectionDuration\":\"0s\",\"maxRequestsPerConnection\":0},\"upstreamHttpProtocolOptions\":{},\"useDownstreamProtocolConfig\":{}}}},{\"connectTimeout\":\"2s\",\"loadAssignment\":{\"clusterName\":\"xds-grpc-cilium\",\"endpoints\":[{\"lbEndpoints\":[{\"endpoint\":{\"address\":{\"pipe\":{\"path\":\"/var/run/cilium/envoy/sockets/xds.sock\"}}}}]}]},\"name\":\"xds-grpc-cilium\",\"type\":\"STATIC\",\"typedExtensionProtocolOptions\":{\"envoy.extensions.upstreams.http.v3.HttpProtocolOptions\":{\"@type\":\"type.googleapis.com/envoy.extensions.upstreams.http.v3.HttpProtocolOptions\",\"explicitHttpConfig\":{\"http2ProtocolOptions\":{}}}}},{\"connectTimeout\":\"2s\",\"loadAssignment\":{\"clusterName\":\"/envoy-admin\",\"endpoints\":[{\"lbEndpoints\":[{\"endpoint\":{\"address\":{\"pipe\":{\"path\":\"/var/run/cilium/envoy/sockets/admin.sock\"}}}}]}]},\"name\":\"/envoy-admin\",\"type\":\"STATIC\"}],\"listeners\":[{\"address\":{\"socketAddress\":{\"address\":\"0.0.0.0\",\"portValue\":9964}},\"filterChains\":[{\"filters\":[{\"name\":\"envoy.filters.network.http_connection_manager\",\"typedConfig\":{\"@type\":\"type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager\",\"httpFilters\":[{\"name\":\"envoy.filters.http.router\",\"typedConfig\":{\"@type\":\"type.googleapis.com/envoy.extensions.filters.http.router.v3.Router\"}}],\"internalAddressConfig\":{\"cidrRanges\":[{\"addressPrefix\":\"10.0.0.0\",\"prefixLen\":8},{\"addressPrefix\":\"172.16.0.0\",\"prefixLen\":12},{\"addressPrefix\":\"192.168.0.0\",\"prefixLen\":16},{\"addressPrefix\":\"127.0.0.1\",\"prefixLen\":32}]},\"routeConfig\":{\"virtualHosts\":[{\"domains\":[\"*\"],\"name\":\"prometheus_metrics_route\",\"routes\":[{\"match\":{\"prefix\":\"/metrics\"},\"name\":\"prometheus_metrics_route\",\"route\":{\"cluster\":\"/envoy-admin\",\"prefixRewrite\":\"/stats/prometheus\"}}]}]},\"statPrefix\":\"envoy-prometheus-metrics-listener\",\"streamIdleTimeout\":\"0s\"}}]}],\"name\":\"envoy-prometheus-metrics-listener\"},{\"address\":{\"socketAddress\":{\"address\":\"127.0.0.1\",\"portValue\":9878}},\"filterChains\":[{\"filters\":[{\"name\":\"envoy.filters.network.http_connection_manager\",\"typedConfig\":{\"@type\":\"type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager\",\"httpFilters\":[{\"name\":\"envoy.filters.http.router\",\"typedConfig\":{\"@type\":\"type.googleapis.com/envoy.extensions.filters.http.router.v3.Router\"}}],\"internalAddressConfig\":{\"cidrRanges\":[{\"addressPrefix\":\"10.0.0.0\",\"prefixLen\":8},{\"addressPrefix\":\"172.16.0.0\",\"prefixLen\":12},{\"addressPrefix\":\"192.168.0.0\",\"prefixLen\":16},{\"addressPrefix\":\"127.0.0.1\",\"prefixLen\":32}]},\"routeConfig\":{\"virtual_hosts\":[{\"domains\":[\"*\"],\"name\":\"health\",\"routes\":[{\"match\":{\"prefix\":\"/healthz\"},\"name\":\"health\",\"route\":{\"cluster\":\"/envoy-admin\",\"prefixRewrite\":\"/ready\"}}]}]},\"statPrefix\":\"envoy-health-listener\",\"streamIdleTimeout\":\"0s\"}}]}],\"name\":\"envoy-health-listener\"}]}}\n"},"kind":"ConfigMap","metadata":{"name":"cilium-envoy-config","namespace":"kube-system"}},{"apiVersion":"rbac.authorization.k8s.io/v1","kind":"ClusterRole","metadata":{"labels":{"app.kubernetes.io/part-of":"cilium"},"name":"cilium"},"rules":[{"apiGroups":["networking.k8s.io"],"resources":["networkpolicies"],"verbs":["get","list","watch"]},{"apiGroups":["discovery.k8s.io"],"resources":["endpointslices"],"verbs":["get","list","watch"]},{"apiGroups":[""],"resources":["namespaces","services","pods","endpoints","nodes"],"verbs":["get","list","watch"]},{"apiGroups":["apiextensions.k8s.io"],"resources":["customresourcedefinitions"],"verbs":["list","watch","get"]},{"apiGroups":["cilium.io"],"resources":["ciliumloadbalancerippools","ciliumbgppeeringpolicies","ciliumbgpnodeconfigs","ciliumbgpadvertisements","ciliumbgppeerconfigs","ciliumclusterwideenvoyconfigs","ciliumclusterwidenetworkpolicies","ciliumegressgatewaypolicies","ciliumendpoints","ciliumendpointslices","ciliumenvoyconfigs","ciliumidentities","ciliumlocalredirectpolicies","ciliumnetworkpolicies","ciliumnodes","ciliumnodeconfigs","ciliumcidrgroups","ciliuml2announcementpolicies","ciliumpodippools"],"verbs":["list","watch"]},{"apiGroups":["cilium.io"],"resources":["ciliumidentities","ciliumendpoints","ciliumnodes"],"verbs":["create"]},{"apiGroups":["cilium.io"],"resources":["ciliumidentities"],"verbs":["update"]},{"apiGroups":["cilium.io"],"resources":["ciliumendpoints"],"verbs":["delete","get"]},{"apiGroups":["cilium.io"],"resources":["ciliumnodes","ciliumnodes/status"],"verbs":["get","update"]},{"apiGroups":["cilium.io"],"resources":["ciliumendpoints/status","ciliumendpoints","ciliuml2announcementpolicies/status","ciliumbgpnodeconfigs/status"],"verbs":["patch"]}]},{"apiVersion":"rbac.authorization.k8s.io/v1","kind":"ClusterRole","metadata":{"labels":{"app.kubernetes.io/part-of":"cilium"},"name":"cilium-operator"},"rules":[{"apiGroups":[""],"resources":["pods"],"verbs":["get","list","watch","delete"]},{"apiGroups":[""],"resourceNames":["cilium-config"],"resources":["configmaps"],"verbs":["patch"]},{"apiGroups":[""],"resources":["nodes"],"verbs":["list","watch"]},{"apiGroups":[""],"resources":["nodes","nodes/status"],"verbs":["patch"]},{"apiGroups":["discovery.k8s.io"],"resources":["endpointslices"],"verbs":["get","list","watch"]},{"apiGroups":[""],"resources":["services/status"],"verbs":["update","patch"]},{"apiGroups":[""],"resources":["namespaces","secrets"],"verbs":["get","list","watch"]},{"apiGroups":[""],"resources":["services","endpoints"],"verbs":["get","list","watch"]},{"apiGroups":["cilium.io"],"resources":["ciliumnetworkpolicies","ciliumclusterwidenetworkpolicies"],"verbs":["create","update","deletecollection","patch","get","list","watch"]},{"apiGroups":["cilium.io"],"resources":["ciliumnetworkpolicies/status","ciliumclusterwidenetworkpolicies/status"],"verbs":["patch","update"]},{"apiGroups":["cilium.io"],"resources":["ciliumendpoints","ciliumidentities"],"verbs":["delete","list","watch"]},{"apiGroups":["cilium.io"],"resources":["ciliumidentities"],"verbs":["update"]},{"apiGroups":["cilium.io"],"resources":["ciliumnodes"],"verbs":["create","update","get","list","watch","delete"]},{"apiGroups":["cilium.io"],"resources":["ciliumnodes/status"],"verbs":["update"]},{"apiGroups":["cilium.io"],"resources":["ciliumendpointslices","ciliumenvoyconfigs","ciliumbgppeerconfigs","ciliumbgpadvertisements","ciliumbgpnodeconfigs"],"verbs":["create","update","get","list","watch","delete","patch"]},{"apiGroups":["cilium.io"],"resources":["ciliumbgpclusterconfigs/status","ciliumbgppeerconfigs/status"],"verbs":["update"]},{"apiGroups":["apiextensions.k8s.io"],"resources":["customresourcedefinitions"],"verbs":["create","get","list","watch"]},{"apiGroups":["apiextensions.k8s.io"],"resourceNames":["ciliumloadbalancerippools.cilium.io","ciliumbgppeeringpolicies.cilium.io","ciliumbgpclusterconfigs.cilium.io","ciliumbgppeerconfigs.cilium.io","ciliumbgpadvertisements.cilium.io","ciliumbgpnodeconfigs.cilium.io","ciliumbgpnodeconfigoverrides.cilium.io","ciliumclusterwideenvoyconfigs.cilium.io","ciliumclusterwidenetworkpolicies.cilium.io","ciliumegressgatewaypolicies.cilium.io","ciliumendpoints.cilium.io","ciliumendpointslices.cilium.io","ciliumenvoyconfigs.cilium.io","ciliumexternalworkloads.cilium.io","ciliumidentities.cilium.io","ciliumlocalredirectpolicies.cilium.io","ciliumnetworkpolicies.cilium.io","ciliumnodes.cilium.io","ciliumnodeconfigs.cilium.io","ciliumcidrgroups.cilium.io","ciliuml2announcementpolicies.cilium.io","ciliumpodippools.cilium.io"],"resources":["customresourcedefinitions"],"verbs":["update"]},{"apiGroups":["cilium.io"],"resources":["ciliumloadbalancerippools","ciliumpodippools","ciliumbgppeeringpolicies","ciliumbgpclusterconfigs","ciliumbgpnodeconfigoverrides","ciliumbgppeerconfigs"],"verbs":["get","list","watch"]},{"apiGroups":["cilium.io"],"resources":["ciliumpodippools"],"verbs":["create"]},{"apiGroups":["cilium.io"],"resources":["ciliumloadbalancerippools/status"],"verbs":["patch"]},{"apiGroups":["coordination.k8s.io"],"resources":["leases"],"verbs":["create","get","update"]}]},{"apiVersion":"rbac.authorization.k8s.io/v1","kind":"ClusterRoleBinding","metadata":{"labels":{"app.kubernetes.io/part-of":"cilium"},"name":"cilium"},"roleRef":{"apiGroup":"rbac.authorization.k8s.io","kind":"ClusterRole","name":"cilium"},"subjects":[{"kind":"ServiceAccount","name":"cilium","namespace":"kube-system"}]},{"apiVersion":"rbac.authorization.k8s.io/v1","kind":"ClusterRoleBinding","metadata":{"labels":{"app.kubernetes.io/part-of":"cilium"},"name":"cilium-operator"},"roleRef":{"apiGroup":"rbac.authorization.k8s.io","kind":"ClusterRole","name":"cilium-operator"},"subjects":[{"kind":"ServiceAccount","name":"cilium-operator","namespace":"kube-system"}]},{"apiVersion":"rbac.authorization.k8s.io/v1","kind":"Role","metadata":{"labels":{"app.kubernetes.io/part-of":"cilium"},"name":"cilium-config-agent","namespace":"kube-system"},"rules":[{"apiGroups":[""],"resources":["configmaps"],"verbs":["get","list","watch"]}]},{"apiVersion":"rbac.authorization.k8s.io/v1","kind":"Role","metadata":{"labels":{"app.kubernetes.io/part-of":"cilium"},"name":"cilium-tlsinterception-secrets","namespace":"kube-system"},"rules":[{"apiGroups":[""],"resources":["secrets"],"verbs":["get","list","watch"]}]},{"apiVersion":"rbac.authorization.k8s.io/v1","kind":"Role","metadata":{"labels":{"app.kubernetes.io/part-of":"cilium"},"name":"cilium-operator-tlsinterception-secrets","namespace":"kube-system"},"rules":[{"apiGroups":[""],"resources":["secrets"],"verbs":["create","delete","update","patch"]}]},{"apiVersion":"rbac.authorization.k8s.io/v1","kind":"RoleBinding","metadata":{"labels":{"app.kubernetes.io/part-of":"cilium"},"name":"cilium-config-agent","namespace":"kube-system"},"roleRef":{"apiGroup":"rbac.authorization.k8s.io","kind":"Role","name":"cilium-config-agent"},"subjects":[{"kind":"ServiceAccount","name":"cilium","namespace":"kube-system"}]},{"apiVersion":"rbac.authorization.k8s.io/v1","kind":"RoleBinding","metadata":{"labels":{"app.kubernetes.io/part-of":"cilium"},"name":"cilium-tlsinterception-secrets","namespace":"kube-system"},"roleRef":{"apiGroup":"rbac.authorization.k8s.io","kind":"Role","name":"cilium-tlsinterception-secrets"},"subjects":[{"kind":"ServiceAccount","name":"cilium","namespace":"kube-system"}]},{"apiVersion":"rbac.authorization.k8s.io/v1","kind":"RoleBinding","metadata":{"labels":{"app.kubernetes.io/part-of":"cilium"},"name":"cilium-operator-tlsinterception-secrets","namespace":"kube-system"},"roleRef":{"apiGroup":"rbac.authorization.k8s.io","kind":"Role","name":"cilium-operator-tlsinterception-secrets"},"subjects":[{"kind":"ServiceAccount","name":"cilium-operator","namespace":"kube-system"}]},{"apiVersion":"v1","kind":"Service","metadata":{"annotations":{"prometheus.io/port":"9964","prometheus.io/scrape":"true"},"labels":{"app.kubernetes.io/name":"cilium-envoy","app.kubernetes.io/part-of":"cilium","io.cilium/app":"proxy","k8s-app":"cilium-envoy"},"name":"cilium-envoy","namespace":"kube-system"},"spec":{"clusterIP":"None","ports":[{"name":"envoy-metrics","port":9964,"protocol":"TCP","targetPort":"envoy-metrics"}],"selector":{"k8s-app":"cilium-envoy"},"type":"ClusterIP"}},{"apiVersion":"apps/v1","kind":"DaemonSet","metadata":{"labels":{"app.kubernetes.io/name":"cilium-agent","app.kubernetes.io/part-of":"cilium","k8s-app":"cilium"},"name":"cilium","namespace":"kube-system"},"spec":{"selector":{"matchLabels":{"k8s-app":"cilium"}},"template":{"metadata":{"annotations":null,"labels":{"app.kubernetes.io/name":"cilium-agent","app.kubernetes.io/part-of":"cilium","k8s-app":"cilium"}},"spec":{"affinity":{"podAntiAffinity":{"requiredDuringSchedulingIgnoredDuringExecution":[{"labelSelector":{"matchLabels":{"k8s-app":"cilium"}},"topologyKey":"kubernetes.io/hostname"}]}},"automountServiceAccountToken":true,"containers":[{"args":["--config-dir=/tmp/cilium/config-map"],"command":["cilium-agent"],"env":[{"name":"K8S_NODE_NAME","valueFrom":{"fieldRef":{"apiVersion":"v1","fieldPath":"spec.nodeName"}}},{"name":"CILIUM_K8S_NAMESPACE","valueFrom":{"fieldRef":{"apiVersion":"v1","fieldPath":"metadata.namespace"}}},{"name":"CILIUM_CLUSTERMESH_CONFIG","value":"/var/lib/cilium/clustermesh/"},{"name":"GOMEMLIMIT","valueFrom":{"resourceFieldRef":{"divisor":"1","resource":"limits.memory"}}}],"image":"quay.io/cilium/cilium:v1.17.4","imagePullPolicy":"IfNotPresent","lifecycle":{"postStart":{"exec":{"command":["bash","-c","set
    -o errexit\nset -o pipefail\nset -o nounset\n\n# When running in AWS ENI mode,
    it''s likely that ''aws-node'' has\n# had a chance to install SNAT iptables rules.
    These can result\n# in dropped traffic, so we should attempt to remove them.\n#
    We do it using a ''postStart'' hook since this may need to run\n# for nodes which
    might have already been init''ed but may still\n# have dangling rules. This is
    safe because there are no\n# dependencies on anything that is part of the startup
    script\n# itself, and can be safely run multiple times per node (e.g. in\n# case
    of a restart).\nif [[ \"$(iptables-save | grep -E -c ''AWS-SNAT-CHAIN|AWS-CONNMARK-CHAIN'')\"
    != \"0\" ]];\nthen\n    echo ''Deleting iptables rules created by the AWS CNI
    VPC plugin''\n    iptables-save | grep -E -v ''AWS-SNAT-CHAIN|AWS-CONNMARK-CHAIN''
    | iptables-restore\nfi\necho ''Done!''\n"]}},"preStop":{"exec":{"command":["/cni-uninstall.sh"]}}},"livenessProbe":{"failureThreshold":10,"httpGet":{"host":"127.0.0.1","httpHeaders":[{"name":"brief","value":"true"},{"name":"require-k8s-connectivity","value":"false"}],"path":"/healthz","port":9879,"scheme":"HTTP"},"periodSeconds":30,"successThreshold":1,"timeoutSeconds":5},"name":"cilium-agent","readinessProbe":{"failureThreshold":3,"httpGet":{"host":"127.0.0.1","httpHeaders":[{"name":"brief","value":"true"}],"path":"/healthz","port":9879,"scheme":"HTTP"},"periodSeconds":30,"successThreshold":1,"timeoutSeconds":5},"securityContext":{"capabilities":{"add":["CHOWN","KILL","NET_ADMIN","NET_RAW","IPC_LOCK","SYS_MODULE","SYS_ADMIN","SYS_RESOURCE","DAC_OVERRIDE","FOWNER","SETGID","SETUID"],"drop":["ALL"]},"seLinuxOptions":{"level":"s0","type":"spc_t"}},"startupProbe":{"failureThreshold":105,"httpGet":{"host":"127.0.0.1","httpHeaders":[{"name":"brief","value":"true"}],"path":"/healthz","port":9879,"scheme":"HTTP"},"initialDelaySeconds":5,"periodSeconds":2,"successThreshold":1},"terminationMessagePolicy":"FallbackToLogsOnError","volumeMounts":[{"mountPath":"/var/run/cilium/envoy/sockets","name":"envoy-sockets","readOnly":false},{"mountPath":"/host/proc/sys/net","name":"host-proc-sys-net"},{"mountPath":"/host/proc/sys/kernel","name":"host-proc-sys-kernel"},{"mountPath":"/sys/fs/bpf","mountPropagation":"HostToContainer","name":"bpf-maps"},{"mountPath":"/var/run/cilium","name":"cilium-run"},{"mountPath":"/var/run/cilium/netns","mountPropagation":"HostToContainer","name":"cilium-netns"},{"mountPath":"/host/etc/cni/net.d","name":"etc-cni-netd"},{"mountPath":"/var/lib/cilium/clustermesh","name":"clustermesh-secrets","readOnly":true},{"mountPath":"/lib/modules","name":"lib-modules","readOnly":true},{"mountPath":"/run/xtables.lock","name":"xtables-lock"},{"mountPath":"/tmp","name":"tmp"}]}],"hostNetwork":true,"initContainers":[{"command":["cilium-dbg","build-config"],"env":[{"name":"K8S_NODE_NAME","valueFrom":{"fieldRef":{"apiVersion":"v1","fieldPath":"spec.nodeName"}}},{"name":"CILIUM_K8S_NAMESPACE","valueFrom":{"fieldRef":{"apiVersion":"v1","fieldPath":"metadata.namespace"}}}],"image":"quay.io/cilium/cilium:v1.17.4","imagePullPolicy":"IfNotPresent","name":"config","terminationMessagePolicy":"FallbackToLogsOnError","volumeMounts":[{"mountPath":"/tmp","name":"tmp"}]},{"command":["sh","-ec","cp
    /usr/bin/cilium-mount /hostbin/cilium-mount;\nnsenter --cgroup=/hostproc/1/ns/cgroup
    --mount=/hostproc/1/ns/mnt \"${BIN_PATH}/cilium-mount\" $CGROUP_ROOT;\nrm /hostbin/cilium-mount\n"],"env":[{"name":"CGROUP_ROOT","value":"/run/cilium/cgroupv2"},{"name":"BIN_PATH","value":"/opt/cni/bin"}],"image":"quay.io/cilium/cilium:v1.17.4","imagePullPolicy":"IfNotPresent","name":"mount-cgroup","securityContext":{"capabilities":{"add":["SYS_ADMIN","SYS_CHROOT","SYS_PTRACE"],"drop":["ALL"]},"seLinuxOptions":{"level":"s0","type":"spc_t"}},"terminationMessagePolicy":"FallbackToLogsOnError","volumeMounts":[{"mountPath":"/hostproc","name":"hostproc"},{"mountPath":"/hostbin","name":"cni-path"}]},{"command":["sh","-ec","cp
    /usr/bin/cilium-sysctlfix /hostbin/cilium-sysctlfix;\nnsenter --mount=/hostproc/1/ns/mnt
    \"${BIN_PATH}/cilium-sysctlfix\";\nrm /hostbin/cilium-sysctlfix\n"],"env":[{"name":"BIN_PATH","value":"/opt/cni/bin"}],"image":"quay.io/cilium/cilium:v1.17.4","imagePullPolicy":"IfNotPresent","name":"apply-sysctl-overwrites","securityContext":{"capabilities":{"add":["SYS_ADMIN","SYS_CHROOT","SYS_PTRACE"],"drop":["ALL"]},"seLinuxOptions":{"level":"s0","type":"spc_t"}},"terminationMessagePolicy":"FallbackToLogsOnError","volumeMounts":[{"mountPath":"/hostproc","name":"hostproc"},{"mountPath":"/hostbin","name":"cni-path"}]},{"args":["mount
    | grep \"/sys/fs/bpf type bpf\" || mount -t bpf bpf /sys/fs/bpf"],"command":["/bin/bash","-c","--"],"image":"quay.io/cilium/cilium:v1.17.4","imagePullPolicy":"IfNotPresent","name":"mount-bpf-fs","securityContext":{"privileged":true},"terminationMessagePolicy":"FallbackToLogsOnError","volumeMounts":[{"mountPath":"/sys/fs/bpf","mountPropagation":"Bidirectional","name":"bpf-maps"}]},{"command":["/init-container.sh"],"env":[{"name":"CILIUM_ALL_STATE","valueFrom":{"configMapKeyRef":{"key":"clean-cilium-state","name":"cilium-config","optional":true}}},{"name":"CILIUM_BPF_STATE","valueFrom":{"configMapKeyRef":{"key":"clean-cilium-bpf-state","name":"cilium-config","optional":true}}},{"name":"WRITE_CNI_CONF_WHEN_READY","valueFrom":{"configMapKeyRef":{"key":"write-cni-conf-when-ready","name":"cilium-config","optional":true}}}],"image":"quay.io/cilium/cilium:v1.17.4","imagePullPolicy":"IfNotPresent","name":"clean-cilium-state","securityContext":{"capabilities":{"add":["NET_ADMIN","SYS_MODULE","SYS_ADMIN","SYS_RESOURCE"],"drop":["ALL"]},"seLinuxOptions":{"level":"s0","type":"spc_t"}},"terminationMessagePolicy":"FallbackToLogsOnError","volumeMounts":[{"mountPath":"/sys/fs/bpf","name":"bpf-maps"},{"mountPath":"/run/cilium/cgroupv2","mountPropagation":"HostToContainer","name":"cilium-cgroup"},{"mountPath":"/var/run/cilium","name":"cilium-run"}]},{"command":["/install-plugin.sh"],"image":"quay.io/cilium/cilium:v1.17.4","imagePullPolicy":"IfNotPresent","name":"install-cni-binaries","resources":{"requests":{"cpu":"100m","memory":"10Mi"}},"securityContext":{"capabilities":{"drop":["ALL"]},"seLinuxOptions":{"level":"s0","type":"spc_t"}},"terminationMessagePolicy":"FallbackToLogsOnError","volumeMounts":[{"mountPath":"/host/opt/cni/bin","name":"cni-path"}]}],"nodeSelector":{"kubernetes.io/os":"linux"},"priorityClassName":"system-node-critical","restartPolicy":"Always","securityContext":{"appArmorProfile":{"type":"Unconfined"}},"serviceAccountName":"cilium","terminationGracePeriodSeconds":1,"tolerations":[{"operator":"Exists"}],"volumes":[{"emptyDir":{},"name":"tmp"},{"hostPath":{"path":"/var/run/cilium","type":"DirectoryOrCreate"},"name":"cilium-run"},{"hostPath":{"path":"/var/run/netns","type":"DirectoryOrCreate"},"name":"cilium-netns"},{"hostPath":{"path":"/sys/fs/bpf","type":"DirectoryOrCreate"},"name":"bpf-maps"},{"hostPath":{"path":"/proc","type":"Directory"},"name":"hostproc"},{"hostPath":{"path":"/run/cilium/cgroupv2","type":"DirectoryOrCreate"},"name":"cilium-cgroup"},{"hostPath":{"path":"/opt/cni/bin","type":"DirectoryOrCreate"},"name":"cni-path"},{"hostPath":{"path":"/etc/cni/net.d","type":"DirectoryOrCreate"},"name":"etc-cni-netd"},{"hostPath":{"path":"/lib/modules"},"name":"lib-modules"},{"hostPath":{"path":"/run/xtables.lock","type":"FileOrCreate"},"name":"xtables-lock"},{"hostPath":{"path":"/var/run/cilium/envoy/sockets","type":"DirectoryOrCreate"},"name":"envoy-sockets"},{"name":"clustermesh-secrets","projected":{"defaultMode":256,"sources":[{"secret":{"name":"cilium-clustermesh","optional":true}},{"secret":{"items":[{"key":"tls.key","path":"common-etcd-client.key"},{"key":"tls.crt","path":"common-etcd-client.crt"},{"key":"ca.crt","path":"common-etcd-client-ca.crt"}],"name":"clustermesh-apiserver-remote-cert","optional":true}},{"secret":{"items":[{"key":"tls.key","path":"local-etcd-client.key"},{"key":"tls.crt","path":"local-etcd-client.crt"},{"key":"ca.crt","path":"local-etcd-client-ca.crt"}],"name":"clustermesh-apiserver-local-cert","optional":true}}]}},{"hostPath":{"path":"/proc/sys/net","type":"Directory"},"name":"host-proc-sys-net"},{"hostPath":{"path":"/proc/sys/kernel","type":"Directory"},"name":"host-proc-sys-kernel"}]}},"updateStrategy":{"rollingUpdate":{"maxUnavailable":2},"type":"RollingUpdate"}}},{"apiVersion":"apps/v1","kind":"DaemonSet","metadata":{"labels":{"app.kubernetes.io/name":"cilium-envoy","app.kubernetes.io/part-of":"cilium","k8s-app":"cilium-envoy","name":"cilium-envoy"},"name":"cilium-envoy","namespace":"kube-system"},"spec":{"selector":{"matchLabels":{"k8s-app":"cilium-envoy"}},"template":{"metadata":{"annotations":null,"labels":{"app.kubernetes.io/name":"cilium-envoy","app.kubernetes.io/part-of":"cilium","k8s-app":"cilium-envoy","name":"cilium-envoy"}},"spec":{"affinity":{"nodeAffinity":{"requiredDuringSchedulingIgnoredDuringExecution":{"nodeSelectorTerms":[{"matchExpressions":[{"key":"cilium.io/no-schedule","operator":"NotIn","values":["true"]}]}]}},"podAffinity":{"requiredDuringSchedulingIgnoredDuringExecution":[{"labelSelector":{"matchLabels":{"k8s-app":"cilium"}},"topologyKey":"kubernetes.io/hostname"}]},"podAntiAffinity":{"requiredDuringSchedulingIgnoredDuringExecution":[{"labelSelector":{"matchLabels":{"k8s-app":"cilium-envoy"}},"topologyKey":"kubernetes.io/hostname"}]}},"automountServiceAccountToken":true,"containers":[{"args":["--","-c
    /var/run/cilium/envoy/bootstrap-config.json","--base-id 0","--log-level info"],"command":["/usr/bin/cilium-envoy-starter"],"env":[{"name":"K8S_NODE_NAME","valueFrom":{"fieldRef":{"apiVersion":"v1","fieldPath":"spec.nodeName"}}},{"name":"CILIUM_K8S_NAMESPACE","valueFrom":{"fieldRef":{"apiVersion":"v1","fieldPath":"metadata.namespace"}}}],"image":"quay.io/cilium/cilium-envoy:v1.32.6-1746661844-0f602c28cb2aa57b29078195049fb257d5b5246c","imagePullPolicy":"IfNotPresent","livenessProbe":{"failureThreshold":10,"httpGet":{"host":"127.0.0.1","path":"/healthz","port":9878,"scheme":"HTTP"},"periodSeconds":30,"successThreshold":1,"timeoutSeconds":5},"name":"cilium-envoy","ports":[{"containerPort":9964,"hostPort":9964,"name":"envoy-metrics","protocol":"TCP"}],"readinessProbe":{"failureThreshold":3,"httpGet":{"host":"127.0.0.1","path":"/healthz","port":9878,"scheme":"HTTP"},"periodSeconds":30,"successThreshold":1,"timeoutSeconds":5},"securityContext":{"capabilities":{"add":["NET_ADMIN","SYS_ADMIN"],"drop":["ALL"]},"seLinuxOptions":{"level":"s0","type":"spc_t"}},"startupProbe":{"failureThreshold":105,"httpGet":{"host":"127.0.0.1","path":"/healthz","port":9878,"scheme":"HTTP"},"initialDelaySeconds":5,"periodSeconds":2,"successThreshold":1},"terminationMessagePolicy":"FallbackToLogsOnError","volumeMounts":[{"mountPath":"/var/run/cilium/envoy/sockets","name":"envoy-sockets","readOnly":false},{"mountPath":"/var/run/cilium/envoy/artifacts","name":"envoy-artifacts","readOnly":true},{"mountPath":"/var/run/cilium/envoy/","name":"envoy-config","readOnly":true},{"mountPath":"/sys/fs/bpf","mountPropagation":"HostToContainer","name":"bpf-maps"}]}],"hostNetwork":true,"nodeSelector":{"kubernetes.io/os":"linux"},"priorityClassName":"system-node-critical","restartPolicy":"Always","securityContext":{"appArmorProfile":{"type":"Unconfined"}},"serviceAccountName":"cilium-envoy","terminationGracePeriodSeconds":1,"tolerations":[{"operator":"Exists"}],"volumes":[{"hostPath":{"path":"/var/run/cilium/envoy/sockets","type":"DirectoryOrCreate"},"name":"envoy-sockets"},{"hostPath":{"path":"/var/run/cilium/envoy/artifacts","type":"DirectoryOrCreate"},"name":"envoy-artifacts"},{"configMap":{"defaultMode":256,"items":[{"key":"bootstrap-config.json","path":"bootstrap-config.json"}],"name":"cilium-envoy-config"},"name":"envoy-config"},{"hostPath":{"path":"/sys/fs/bpf","type":"DirectoryOrCreate"},"name":"bpf-maps"}]}},"updateStrategy":{"rollingUpdate":{"maxUnavailable":2},"type":"RollingUpdate"}}},{"apiVersion":"apps/v1","kind":"Deployment","metadata":{"labels":{"app.kubernetes.io/name":"cilium-operator","app.kubernetes.io/part-of":"cilium","io.cilium/app":"operator","name":"cilium-operator"},"name":"cilium-operator","namespace":"kube-system"},"spec":{"replicas":2,"selector":{"matchLabels":{"io.cilium/app":"operator","name":"cilium-operator"}},"strategy":{"rollingUpdate":{"maxSurge":"25%","maxUnavailable":"50%"},"type":"RollingUpdate"},"template":{"metadata":{"annotations":{"prometheus.io/port":"9963","prometheus.io/scrape":"true"},"labels":{"app.kubernetes.io/name":"cilium-operator","app.kubernetes.io/part-of":"cilium","io.cilium/app":"operator","name":"cilium-operator"}},"spec":{"affinity":{"podAntiAffinity":{"requiredDuringSchedulingIgnoredDuringExecution":[{"labelSelector":{"matchLabels":{"io.cilium/app":"operator"}},"topologyKey":"kubernetes.io/hostname"}]}},"automountServiceAccountToken":true,"containers":[{"args":["--config-dir=/tmp/cilium/config-map","--debug=$(CILIUM_DEBUG)"],"command":["cilium-operator-generic"],"env":[{"name":"K8S_NODE_NAME","valueFrom":{"fieldRef":{"apiVersion":"v1","fieldPath":"spec.nodeName"}}},{"name":"CILIUM_K8S_NAMESPACE","valueFrom":{"fieldRef":{"apiVersion":"v1","fieldPath":"metadata.namespace"}}},{"name":"CILIUM_DEBUG","valueFrom":{"configMapKeyRef":{"key":"debug","name":"cilium-config","optional":true}}}],"image":"quay.io/cilium/operator-generic:v1.17.4","imagePullPolicy":"IfNotPresent","livenessProbe":{"httpGet":{"host":"127.0.0.1","path":"/healthz","port":9234,"scheme":"HTTP"},"initialDelaySeconds":60,"periodSeconds":10,"timeoutSeconds":3},"name":"cilium-operator","ports":[{"containerPort":9963,"hostPort":9963,"name":"prometheus","protocol":"TCP"}],"readinessProbe":{"failureThreshold":5,"httpGet":{"host":"127.0.0.1","path":"/healthz","port":9234,"scheme":"HTTP"},"initialDelaySeconds":0,"periodSeconds":5,"timeoutSeconds":3},"terminationMessagePolicy":"FallbackToLogsOnError","volumeMounts":[{"mountPath":"/tmp/cilium/config-map","name":"cilium-config-path","readOnly":true}]}],"hostNetwork":true,"nodeSelector":{"kubernetes.io/os":"linux"},"priorityClassName":"system-cluster-critical","restartPolicy":"Always","serviceAccountName":"cilium-operator","tolerations":[{"operator":"Exists"}],"volumes":[{"configMap":{"name":"cilium-config"},"name":"cilium-config-path"}]}}}}]

    '
kind: ConfigMap
metadata:
  creationTimestamp: null
  labels:
    cluster.x-k8s.io/provider: runtime-extension-caren
    clusterctl.cluster.x-k8s.io: ''
  name: cilium
  namespace: cluster-api
---
apiVersion: v1
data:
  values.yaml: "cni:\n  chainingMode: portmap\n  exclusive: false\nhubble:\n  enabled:\
    \ true\n  tls:\n    auto:\n      enabled: true               # enable automatic\
    \ TLS certificate generation\n      method: cronJob             # auto generate\
    \ certificates using cronJob method\n      certValidityDuration: 60    # certificates\
    \ validity duration in days (default 2 months)\n      schedule: \"0 0 1 * *\"\
    \       # schedule on the 1st day regeneration of each month\n  relay:\n    enabled:\
    \ true\n    tls:\n      server:\n        enabled: true\n        mtls: true\n \
    \   image:\n      useDigest: false\n    priorityClassName: system-cluster-critical\n\
    ipam:\n  mode: kubernetes\nimage:\n  useDigest: false\noperator:\n  image:\n \
    \   useDigest: false\ncertgen:\n  image:\n    useDigest: false\nsocketLB:\n  hostNamespaceOnly:\
    \ true\nenvoy:\n  image:\n    useDigest: false"
kind: ConfigMap
metadata:
  labels:
    cluster.x-k8s.io/provider: runtime-extension-caren
    clusterctl.cluster.x-k8s.io: ''
  name: default-cilium-cni-helm-values-template
  namespace: cluster-api
---
apiVersion: v1
data:
  values.yaml: ''
kind: ConfigMap
metadata:
  labels:
    cluster.x-k8s.io/provider: runtime-extension-caren
    clusterctl.cluster.x-k8s.io: ''
  name: default-cosi-controller-helm-values-template
  namespace: cluster-api
---
apiVersion: v1
data:
  aws-ebs-csi.yaml: "apiVersion: v1\nautomountServiceAccountToken: true\nkind: ServiceAccount\n\
    metadata:\n  labels:\n    app.kubernetes.io/component: csi-driver\n    app.kubernetes.io/instance:\
    \ aws-ebs-csi-driver\n    app.kubernetes.io/managed-by: Helm\n    app.kubernetes.io/name:\
    \ aws-ebs-csi-driver\n    app.kubernetes.io/version: 1.44.0\n    helm.sh/chart:\
    \ aws-ebs-csi-driver-2.44.0\n  name: ebs-csi-controller-sa\n  namespace: kube-system\n\
    ---\napiVersion: v1\nautomountServiceAccountToken: true\nkind: ServiceAccount\n\
    metadata:\n  labels:\n    app.kubernetes.io/component: csi-driver\n    app.kubernetes.io/instance:\
    \ aws-ebs-csi-driver\n    app.kubernetes.io/managed-by: Helm\n    app.kubernetes.io/name:\
    \ aws-ebs-csi-driver\n    app.kubernetes.io/version: 1.44.0\n    helm.sh/chart:\
    \ aws-ebs-csi-driver-2.44.0\n  name: ebs-csi-node-sa\n  namespace: kube-system\n\
    ---\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  labels:\n\
    \    app.kubernetes.io/component: csi-driver\n    app.kubernetes.io/instance:\
    \ aws-ebs-csi-driver\n    app.kubernetes.io/managed-by: Helm\n    app.kubernetes.io/name:\
    \ aws-ebs-csi-driver\n    app.kubernetes.io/version: 1.44.0\n    helm.sh/chart:\
    \ aws-ebs-csi-driver-2.44.0\n  name: ebs-csi-leases-role\n  namespace: kube-system\n\
    rules:\n- apiGroups:\n  - coordination.k8s.io\n  resources:\n  - leases\n  verbs:\n\
    \  - get\n  - watch\n  - list\n  - delete\n  - update\n  - create\n---\napiVersion:\
    \ rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  labels:\n    app.kubernetes.io/component:\
    \ csi-driver\n    app.kubernetes.io/instance: aws-ebs-csi-driver\n    app.kubernetes.io/managed-by:\
    \ Helm\n    app.kubernetes.io/name: aws-ebs-csi-driver\n    app.kubernetes.io/version:\
    \ 1.44.0\n    helm.sh/chart: aws-ebs-csi-driver-2.44.0\n  name: ebs-csi-node-role\n\
    rules:\n- apiGroups:\n  - \"\"\n  resources:\n  - nodes\n  verbs:\n  - get\n \
    \ - patch\n- apiGroups:\n  - storage.k8s.io\n  resources:\n  - volumeattachments\n\
    \  verbs:\n  - get\n  - list\n  - watch\n- apiGroups:\n  - storage.k8s.io\n  resources:\n\
    \  - csinodes\n  verbs:\n  - get\n---\napiVersion: rbac.authorization.k8s.io/v1\n\
    kind: ClusterRole\nmetadata:\n  labels:\n    app.kubernetes.io/component: csi-driver\n\
    \    app.kubernetes.io/instance: aws-ebs-csi-driver\n    app.kubernetes.io/managed-by:\
    \ Helm\n    app.kubernetes.io/name: aws-ebs-csi-driver\n    app.kubernetes.io/version:\
    \ 1.44.0\n    helm.sh/chart: aws-ebs-csi-driver-2.44.0\n  name: ebs-external-attacher-role\n\
    rules:\n- apiGroups:\n  - \"\"\n  resources:\n  - persistentvolumes\n  verbs:\n\
    \  - get\n  - list\n  - watch\n  - patch\n- apiGroups:\n  - storage.k8s.io\n \
    \ resources:\n  - csinodes\n  verbs:\n  - get\n  - list\n  - watch\n- apiGroups:\n\
    \  - storage.k8s.io\n  resources:\n  - volumeattachments\n  verbs:\n  - get\n\
    \  - list\n  - watch\n  - patch\n- apiGroups:\n  - storage.k8s.io\n  resources:\n\
    \  - volumeattachments/status\n  verbs:\n  - patch\n---\napiVersion: rbac.authorization.k8s.io/v1\n\
    kind: ClusterRole\nmetadata:\n  labels:\n    app.kubernetes.io/component: csi-driver\n\
    \    app.kubernetes.io/instance: aws-ebs-csi-driver\n    app.kubernetes.io/managed-by:\
    \ Helm\n    app.kubernetes.io/name: aws-ebs-csi-driver\n    app.kubernetes.io/version:\
    \ 1.44.0\n    helm.sh/chart: aws-ebs-csi-driver-2.44.0\n  name: ebs-external-provisioner-role\n\
    rules:\n- apiGroups:\n  - \"\"\n  resources:\n  - persistentvolumes\n  verbs:\n\
    \  - get\n  - list\n  - watch\n  - create\n  - patch\n  - delete\n- apiGroups:\n\
    \  - \"\"\n  resources:\n  - persistentvolumeclaims\n  verbs:\n  - get\n  - list\n\
    \  - watch\n  - update\n- apiGroups:\n  - storage.k8s.io\n  resources:\n  - storageclasses\n\
    \  verbs:\n  - get\n  - list\n  - watch\n- apiGroups:\n  - \"\"\n  resources:\n\
    \  - events\n  verbs:\n  - list\n  - watch\n  - create\n  - update\n  - patch\n\
    - apiGroups:\n  - snapshot.storage.k8s.io\n  resources:\n  - volumesnapshots\n\
    \  verbs:\n  - get\n  - list\n- apiGroups:\n  - snapshot.storage.k8s.io\n  resources:\n\
    \  - volumesnapshotcontents\n  verbs:\n  - get\n  - list\n- apiGroups:\n  - storage.k8s.io\n\
    \  resources:\n  - csinodes\n  verbs:\n  - get\n  - list\n  - watch\n- apiGroups:\n\
    \  - \"\"\n  resources:\n  - nodes\n  verbs:\n  - get\n  - list\n  - watch\n-\
    \ apiGroups:\n  - storage.k8s.io\n  resources:\n  - volumeattachments\n  verbs:\n\
    \  - get\n  - list\n  - watch\n- apiGroups:\n  - storage.k8s.io\n  resources:\n\
    \  - volumeattributesclasses\n  verbs:\n  - get\n---\napiVersion: rbac.authorization.k8s.io/v1\n\
    kind: ClusterRole\nmetadata:\n  labels:\n    app.kubernetes.io/component: csi-driver\n\
    \    app.kubernetes.io/instance: aws-ebs-csi-driver\n    app.kubernetes.io/managed-by:\
    \ Helm\n    app.kubernetes.io/name: aws-ebs-csi-driver\n    app.kubernetes.io/version:\
    \ 1.44.0\n    helm.sh/chart: aws-ebs-csi-driver-2.44.0\n  name: ebs-external-resizer-role\n\
    rules:\n- apiGroups:\n  - \"\"\n  resources:\n  - persistentvolumes\n  verbs:\n\
    \  - get\n  - list\n  - watch\n  - patch\n- apiGroups:\n  - \"\"\n  resources:\n\
    \  - persistentvolumeclaims\n  verbs:\n  - get\n  - list\n  - watch\n- apiGroups:\n\
    \  - \"\"\n  resources:\n  - pods\n  verbs:\n  - get\n  - list\n  - watch\n- apiGroups:\n\
    \  - \"\"\n  resources:\n  - persistentvolumeclaims/status\n  verbs:\n  - patch\n\
    - apiGroups:\n  - \"\"\n  resources:\n  - events\n  verbs:\n  - list\n  - watch\n\
    \  - create\n  - update\n  - patch\n- apiGroups:\n  - storage.k8s.io\n  resources:\n\
    \  - volumeattributesclasses\n  verbs:\n  - get\n  - list\n  - watch\n---\napiVersion:\
    \ rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  labels:\n    app.kubernetes.io/component:\
    \ csi-driver\n    app.kubernetes.io/instance: aws-ebs-csi-driver\n    app.kubernetes.io/managed-by:\
    \ Helm\n    app.kubernetes.io/name: aws-ebs-csi-driver\n    app.kubernetes.io/version:\
    \ 1.44.0\n    helm.sh/chart: aws-ebs-csi-driver-2.44.0\n  name: ebs-external-snapshotter-role\n\
    rules:\n- apiGroups:\n  - \"\"\n  resources:\n  - events\n  verbs:\n  - list\n\
    \  - watch\n  - create\n  - update\n  - patch\n- apiGroups:\n  - snapshot.storage.k8s.io\n\
    \  resources:\n  - volumesnapshotclasses\n  verbs:\n  - get\n  - list\n  - watch\n\
    - apiGroups:\n  - snapshot.storage.k8s.io\n  resources:\n  - volumesnapshotcontents\n\
    \  verbs:\n  - get\n  - list\n  - watch\n  - update\n  - patch\n- apiGroups:\n\
    \  - snapshot.storage.k8s.io\n  resources:\n  - volumesnapshotcontents/status\n\
    \  verbs:\n  - update\n  - patch\n- apiGroups:\n  - groupsnapshot.storage.k8s.io\n\
    \  resources:\n  - volumegroupsnapshotclasses\n  verbs:\n  - get\n  - list\n \
    \ - watch\n- apiGroups:\n  - groupsnapshot.storage.k8s.io\n  resources:\n  - volumegroupsnapshotcontents\n\
    \  verbs:\n  - get\n  - list\n  - watch\n  - update\n  - patch\n- apiGroups:\n\
    \  - groupsnapshot.storage.k8s.io\n  resources:\n  - volumegroupsnapshotcontents/status\n\
    \  verbs:\n  - update\n  - patch\n---\napiVersion: rbac.authorization.k8s.io/v1\n\
    kind: RoleBinding\nmetadata:\n  labels:\n    app.kubernetes.io/component: csi-driver\n\
    \    app.kubernetes.io/instance: aws-ebs-csi-driver\n    app.kubernetes.io/managed-by:\
    \ Helm\n    app.kubernetes.io/name: aws-ebs-csi-driver\n    app.kubernetes.io/version:\
    \ 1.44.0\n    helm.sh/chart: aws-ebs-csi-driver-2.44.0\n  name: ebs-csi-leases-rolebinding\n\
    \  namespace: kube-system\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n \
    \ kind: Role\n  name: ebs-csi-leases-role\nsubjects:\n- kind: ServiceAccount\n\
    \  name: ebs-csi-controller-sa\n  namespace: kube-system\n---\napiVersion: rbac.authorization.k8s.io/v1\n\
    kind: ClusterRoleBinding\nmetadata:\n  labels:\n    app.kubernetes.io/component:\
    \ csi-driver\n    app.kubernetes.io/instance: aws-ebs-csi-driver\n    app.kubernetes.io/managed-by:\
    \ Helm\n    app.kubernetes.io/name: aws-ebs-csi-driver\n    app.kubernetes.io/version:\
    \ 1.44.0\n    helm.sh/chart: aws-ebs-csi-driver-2.44.0\n  name: ebs-csi-attacher-binding\n\
    roleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name:\
    \ ebs-external-attacher-role\nsubjects:\n- kind: ServiceAccount\n  name: ebs-csi-controller-sa\n\
    \  namespace: kube-system\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind:\
    \ ClusterRoleBinding\nmetadata:\n  labels:\n    app.kubernetes.io/component: csi-driver\n\
    \    app.kubernetes.io/instance: aws-ebs-csi-driver\n    app.kubernetes.io/managed-by:\
    \ Helm\n    app.kubernetes.io/name: aws-ebs-csi-driver\n    app.kubernetes.io/version:\
    \ 1.44.0\n    helm.sh/chart: aws-ebs-csi-driver-2.44.0\n  name: ebs-csi-node-getter-binding\n\
    roleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name:\
    \ ebs-csi-node-role\nsubjects:\n- kind: ServiceAccount\n  name: ebs-csi-node-sa\n\
    \  namespace: kube-system\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind:\
    \ ClusterRoleBinding\nmetadata:\n  labels:\n    app.kubernetes.io/component: csi-driver\n\
    \    app.kubernetes.io/instance: aws-ebs-csi-driver\n    app.kubernetes.io/managed-by:\
    \ Helm\n    app.kubernetes.io/name: aws-ebs-csi-driver\n    app.kubernetes.io/version:\
    \ 1.44.0\n    helm.sh/chart: aws-ebs-csi-driver-2.44.0\n  name: ebs-csi-provisioner-binding\n\
    roleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name:\
    \ ebs-external-provisioner-role\nsubjects:\n- kind: ServiceAccount\n  name: ebs-csi-controller-sa\n\
    \  namespace: kube-system\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind:\
    \ ClusterRoleBinding\nmetadata:\n  labels:\n    app.kubernetes.io/component: csi-driver\n\
    \    app.kubernetes.io/instance: aws-ebs-csi-driver\n    app.kubernetes.io/managed-by:\
    \ Helm\n    app.kubernetes.io/name: aws-ebs-csi-driver\n    app.kubernetes.io/version:\
    \ 1.44.0\n    helm.sh/chart: aws-ebs-csi-driver-2.44.0\n  name: ebs-csi-resizer-binding\n\
    roleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name:\
    \ ebs-external-resizer-role\nsubjects:\n- kind: ServiceAccount\n  name: ebs-csi-controller-sa\n\
    \  namespace: kube-system\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind:\
    \ ClusterRoleBinding\nmetadata:\n  labels:\n    app.kubernetes.io/component: csi-driver\n\
    \    app.kubernetes.io/instance: aws-ebs-csi-driver\n    app.kubernetes.io/managed-by:\
    \ Helm\n    app.kubernetes.io/name: aws-ebs-csi-driver\n    app.kubernetes.io/version:\
    \ 1.44.0\n    helm.sh/chart: aws-ebs-csi-driver-2.44.0\n  name: ebs-csi-snapshotter-binding\n\
    roleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name:\
    \ ebs-external-snapshotter-role\nsubjects:\n- kind: ServiceAccount\n  name: ebs-csi-controller-sa\n\
    \  namespace: kube-system\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n\
    \  labels:\n    app.kubernetes.io/component: csi-driver\n    app.kubernetes.io/instance:\
    \ aws-ebs-csi-driver\n    app.kubernetes.io/managed-by: Helm\n    app.kubernetes.io/name:\
    \ aws-ebs-csi-driver\n    app.kubernetes.io/version: 1.44.0\n    helm.sh/chart:\
    \ aws-ebs-csi-driver-2.44.0\n  name: ebs-csi-controller\n  namespace: kube-system\n\
    spec:\n  replicas: 2\n  revisionHistoryLimit: 10\n  selector:\n    matchLabels:\n\
    \      app: ebs-csi-controller\n      app.kubernetes.io/instance: aws-ebs-csi-driver\n\
    \      app.kubernetes.io/name: aws-ebs-csi-driver\n  strategy:\n    rollingUpdate:\n\
    \      maxUnavailable: 1\n    type: RollingUpdate\n  template:\n    metadata:\n\
    \      labels:\n        app: ebs-csi-controller\n        app.kubernetes.io/component:\
    \ csi-driver\n        app.kubernetes.io/instance: aws-ebs-csi-driver\n       \
    \ app.kubernetes.io/managed-by: Helm\n        app.kubernetes.io/name: aws-ebs-csi-driver\n\
    \        app.kubernetes.io/version: 1.44.0\n        helm.sh/chart: aws-ebs-csi-driver-2.44.0\n\
    \    spec:\n      affinity:\n        nodeAffinity:\n          preferredDuringSchedulingIgnoredDuringExecution:\n\
    \          - preference:\n              matchExpressions:\n              - key:\
    \ eks.amazonaws.com/compute-type\n                operator: NotIn\n          \
    \      values:\n                - fargate\n                - auto\n          \
    \      - hybrid\n            weight: 1\n          requiredDuringSchedulingIgnoredDuringExecution:\n\
    \            nodeSelectorTerms:\n            - matchExpressions:\n           \
    \   - key: node-role.kubernetes.io/control-plane\n                operator: Exists\n\
    \        podAntiAffinity:\n          preferredDuringSchedulingIgnoredDuringExecution:\n\
    \          - podAffinityTerm:\n              labelSelector:\n                matchExpressions:\n\
    \                - key: app\n                  operator: In\n                \
    \  values:\n                  - ebs-csi-controller\n              topologyKey:\
    \ kubernetes.io/hostname\n            weight: 100\n      containers:\n      -\
    \ args:\n        - controller\n        - --endpoint=$(CSI_ENDPOINT)\n        -\
    \ --batching=true\n        - --logging-format=text\n        - --user-agent-extra=helm\n\
    \        - --v=2\n        env:\n        - name: CSI_ENDPOINT\n          value:\
    \ unix:///var/lib/csi/sockets/pluginproxy/csi.sock\n        - name: CSI_NODE_NAME\n\
    \          valueFrom:\n            fieldRef:\n              fieldPath: spec.nodeName\n\
    \        - name: AWS_ACCESS_KEY_ID\n          valueFrom:\n            secretKeyRef:\n\
    \              key: key_id\n              name: aws-secret\n              optional:\
    \ true\n        - name: AWS_SECRET_ACCESS_KEY\n          valueFrom:\n        \
    \    secretKeyRef:\n              key: access_key\n              name: aws-secret\n\
    \              optional: true\n        - name: AWS_EC2_ENDPOINT\n          valueFrom:\n\
    \            configMapKeyRef:\n              key: endpoint\n              name:\
    \ aws-meta\n              optional: true\n        image: public.ecr.aws/ebs-csi-driver/aws-ebs-csi-driver:v1.44.0\n\
    \        imagePullPolicy: IfNotPresent\n        livenessProbe:\n          failureThreshold:\
    \ 5\n          httpGet:\n            path: /healthz\n            port: healthz\n\
    \          initialDelaySeconds: 10\n          periodSeconds: 10\n          timeoutSeconds:\
    \ 3\n        name: ebs-plugin\n        ports:\n        - containerPort: 9808\n\
    \          name: healthz\n          protocol: TCP\n        readinessProbe:\n \
    \         failureThreshold: 5\n          httpGet:\n            path: /healthz\n\
    \            port: healthz\n          initialDelaySeconds: 10\n          periodSeconds:\
    \ 10\n          timeoutSeconds: 3\n        resources:\n          limits:\n   \
    \         memory: 256Mi\n          requests:\n            cpu: 10m\n         \
    \   memory: 40Mi\n        securityContext:\n          allowPrivilegeEscalation:\
    \ false\n          readOnlyRootFilesystem: true\n          seccompProfile:\n \
    \           type: RuntimeDefault\n        volumeMounts:\n        - mountPath:\
    \ /var/lib/csi/sockets/pluginproxy/\n          name: socket-dir\n      - args:\n\
    \        - --timeout=60s\n        - --csi-address=$(ADDRESS)\n        - --v=2\n\
    \        - --feature-gates=Topology=true\n        - --extra-create-metadata\n\
    \        - --leader-election=true\n        - --default-fstype=ext4\n        -\
    \ --kube-api-qps=20\n        - --kube-api-burst=100\n        - --worker-threads=100\n\
    \        - --retry-interval-max=30m\n        env:\n        - name: ADDRESS\n \
    \         value: /var/lib/csi/sockets/pluginproxy/csi.sock\n        image: public.ecr.aws/eks-distro/kubernetes-csi/external-provisioner:v5.2.0-eks-1-33-3\n\
    \        imagePullPolicy: IfNotPresent\n        name: csi-provisioner\n      \
    \  resources:\n          limits:\n            memory: 256Mi\n          requests:\n\
    \            cpu: 10m\n            memory: 40Mi\n        securityContext:\n  \
    \        allowPrivilegeEscalation: false\n          readOnlyRootFilesystem: true\n\
    \          seccompProfile:\n            type: RuntimeDefault\n        volumeMounts:\n\
    \        - mountPath: /var/lib/csi/sockets/pluginproxy/\n          name: socket-dir\n\
    \      - args:\n        - --timeout=60s\n        - --csi-address=$(ADDRESS)\n\
    \        - --v=2\n        - --leader-election=true\n        - --kube-api-qps=20\n\
    \        - --kube-api-burst=100\n        - --worker-threads=100\n        - --retry-interval-max=5m\n\
    \        env:\n        - name: ADDRESS\n          value: /var/lib/csi/sockets/pluginproxy/csi.sock\n\
    \        image: public.ecr.aws/eks-distro/kubernetes-csi/external-attacher:v4.8.1-eks-1-33-3\n\
    \        imagePullPolicy: IfNotPresent\n        name: csi-attacher\n        resources:\n\
    \          limits:\n            memory: 256Mi\n          requests:\n         \
    \   cpu: 10m\n            memory: 40Mi\n        securityContext:\n          allowPrivilegeEscalation:\
    \ false\n          readOnlyRootFilesystem: true\n          seccompProfile:\n \
    \           type: RuntimeDefault\n        volumeMounts:\n        - mountPath:\
    \ /var/lib/csi/sockets/pluginproxy/\n          name: socket-dir\n      - args:\n\
    \        - --csi-address=$(ADDRESS)\n        - --leader-election=true\n      \
    \  - --v=2\n        - --extra-create-metadata\n        - --kube-api-qps=20\n \
    \       - --kube-api-burst=100\n        - --worker-threads=100\n        - --retry-interval-max=30m\n\
    \        env:\n        - name: ADDRESS\n          value: /var/lib/csi/sockets/pluginproxy/csi.sock\n\
    \        image: public.ecr.aws/eks-distro/kubernetes-csi/external-snapshotter/csi-snapshotter:v8.2.1-eks-1-33-3\n\
    \        imagePullPolicy: IfNotPresent\n        name: csi-snapshotter\n      \
    \  resources:\n          limits:\n            memory: 256Mi\n          requests:\n\
    \            cpu: 10m\n            memory: 40Mi\n        securityContext:\n  \
    \        allowPrivilegeEscalation: false\n          readOnlyRootFilesystem: true\n\
    \          seccompProfile:\n            type: RuntimeDefault\n        volumeMounts:\n\
    \        - mountPath: /var/lib/csi/sockets/pluginproxy/\n          name: socket-dir\n\
    \      - args:\n        - --timeout=60s\n        - --extra-modify-metadata\n \
    \       - --csi-address=$(ADDRESS)\n        - --v=2\n        - --handle-volume-inuse-error=false\n\
    \        - --leader-election=true\n        - --kube-api-qps=20\n        - --kube-api-burst=100\n\
    \        - --workers=100\n        - --retry-interval-max=30m\n        env:\n \
    \       - name: ADDRESS\n          value: /var/lib/csi/sockets/pluginproxy/csi.sock\n\
    \        image: public.ecr.aws/eks-distro/kubernetes-csi/external-resizer:v1.13.2-eks-1-33-3\n\
    \        imagePullPolicy: IfNotPresent\n        name: csi-resizer\n        resources:\n\
    \          limits:\n            memory: 256Mi\n          requests:\n         \
    \   cpu: 10m\n            memory: 40Mi\n        securityContext:\n          allowPrivilegeEscalation:\
    \ false\n          readOnlyRootFilesystem: true\n          seccompProfile:\n \
    \           type: RuntimeDefault\n        volumeMounts:\n        - mountPath:\
    \ /var/lib/csi/sockets/pluginproxy/\n          name: socket-dir\n      - args:\n\
    \        - --csi-address=/csi/csi.sock\n        image: public.ecr.aws/eks-distro/kubernetes-csi/livenessprobe:v2.15.0-eks-1-33-3\n\
    \        imagePullPolicy: IfNotPresent\n        name: liveness-probe\n       \
    \ resources:\n          limits:\n            memory: 256Mi\n          requests:\n\
    \            cpu: 10m\n            memory: 40Mi\n        securityContext:\n  \
    \        allowPrivilegeEscalation: false\n          readOnlyRootFilesystem: true\n\
    \        volumeMounts:\n        - mountPath: /csi\n          name: socket-dir\n\
    \      nodeSelector:\n        kubernetes.io/os: linux\n      priorityClassName:\
    \ system-cluster-critical\n      securityContext:\n        fsGroup: 1000\n   \
    \     runAsGroup: 1000\n        runAsNonRoot: true\n        runAsUser: 1000\n\
    \      serviceAccountName: ebs-csi-controller-sa\n      tolerations:\n      -\
    \ key: CriticalAddonsOnly\n        operator: Exists\n      - effect: NoExecute\n\
    \        operator: Exists\n        tolerationSeconds: 300\n      - effect: NoSchedule\n\
    \        operator: Exists\n      volumes:\n      - emptyDir: {}\n        name:\
    \ socket-dir\n---\napiVersion: policy/v1\nkind: PodDisruptionBudget\nmetadata:\n\
    \  labels:\n    app.kubernetes.io/component: csi-driver\n    app.kubernetes.io/instance:\
    \ aws-ebs-csi-driver\n    app.kubernetes.io/managed-by: Helm\n    app.kubernetes.io/name:\
    \ aws-ebs-csi-driver\n    app.kubernetes.io/version: 1.44.0\n    helm.sh/chart:\
    \ aws-ebs-csi-driver-2.44.0\n  name: ebs-csi-controller\n  namespace: kube-system\n\
    spec:\n  maxUnavailable: 1\n  selector:\n    matchLabels:\n      app: ebs-csi-controller\n\
    \      app.kubernetes.io/instance: aws-ebs-csi-driver\n      app.kubernetes.io/name:\
    \ aws-ebs-csi-driver\n---\napiVersion: apps/v1\nkind: DaemonSet\nmetadata:\n \
    \ labels:\n    app.kubernetes.io/component: csi-driver\n    app.kubernetes.io/instance:\
    \ aws-ebs-csi-driver\n    app.kubernetes.io/managed-by: Helm\n    app.kubernetes.io/name:\
    \ aws-ebs-csi-driver\n    app.kubernetes.io/version: 1.44.0\n    helm.sh/chart:\
    \ aws-ebs-csi-driver-2.44.0\n  name: ebs-csi-node\n  namespace: kube-system\n\
    spec:\n  revisionHistoryLimit: 10\n  selector:\n    matchLabels:\n      app: ebs-csi-node\n\
    \      app.kubernetes.io/instance: aws-ebs-csi-driver\n      app.kubernetes.io/name:\
    \ aws-ebs-csi-driver\n  template:\n    metadata:\n      labels:\n        app:\
    \ ebs-csi-node\n        app.kubernetes.io/component: csi-driver\n        app.kubernetes.io/instance:\
    \ aws-ebs-csi-driver\n        app.kubernetes.io/managed-by: Helm\n        app.kubernetes.io/name:\
    \ aws-ebs-csi-driver\n        app.kubernetes.io/version: 1.44.0\n        helm.sh/chart:\
    \ aws-ebs-csi-driver-2.44.0\n    spec:\n      affinity:\n        nodeAffinity:\n\
    \          requiredDuringSchedulingIgnoredDuringExecution:\n            nodeSelectorTerms:\n\
    \            - matchExpressions:\n              - key: eks.amazonaws.com/compute-type\n\
    \                operator: NotIn\n                values:\n                - fargate\n\
    \                - auto\n                - hybrid\n              - key: node.kubernetes.io/instance-type\n\
    \                operator: NotIn\n                values:\n                - a1.medium\n\
    \                - a1.large\n                - a1.xlarge\n                - a1.2xlarge\n\
    \                - a1.4xlarge\n      containers:\n      - args:\n        - node\n\
    \        - --endpoint=$(CSI_ENDPOINT)\n        - --csi-mount-point-prefix=/var/lib/kubelet/plugins/kubernetes.io/csi/ebs.csi.aws.com/\n\
    \        - --logging-format=text\n        - --v=2\n        env:\n        - name:\
    \ CSI_ENDPOINT\n          value: unix:/csi/csi.sock\n        - name: CSI_NODE_NAME\n\
    \          valueFrom:\n            fieldRef:\n              fieldPath: spec.nodeName\n\
    \        image: public.ecr.aws/ebs-csi-driver/aws-ebs-csi-driver:v1.44.0\n   \
    \     imagePullPolicy: IfNotPresent\n        lifecycle:\n          preStop:\n\
    \            exec:\n              command:\n              - /bin/aws-ebs-csi-driver\n\
    \              - pre-stop-hook\n        livenessProbe:\n          failureThreshold:\
    \ 5\n          httpGet:\n            path: /healthz\n            port: healthz\n\
    \          initialDelaySeconds: 10\n          periodSeconds: 10\n          timeoutSeconds:\
    \ 3\n        name: ebs-plugin\n        ports:\n        - containerPort: 9808\n\
    \          name: healthz\n          protocol: TCP\n        resources:\n      \
    \    limits:\n            memory: 256Mi\n          requests:\n            cpu:\
    \ 10m\n            memory: 40Mi\n        securityContext:\n          privileged:\
    \ true\n          readOnlyRootFilesystem: true\n        volumeMounts:\n      \
    \  - mountPath: /var/lib/kubelet\n          mountPropagation: Bidirectional\n\
    \          name: kubelet-dir\n        - mountPath: /csi\n          name: plugin-dir\n\
    \        - mountPath: /dev\n          name: device-dir\n      - args:\n      \
    \  - --csi-address=$(ADDRESS)\n        - --kubelet-registration-path=$(DRIVER_REG_SOCK_PATH)\n\
    \        - --v=2\n        env:\n        - name: ADDRESS\n          value: /csi/csi.sock\n\
    \        - name: DRIVER_REG_SOCK_PATH\n          value: /var/lib/kubelet/plugins/ebs.csi.aws.com/csi.sock\n\
    \        image: public.ecr.aws/eks-distro/kubernetes-csi/node-driver-registrar:v2.13.0-eks-1-33-3\n\
    \        imagePullPolicy: IfNotPresent\n        livenessProbe:\n          exec:\n\
    \            command:\n            - /csi-node-driver-registrar\n            -\
    \ --kubelet-registration-path=$(DRIVER_REG_SOCK_PATH)\n            - --mode=kubelet-registration-probe\n\
    \          initialDelaySeconds: 30\n          periodSeconds: 90\n          timeoutSeconds:\
    \ 15\n        name: node-driver-registrar\n        resources:\n          limits:\n\
    \            memory: 256Mi\n          requests:\n            cpu: 10m\n      \
    \      memory: 40Mi\n        securityContext:\n          allowPrivilegeEscalation:\
    \ false\n          readOnlyRootFilesystem: true\n        volumeMounts:\n     \
    \   - mountPath: /csi\n          name: plugin-dir\n        - mountPath: /registration\n\
    \          name: registration-dir\n        - mountPath: /var/lib/kubelet/plugins/ebs.csi.aws.com/\n\
    \          name: probe-dir\n      - args:\n        - --csi-address=/csi/csi.sock\n\
    \        image: public.ecr.aws/eks-distro/kubernetes-csi/livenessprobe:v2.15.0-eks-1-33-3\n\
    \        imagePullPolicy: IfNotPresent\n        name: liveness-probe\n       \
    \ resources:\n          limits:\n            memory: 256Mi\n          requests:\n\
    \            cpu: 10m\n            memory: 40Mi\n        securityContext:\n  \
    \        allowPrivilegeEscalation: false\n          readOnlyRootFilesystem: true\n\
    \        volumeMounts:\n        - mountPath: /csi\n          name: plugin-dir\n\
    \      hostNetwork: false\n      nodeSelector:\n        kubernetes.io/os: linux\n\
    \      priorityClassName: system-node-critical\n      securityContext:\n     \
    \   fsGroup: 0\n        runAsGroup: 0\n        runAsNonRoot: false\n        runAsUser:\
    \ 0\n      serviceAccountName: ebs-csi-node-sa\n      terminationGracePeriodSeconds:\
    \ 30\n      tolerations:\n      - operator: Exists\n      volumes:\n      - hostPath:\n\
    \          path: /var/lib/kubelet\n          type: Directory\n        name: kubelet-dir\n\
    \      - hostPath:\n          path: /var/lib/kubelet/plugins/ebs.csi.aws.com/\n\
    \          type: DirectoryOrCreate\n        name: plugin-dir\n      - hostPath:\n\
    \          path: /var/lib/kubelet/plugins_registry/\n          type: Directory\n\
    \        name: registration-dir\n      - hostPath:\n          path: /dev\n   \
    \       type: Directory\n        name: device-dir\n      - emptyDir: {}\n    \
    \    name: probe-dir\n  updateStrategy:\n    rollingUpdate:\n      maxUnavailable:\
    \ 10%\n    type: RollingUpdate\n---\napiVersion: apps/v1\nkind: DaemonSet\nmetadata:\n\
    \  labels:\n    app.kubernetes.io/component: csi-driver\n    app.kubernetes.io/instance:\
    \ aws-ebs-csi-driver\n    app.kubernetes.io/managed-by: Helm\n    app.kubernetes.io/name:\
    \ aws-ebs-csi-driver\n    app.kubernetes.io/version: 1.44.0\n    helm.sh/chart:\
    \ aws-ebs-csi-driver-2.44.0\n  name: ebs-csi-node-windows\n  namespace: kube-system\n\
    spec:\n  revisionHistoryLimit: 10\n  selector:\n    matchLabels:\n      app: ebs-csi-node\n\
    \      app.kubernetes.io/instance: aws-ebs-csi-driver\n      app.kubernetes.io/name:\
    \ aws-ebs-csi-driver\n  template:\n    metadata:\n      labels:\n        app:\
    \ ebs-csi-node\n        app.kubernetes.io/component: csi-driver\n        app.kubernetes.io/instance:\
    \ aws-ebs-csi-driver\n        app.kubernetes.io/managed-by: Helm\n        app.kubernetes.io/name:\
    \ aws-ebs-csi-driver\n        app.kubernetes.io/version: 1.44.0\n        helm.sh/chart:\
    \ aws-ebs-csi-driver-2.44.0\n    spec:\n      affinity:\n        nodeAffinity:\n\
    \          requiredDuringSchedulingIgnoredDuringExecution:\n            nodeSelectorTerms:\n\
    \            - matchExpressions:\n              - key: eks.amazonaws.com/compute-type\n\
    \                operator: NotIn\n                values:\n                - fargate\n\
    \                - auto\n                - hybrid\n              - key: node.kubernetes.io/instance-type\n\
    \                operator: NotIn\n                values:\n                - a1.medium\n\
    \                - a1.large\n                - a1.xlarge\n                - a1.2xlarge\n\
    \                - a1.4xlarge\n      containers:\n      - args:\n        - node\n\
    \        - --endpoint=$(CSI_ENDPOINT)\n        - --logging-format=text\n     \
    \   - --v=2\n        env:\n        - name: CSI_ENDPOINT\n          value: unix:/csi/csi.sock\n\
    \        - name: CSI_NODE_NAME\n          valueFrom:\n            fieldRef:\n\
    \              fieldPath: spec.nodeName\n        image: public.ecr.aws/ebs-csi-driver/aws-ebs-csi-driver:v1.44.0\n\
    \        imagePullPolicy: IfNotPresent\n        lifecycle:\n          preStop:\n\
    \            exec:\n              command:\n              - /bin/aws-ebs-csi-driver\n\
    \              - pre-stop-hook\n        livenessProbe:\n          failureThreshold:\
    \ 5\n          httpGet:\n            path: /healthz\n            port: healthz\n\
    \          initialDelaySeconds: 10\n          periodSeconds: 10\n          timeoutSeconds:\
    \ 3\n        name: ebs-plugin\n        ports:\n        - containerPort: 9808\n\
    \          name: healthz\n          protocol: TCP\n        resources:\n      \
    \    limits:\n            memory: 256Mi\n          requests:\n            cpu:\
    \ 10m\n            memory: 40Mi\n        securityContext:\n          windowsOptions:\n\
    \            runAsUserName: ContainerAdministrator\n        volumeMounts:\n  \
    \      - mountPath: C:\\var\\lib\\kubelet\n          mountPropagation: None\n\
    \          name: kubelet-dir\n        - mountPath: C:\\csi\n          name: plugin-dir\n\
    \        - mountPath: \\\\.\\pipe\\csi-proxy-disk-v1\n          name: csi-proxy-disk-pipe\n\
    \        - mountPath: \\\\.\\pipe\\csi-proxy-volume-v1\n          name: csi-proxy-volume-pipe\n\
    \        - mountPath: \\\\.\\pipe\\csi-proxy-filesystem-v1\n          name: csi-proxy-filesystem-pipe\n\
    \      - args:\n        - --csi-address=$(ADDRESS)\n        - --kubelet-registration-path=$(DRIVER_REG_SOCK_PATH)\n\
    \        - --v=2\n        env:\n        - name: ADDRESS\n          value: unix:/csi/csi.sock\n\
    \        - name: DRIVER_REG_SOCK_PATH\n          value: C:\\var\\lib\\kubelet\\\
    plugins\\ebs.csi.aws.com\\csi.sock\n        image: public.ecr.aws/eks-distro/kubernetes-csi/node-driver-registrar:v2.13.0-eks-1-33-3\n\
    \        imagePullPolicy: IfNotPresent\n        livenessProbe:\n          exec:\n\
    \            command:\n            - /csi-node-driver-registrar.exe\n        \
    \    - --kubelet-registration-path=$(DRIVER_REG_SOCK_PATH)\n            - --mode=kubelet-registration-probe\n\
    \          initialDelaySeconds: 30\n          periodSeconds: 90\n          timeoutSeconds:\
    \ 15\n        name: node-driver-registrar\n        resources:\n          limits:\n\
    \            memory: 256Mi\n          requests:\n            cpu: 10m\n      \
    \      memory: 40Mi\n        volumeMounts:\n        - mountPath: C:\\csi\n   \
    \       name: plugin-dir\n        - mountPath: C:\\registration\n          name:\
    \ registration-dir\n        - mountPath: C:\\var\\lib\\kubelet\\plugins\\ebs.csi.aws.com\n\
    \          name: probe-dir\n      - args:\n        - --csi-address=unix:/csi/csi.sock\n\
    \        image: public.ecr.aws/eks-distro/kubernetes-csi/livenessprobe:v2.15.0-eks-1-33-3\n\
    \        imagePullPolicy: IfNotPresent\n        name: liveness-probe\n       \
    \ resources:\n          limits:\n            memory: 256Mi\n          requests:\n\
    \            cpu: 10m\n            memory: 40Mi\n        volumeMounts:\n     \
    \   - mountPath: C:\\csi\n          name: plugin-dir\n      nodeSelector:\n  \
    \      kubernetes.io/os: windows\n      priorityClassName: system-node-critical\n\
    \      serviceAccountName: ebs-csi-node-sa\n      terminationGracePeriodSeconds:\
    \ 30\n      tolerations:\n      - operator: Exists\n      volumes:\n      - hostPath:\n\
    \          path: C:\\var\\lib\\kubelet\n          type: Directory\n        name:\
    \ kubelet-dir\n      - hostPath:\n          path: C:\\var\\lib\\kubelet\\plugins\\\
    ebs.csi.aws.com\n          type: DirectoryOrCreate\n        name: plugin-dir\n\
    \      - hostPath:\n          path: C:\\var\\lib\\kubelet\\plugins_registry\n\
    \          type: Directory\n        name: registration-dir\n      - hostPath:\n\
    \          path: \\\\.\\pipe\\csi-proxy-disk-v1\n          type: \"\"\n      \
    \  name: csi-proxy-disk-pipe\n      - hostPath:\n          path: \\\\.\\pipe\\\
    csi-proxy-volume-v1\n          type: \"\"\n        name: csi-proxy-volume-pipe\n\
    \      - hostPath:\n          path: \\\\.\\pipe\\csi-proxy-filesystem-v1\n   \
    \       type: \"\"\n        name: csi-proxy-filesystem-pipe\n      - emptyDir:\
    \ {}\n        name: probe-dir\n  updateStrategy:\n    rollingUpdate:\n      maxUnavailable:\
    \ 10%\n    type: RollingUpdate\n---\napiVersion: storage.k8s.io/v1\nkind: CSIDriver\n\
    metadata:\n  labels:\n    app.kubernetes.io/component: csi-driver\n    app.kubernetes.io/instance:\
    \ aws-ebs-csi-driver\n    app.kubernetes.io/managed-by: Helm\n    app.kubernetes.io/name:\
    \ aws-ebs-csi-driver\n    app.kubernetes.io/version: 1.44.0\n    helm.sh/chart:\
    \ aws-ebs-csi-driver-2.44.0\n  name: ebs.csi.aws.com\nspec:\n  attachRequired:\
    \ true\n  fsGroupPolicy: File\n  podInfoOnMount: false\n"
kind: ConfigMap
metadata:
  creationTimestamp: null
  labels:
    cluster.x-k8s.io/provider: runtime-extension-caren
    clusterctl.cluster.x-k8s.io: ''
  name: aws-ebs-csi
  namespace: cluster-api
---
apiVersion: v1
data:
  values.yaml: "controller:\n  affinity:\n    nodeAffinity:\n      requiredDuringSchedulingIgnoredDuringExecution:\n\
    \        nodeSelectorTerms:\n          - matchExpressions:\n              - key:\
    \ node-role.kubernetes.io/control-plane\n                operator: Exists\n  tolerations:\n\
    \    - key: CriticalAddonsOnly\n      operator: Exists\n    - effect: NoExecute\n\
    \      operator: Exists\n      tolerationSeconds: 300\n    - effect: NoSchedule\n\
    \      operator: Exists\nnode:\n  priorityClassName: system-node-critical\nsidecars:\n\
    \  snapshotter:\n    forceEnable: true"
kind: ConfigMap
metadata:
  labels:
    cluster.x-k8s.io/provider: runtime-extension-caren
    clusterctl.cluster.x-k8s.io: ''
  name: default-aws-ebs-csi-helm-values-template
  namespace: cluster-api
---
apiVersion: v1
data:
  values.yaml: "storageClass:\n  create: false\n  provisionerName: rancher.io/local-path\n\
    helperImage:\n  tag: 1.36.1\ntolerations:\n  - key: CriticalAddonsOnly\n    operator:\
    \ Exists\n  - effect: NoExecute\n    operator: Exists\n    tolerationSeconds:\
    \ 300\n  - effect: NoSchedule\n    operator: Exists"
kind: ConfigMap
metadata:
  labels:
    cluster.x-k8s.io/provider: runtime-extension-caren
    clusterctl.cluster.x-k8s.io: ''
  name: default-local-path-provisioner-csi-helm-values-template
  namespace: cluster-api
---
apiVersion: v1
data:
  local-path-provisioner-csi.yaml: "apiVersion: v1\nimagePullSecrets: null\nkind:\
    \ ServiceAccount\nmetadata:\n  labels:\n    app.kubernetes.io/instance: local-path-provisioner-csi\n\
    \    app.kubernetes.io/managed-by: Helm\n    app.kubernetes.io/name: local-path-provisioner\n\
    \    app.kubernetes.io/version: v0.0.30\n    helm.sh/chart: local-path-provisioner-0.0.31\n\
    \  name: local-path-provisioner-csi\n  namespace: kube-system\n---\napiVersion:\
    \ rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  labels:\n    app.kubernetes.io/instance:\
    \ local-path-provisioner-csi\n    app.kubernetes.io/managed-by: Helm\n    app.kubernetes.io/name:\
    \ local-path-provisioner\n    app.kubernetes.io/version: v0.0.30\n    helm.sh/chart:\
    \ local-path-provisioner-0.0.31\n  name: local-path-provisioner-csi\n  namespace:\
    \ kube-system\nrules:\n- apiGroups:\n  - \"\"\n  resources:\n  - pods\n  verbs:\n\
    \  - get\n  - list\n  - watch\n  - create\n  - patch\n  - update\n  - delete\n\
    ---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n\
    \  labels:\n    app.kubernetes.io/instance: local-path-provisioner-csi\n    app.kubernetes.io/managed-by:\
    \ Helm\n    app.kubernetes.io/name: local-path-provisioner\n    app.kubernetes.io/version:\
    \ v0.0.30\n    helm.sh/chart: local-path-provisioner-0.0.31\n  name: local-path-provisioner-csi\n\
    rules:\n- apiGroups:\n  - \"\"\n  resources:\n  - nodes\n  - persistentvolumeclaims\n\
    \  - configmaps\n  - pods\n  - pods/log\n  verbs:\n  - get\n  - list\n  - watch\n\
    - apiGroups:\n  - \"\"\n  resources:\n  - persistentvolumes\n  verbs:\n  - get\n\
    \  - list\n  - watch\n  - create\n  - patch\n  - update\n  - delete\n- apiGroups:\n\
    \  - \"\"\n  resources:\n  - events\n  verbs:\n  - create\n  - patch\n- apiGroups:\n\
    \  - storage.k8s.io\n  resources:\n  - storageclasses\n  verbs:\n  - get\n  -\
    \ list\n  - watch\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\n\
    metadata:\n  labels:\n    app.kubernetes.io/instance: local-path-provisioner-csi\n\
    \    app.kubernetes.io/managed-by: Helm\n    app.kubernetes.io/name: local-path-provisioner\n\
    \    app.kubernetes.io/version: v0.0.30\n    helm.sh/chart: local-path-provisioner-0.0.31\n\
    \  name: local-path-provisioner-csi\n  namespace: kube-system\nroleRef:\n  apiGroup:\
    \ rbac.authorization.k8s.io\n  kind: Role\n  name: local-path-provisioner-csi\n\
    subjects:\n- kind: ServiceAccount\n  name: local-path-provisioner-csi\n  namespace:\
    \ kube-system\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\n\
    metadata:\n  labels:\n    app.kubernetes.io/instance: local-path-provisioner-csi\n\
    \    app.kubernetes.io/managed-by: Helm\n    app.kubernetes.io/name: local-path-provisioner\n\
    \    app.kubernetes.io/version: v0.0.30\n    helm.sh/chart: local-path-provisioner-0.0.31\n\
    \  name: local-path-provisioner-csi\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n\
    \  kind: ClusterRole\n  name: local-path-provisioner-csi\nsubjects:\n- kind: ServiceAccount\n\
    \  name: local-path-provisioner-csi\n  namespace: kube-system\n---\napiVersion:\
    \ v1\ndata:\n  config.json: |-\n    {\n      \"nodePathMap\": [\n        {\n \
    \         \"node\": \"DEFAULT_PATH_FOR_NON_LISTED_NODES\",\n          \"paths\"\
    : [\n            \"/opt/local-path-provisioner\"\n          ]\n        }\n   \
    \   ]\n    }\n  helperPod.yaml: |-\n    apiVersion: v1\n    kind: Pod\n    metadata:\n\
    \      name: helper-pod\n      namespace: kube-system\n    spec:\n      priorityClassName:\
    \ system-node-critical\n      tolerations:\n        - key: node.kubernetes.io/disk-pressure\n\
    \          operator: Exists\n          effect: NoSchedule\n      containers:\n\
    \        - name: helper-pod\n          image: busybox:1.36.1\n          imagePullPolicy:\
    \ IfNotPresent\n          resources:\n            {}\n  setup: |-\n    #!/bin/sh\n\
    \    set -eu\n    mkdir -m 0777 -p \"$VOL_DIR\"\n  teardown: |-\n    #!/bin/sh\n\
    \    set -eu\n    rm -rf \"$VOL_DIR\"\nkind: ConfigMap\nmetadata:\n  labels:\n\
    \    app.kubernetes.io/instance: local-path-provisioner-csi\n    app.kubernetes.io/managed-by:\
    \ Helm\n    app.kubernetes.io/name: local-path-provisioner\n    app.kubernetes.io/version:\
    \ v0.0.30\n    helm.sh/chart: local-path-provisioner-0.0.31\n  name: local-path-config\n\
    \  namespace: kube-system\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n\
    \  labels:\n    app.kubernetes.io/instance: local-path-provisioner-csi\n    app.kubernetes.io/managed-by:\
    \ Helm\n    app.kubernetes.io/name: local-path-provisioner\n    app.kubernetes.io/version:\
    \ v0.0.30\n    helm.sh/chart: local-path-provisioner-0.0.31\n  name: local-path-provisioner-csi\n\
    \  namespace: kube-system\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n\
    \      app.kubernetes.io/instance: local-path-provisioner-csi\n      app.kubernetes.io/name:\
    \ local-path-provisioner\n  template:\n    metadata:\n      labels:\n        app.kubernetes.io/instance:\
    \ local-path-provisioner-csi\n        app.kubernetes.io/managed-by: Helm\n   \
    \     app.kubernetes.io/name: local-path-provisioner\n        app.kubernetes.io/version:\
    \ v0.0.30\n        helm.sh/chart: local-path-provisioner-0.0.31\n    spec:\n \
    \     containers:\n      - command:\n        - local-path-provisioner\n      \
    \  - --debug\n        - start\n        - --config\n        - /etc/config/config.json\n\
    \        - --service-account-name\n        - local-path-provisioner-csi\n    \
    \    - --provisioner-name\n        - rancher.io/local-path\n        - --helper-image\n\
    \        - busybox:1.36.1\n        - --configmap-name\n        - local-path-config\n\
    \        env:\n        - name: POD_NAMESPACE\n          value: kube-system\n \
    \       - name: CONFIG_MOUNT_PATH\n          value: /etc/config/\n        image:\
    \ rancher/local-path-provisioner:v0.0.30\n        imagePullPolicy: IfNotPresent\n\
    \        name: local-path-provisioner\n        resources: {}\n        securityContext:\
    \ {}\n        volumeMounts:\n        - mountPath: /etc/config/\n          name:\
    \ config-volume\n      securityContext: {}\n      serviceAccountName: local-path-provisioner-csi\n\
    \      tolerations:\n      - key: CriticalAddonsOnly\n        operator: Exists\n\
    \      - effect: NoExecute\n        operator: Exists\n        tolerationSeconds:\
    \ 300\n      - effect: NoSchedule\n        operator: Exists\n      volumes:\n\
    \      - configMap:\n          name: local-path-config\n        name: config-volume\n"
kind: ConfigMap
metadata:
  creationTimestamp: null
  labels:
    cluster.x-k8s.io/provider: runtime-extension-caren
    clusterctl.cluster.x-k8s.io: ''
  name: local-path-provisioner-csi
  namespace: cluster-api
---
apiVersion: v1
data:
  values.yaml: "# Disable creating the Prism Central credentials Secret, the Secret\
    \ will be created by the handler.\ncreatePrismCentralSecret: false\n# Disable\
    \ creating the Prism Element credentials Secret, it won't be used the CSI driver\
    \ as configured here.\ncreateSecret: false\npcSecretName: nutanix-csi-credentials\n\
    \ntolerations:\n  - key: CriticalAddonsOnly\n    operator: Exists\n  - effect:\
    \ NoExecute\n    operator: Exists\n    tolerationSeconds: 300\n  - effect: NoSchedule\n\
    \    operator: Exists"
kind: ConfigMap
metadata:
  labels:
    cluster.x-k8s.io/provider: runtime-extension-caren
    clusterctl.cluster.x-k8s.io: ''
  name: default-nutanix-csi-helm-values-template
  namespace: cluster-api
---
apiVersion: v1
data:
  values.yaml: "controller:\n  priorityClassName: system-cluster-critical\n  tolerations:\n\
    \    - key: CriticalAddonsOnly\n      operator: Exists\n    - effect: NoExecute\n\
    \      operator: Exists\n      tolerationSeconds: 300\n    - effect: NoSchedule\n\
    \      key: node-role.kubernetes.io/control-plane\n      operator: Exists\nwebhook:\n\
    \  enabled: false"
kind: ConfigMap
metadata:
  labels:
    cluster.x-k8s.io/provider: runtime-extension-caren
    clusterctl.cluster.x-k8s.io: ''
  name: default-snapshot-controller-helm-values-template
  namespace: cluster-api
---
apiVersion: v1
data:
  snapshot-controller.yaml: "apiVersion: apiextensions.k8s.io/v1\nkind: CustomResourceDefinition\n\
    metadata:\n  annotations:\n    api-approved.kubernetes.io: https://github.com/kubernetes-csi/external-snapshotter/pull/1150\n\
    \    controller-gen.kubebuilder.io/version: v0.15.0\n  name: volumegroupsnapshotclasses.groupsnapshot.storage.k8s.io\n\
    spec:\n  group: groupsnapshot.storage.k8s.io\n  names:\n    kind: VolumeGroupSnapshotClass\n\
    \    listKind: VolumeGroupSnapshotClassList\n    plural: volumegroupsnapshotclasses\n\
    \    shortNames:\n    - vgsclass\n    - vgsclasses\n    singular: volumegroupsnapshotclass\n\
    \  scope: Cluster\n  versions:\n  - additionalPrinterColumns:\n    - jsonPath:\
    \ .driver\n      name: Driver\n      type: string\n    - description: Determines\
    \ whether a VolumeGroupSnapshotContent created through\n        the VolumeGroupSnapshotClass\
    \ should be deleted when its bound VolumeGroupSnapshot\n        is deleted.\n\
    \      jsonPath: .deletionPolicy\n      name: DeletionPolicy\n      type: string\n\
    \    - jsonPath: .metadata.creationTimestamp\n      name: Age\n      type: date\n\
    \    name: v1beta1\n    schema:\n      openAPIV3Schema:\n        description:\
    \ |-\n          VolumeGroupSnapshotClass specifies parameters that a underlying\
    \ storage system\n          uses when creating a volume group snapshot. A specific\
    \ VolumeGroupSnapshotClass\n          is used by specifying its name in a VolumeGroupSnapshot\
    \ object.\n          VolumeGroupSnapshotClasses are non-namespaced.\n        properties:\n\
    \          apiVersion:\n            description: |-\n              APIVersion\
    \ defines the versioned schema of this representation of an object.\n        \
    \      Servers should convert recognized schemas to the latest internal value,\
    \ and\n              may reject unrecognized values.\n              More info:\
    \ https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources\n\
    \            type: string\n          deletionPolicy:\n            description:\
    \ |-\n              DeletionPolicy determines whether a VolumeGroupSnapshotContent\
    \ created\n              through the VolumeGroupSnapshotClass should be deleted\
    \ when its bound\n              VolumeGroupSnapshot is deleted.\n            \
    \  Supported values are \"Retain\" and \"Delete\".\n              \"Retain\" means\
    \ that the VolumeGroupSnapshotContent and its physical group\n              snapshot\
    \ on underlying storage system are kept.\n              \"Delete\" means that\
    \ the VolumeGroupSnapshotContent and its physical group\n              snapshot\
    \ on underlying storage system are deleted.\n              Required.\n       \
    \     enum:\n            - Delete\n            - Retain\n            type: string\n\
    \          driver:\n            description: |-\n              Driver is the name\
    \ of the storage driver expected to handle this VolumeGroupSnapshotClass.\n  \
    \            Required.\n            type: string\n          kind:\n          \
    \  description: |-\n              Kind is a string value representing the REST\
    \ resource this object represents.\n              Servers may infer this from\
    \ the endpoint the client submits requests to.\n              Cannot be updated.\n\
    \              In CamelCase.\n              More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds\n\
    \            type: string\n          metadata:\n            type: object\n   \
    \       parameters:\n            additionalProperties:\n              type: string\n\
    \            description: |-\n              Parameters is a key-value map with\
    \ storage driver specific parameters for\n              creating group snapshots.\n\
    \              These values are opaque to Kubernetes and are passed directly to\
    \ the driver.\n            type: object\n        required:\n        - deletionPolicy\n\
    \        - driver\n        type: object\n    served: true\n    storage: true\n\
    \    subresources: {}\n---\napiVersion: apiextensions.k8s.io/v1\nkind: CustomResourceDefinition\n\
    metadata:\n  annotations:\n    api-approved.kubernetes.io: https://github.com/kubernetes-csi/external-snapshotter/pull/1150\n\
    \    controller-gen.kubebuilder.io/version: v0.15.0\n  name: volumegroupsnapshotcontents.groupsnapshot.storage.k8s.io\n\
    spec:\n  group: groupsnapshot.storage.k8s.io\n  names:\n    kind: VolumeGroupSnapshotContent\n\
    \    listKind: VolumeGroupSnapshotContentList\n    plural: volumegroupsnapshotcontents\n\
    \    shortNames:\n    - vgsc\n    - vgscs\n    singular: volumegroupsnapshotcontent\n\
    \  scope: Cluster\n  versions:\n  - additionalPrinterColumns:\n    - description:\
    \ Indicates if all the individual snapshots in the group are ready\n        to\
    \ be used to restore a group of volumes.\n      jsonPath: .status.readyToUse\n\
    \      name: ReadyToUse\n      type: boolean\n    - description: Determines whether\
    \ this VolumeGroupSnapshotContent and its physical\n        group snapshot on\
    \ the underlying storage system should be deleted when its\n        bound VolumeGroupSnapshot\
    \ is deleted.\n      jsonPath: .spec.deletionPolicy\n      name: DeletionPolicy\n\
    \      type: string\n    - description: Name of the CSI driver used to create\
    \ the physical group snapshot\n        on the underlying storage system.\n   \
    \   jsonPath: .spec.driver\n      name: Driver\n      type: string\n    - description:\
    \ Name of the VolumeGroupSnapshotClass from which this group snapshot\n      \
    \  was (or will be) created.\n      jsonPath: .spec.volumeGroupSnapshotClassName\n\
    \      name: VolumeGroupSnapshotClass\n      type: string\n    - description:\
    \ Namespace of the VolumeGroupSnapshot object to which this VolumeGroupSnapshotContent\n\
    \        object is bound.\n      jsonPath: .spec.volumeGroupSnapshotRef.namespace\n\
    \      name: VolumeGroupSnapshotNamespace\n      type: string\n    - description:\
    \ Name of the VolumeGroupSnapshot object to which this VolumeGroupSnapshotContent\n\
    \        object is bound.\n      jsonPath: .spec.volumeGroupSnapshotRef.name\n\
    \      name: VolumeGroupSnapshot\n      type: string\n    - jsonPath: .metadata.creationTimestamp\n\
    \      name: Age\n      type: date\n    name: v1beta1\n    schema:\n      openAPIV3Schema:\n\
    \        description: |-\n          VolumeGroupSnapshotContent represents the\
    \ actual \"on-disk\" group snapshot object\n          in the underlying storage\
    \ system\n        properties:\n          apiVersion:\n            description:\
    \ |-\n              APIVersion defines the versioned schema of this representation\
    \ of an object.\n              Servers should convert recognized schemas to the\
    \ latest internal value, and\n              may reject unrecognized values.\n\
    \              More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources\n\
    \            type: string\n          kind:\n            description: |-\n    \
    \          Kind is a string value representing the REST resource this object represents.\n\
    \              Servers may infer this from the endpoint the client submits requests\
    \ to.\n              Cannot be updated.\n              In CamelCase.\n       \
    \       More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds\n\
    \            type: string\n          metadata:\n            type: object\n   \
    \       spec:\n            description: |-\n              Spec defines properties\
    \ of a VolumeGroupSnapshotContent created by the underlying storage system.\n\
    \              Required.\n            properties:\n              deletionPolicy:\n\
    \                description: |-\n                  DeletionPolicy determines\
    \ whether this VolumeGroupSnapshotContent and the\n                  physical\
    \ group snapshot on the underlying storage system should be deleted\n        \
    \          when the bound VolumeGroupSnapshot is deleted.\n                  Supported\
    \ values are \"Retain\" and \"Delete\".\n                  \"Retain\" means that\
    \ the VolumeGroupSnapshotContent and its physical group\n                  snapshot\
    \ on underlying storage system are kept.\n                  \"Delete\" means that\
    \ the VolumeGroupSnapshotContent and its physical group\n                  snapshot\
    \ on underlying storage system are deleted.\n                  For dynamically\
    \ provisioned group snapshots, this field will automatically\n               \
    \   be filled in by the CSI snapshotter sidecar with the \"DeletionPolicy\" field\n\
    \                  defined in the corresponding VolumeGroupSnapshotClass.\n  \
    \                For pre-existing snapshots, users MUST specify this field when\
    \ creating the\n                  VolumeGroupSnapshotContent object.\n       \
    \           Required.\n                enum:\n                - Delete\n     \
    \           - Retain\n                type: string\n              driver:\n  \
    \              description: |-\n                  Driver is the name of the CSI\
    \ driver used to create the physical group snapshot on\n                  the\
    \ underlying storage system.\n                  This MUST be the same as the name\
    \ returned by the CSI GetPluginName() call for\n                  that driver.\n\
    \                  Required.\n                type: string\n              source:\n\
    \                description: |-\n                  Source specifies whether the\
    \ snapshot is (or should be) dynamically provisioned\n                  or already\
    \ exists, and just requires a Kubernetes object representation.\n            \
    \      This field is immutable after creation.\n                  Required.\n\
    \                properties:\n                  groupSnapshotHandles:\n      \
    \              description: |-\n                      GroupSnapshotHandles specifies\
    \ the CSI \"group_snapshot_id\" of a pre-existing\n                      group\
    \ snapshot and a list of CSI \"snapshot_id\" of pre-existing snapshots\n     \
    \                 on the underlying storage system for which a Kubernetes object\n\
    \                      representation was (or should be) created.\n          \
    \            This field is immutable.\n                    properties:\n     \
    \                 volumeGroupSnapshotHandle:\n                        description:\
    \ |-\n                          VolumeGroupSnapshotHandle specifies the CSI \"\
    group_snapshot_id\" of a pre-existing\n                          group snapshot\
    \ on the underlying storage system for which a Kubernetes object\n           \
    \               representation was (or should be) created.\n                 \
    \         This field is immutable.\n                          Required.\n    \
    \                    type: string\n                      volumeSnapshotHandles:\n\
    \                        description: |-\n                          VolumeSnapshotHandles\
    \ is a list of CSI \"snapshot_id\" of pre-existing\n                         \
    \ snapshots on the underlying storage system for which Kubernetes objects\n  \
    \                        representation were (or should be) created.\n       \
    \                   This field is immutable.\n                          Required.\n\
    \                        items:\n                          type: string\n    \
    \                    type: array\n                    required:\n            \
    \        - volumeGroupSnapshotHandle\n                    - volumeSnapshotHandles\n\
    \                    type: object\n                    x-kubernetes-validations:\n\
    \                    - message: groupSnapshotHandles is immutable\n          \
    \            rule: self == oldSelf\n                  volumeHandles:\n       \
    \             description: |-\n                      VolumeHandles is a list of\
    \ volume handles on the backend to be snapshotted\n                      together.\
    \ It is specified for dynamic provisioning of the VolumeGroupSnapshot.\n     \
    \                 This field is immutable.\n                    items:\n     \
    \                 type: string\n                    type: array\n            \
    \        x-kubernetes-validations:\n                    - message: volumeHandles\
    \ is immutable\n                      rule: self == oldSelf\n                type:\
    \ object\n                x-kubernetes-validations:\n                - message:\
    \ volumeHandles is required once set\n                  rule: '!has(oldSelf.volumeHandles)\
    \ || has(self.volumeHandles)'\n                - message: groupSnapshotHandles\
    \ is required once set\n                  rule: '!has(oldSelf.groupSnapshotHandles)\
    \ || has(self.groupSnapshotHandles)'\n                - message: exactly one of\
    \ volumeHandles and groupSnapshotHandles must\n                    be set\n  \
    \                rule: (has(self.volumeHandles) && !has(self.groupSnapshotHandles))\n\
    \                    || (!has(self.volumeHandles) && has(self.groupSnapshotHandles))\n\
    \              volumeGroupSnapshotClassName:\n                description: |-\n\
    \                  VolumeGroupSnapshotClassName is the name of the VolumeGroupSnapshotClass\
    \ from\n                  which this group snapshot was (or will be) created.\n\
    \                  Note that after provisioning, the VolumeGroupSnapshotClass\
    \ may be deleted or\n                  recreated with different set of values,\
    \ and as such, should not be referenced\n                  post-snapshot creation.\n\
    \                  For dynamic provisioning, this field must be set.\n       \
    \           This field may be unset for pre-provisioned snapshots.\n         \
    \       type: string\n              volumeGroupSnapshotRef:\n                description:\
    \ |-\n                  VolumeGroupSnapshotRef specifies the VolumeGroupSnapshot\
    \ object to which this\n                  VolumeGroupSnapshotContent object is\
    \ bound.\n                  VolumeGroupSnapshot.Spec.VolumeGroupSnapshotContentName\
    \ field must reference to\n                  this VolumeGroupSnapshotContent's\
    \ name for the bidirectional binding to be valid.\n                  For a pre-existing\
    \ VolumeGroupSnapshotContent object, name and namespace of the\n             \
    \     VolumeGroupSnapshot object MUST be provided for binding to happen.\n   \
    \               This field is immutable after creation.\n                  Required.\n\
    \                properties:\n                  apiVersion:\n                \
    \    description: API version of the referent.\n                    type: string\n\
    \                  fieldPath:\n                    description: |-\n         \
    \             If referring to a piece of an object instead of an entire object,\
    \ this string\n                      should contain a valid JSON/Go field access\
    \ statement, such as desiredState.manifest.containers[2].\n                  \
    \    For example, if the object reference is to a container within a pod, this\
    \ would take on a value like:\n                      \"spec.containers{name}\"\
    \ (where \"name\" refers to the name of the container that triggered\n       \
    \               the event) or if no container name is specified \"spec.containers[2]\"\
    \ (container with\n                      index 2 in this pod). This syntax is\
    \ chosen only to have some well-defined way of\n                      referencing\
    \ a part of an object.\n                      TODO: this design is not final and\
    \ this field is subject to change in the future.\n                    type: string\n\
    \                  kind:\n                    description: |-\n              \
    \        Kind of the referent.\n                      More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds\n\
    \                    type: string\n                  name:\n                 \
    \   description: |-\n                      Name of the referent.\n           \
    \           More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names\n\
    \                    type: string\n                  namespace:\n            \
    \        description: |-\n                      Namespace of the referent.\n \
    \                     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/\n\
    \                    type: string\n                  resourceVersion:\n      \
    \              description: |-\n                      Specific resourceVersion\
    \ to which this reference is made, if any.\n                      More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency\n\
    \                    type: string\n                  uid:\n                  \
    \  description: |-\n                      UID of the referent.\n             \
    \         More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids\n\
    \                    type: string\n                type: object\n            \
    \    x-kubernetes-map-type: atomic\n                x-kubernetes-validations:\n\
    \                - message: both volumeGroupSnapshotRef.name and volumeGroupSnapshotRef.namespace\n\
    \                    must be set\n                  rule: has(self.name) && has(self.__namespace__)\n\
    \            required:\n            - deletionPolicy\n            - driver\n \
    \           - source\n            - volumeGroupSnapshotRef\n            type:\
    \ object\n          status:\n            description: status represents the current\
    \ information of a group snapshot.\n            properties:\n              creationTime:\n\
    \                description: |-\n                  CreationTime is the timestamp\
    \ when the point-in-time group snapshot is taken\n                  by the underlying\
    \ storage system.\n                  If not specified, it indicates the creation\
    \ time is unknown.\n                  If not specified, it means the readiness\
    \ of a group snapshot is unknown.\n                  The format of this field\
    \ is a Unix nanoseconds time encoded as an int64.\n                  On Unix,\
    \ the command date +%s%N returns the current time in nanoseconds\n           \
    \       since 1970-01-01 00:00:00 UTC.\n                  This field is the source\
    \ for the CreationTime field in VolumeGroupSnapshotStatus\n                format:\
    \ date-time\n                type: string\n              error:\n            \
    \    description: |-\n                  Error is the last observed error during\
    \ group snapshot creation, if any.\n                  Upon success after retry,\
    \ this error field will be cleared.\n                properties:\n           \
    \       message:\n                    description: |-\n                      message\
    \ is a string detailing the encountered error during snapshot\n              \
    \        creation if specified.\n                      NOTE: message may be logged,\
    \ and it should not contain sensitive\n                      information.\n  \
    \                  type: string\n                  time:\n                   \
    \ description: time is the timestamp when the error was encountered.\n       \
    \             format: date-time\n                    type: string\n          \
    \      type: object\n              readyToUse:\n                description: |-\n\
    \                  ReadyToUse indicates if all the individual snapshots in the\
    \ group are ready to be\n                  used to restore a group of volumes.\n\
    \                  ReadyToUse becomes true when ReadyToUse of all individual snapshots\
    \ become true.\n                type: boolean\n              volumeGroupSnapshotHandle:\n\
    \                description: |-\n                  VolumeGroupSnapshotHandle\
    \ is a unique id returned by the CSI driver\n                  to identify the\
    \ VolumeGroupSnapshot on the storage system.\n                  If a storage system\
    \ does not provide such an id, the\n                  CSI driver can choose to\
    \ return the VolumeGroupSnapshot name.\n                type: string\n       \
    \       volumeSnapshotHandlePairList:\n                description: |-\n     \
    \             VolumeSnapshotHandlePairList is a list of CSI \"volume_id\" and\
    \ \"snapshot_id\"\n                  pair returned by the CSI driver to identify\
    \ snapshots and their source volumes\n                  on the storage system.\n\
    \                items:\n                  description: VolumeSnapshotHandlePair\
    \ defines a pair of a source\n                    volume handle and a snapshot\
    \ handle\n                  properties:\n                    snapshotHandle:\n\
    \                      description: |-\n                        SnapshotHandle\
    \ is a unique id returned by the CSI driver to identify a volume\n           \
    \             snapshot on the storage system\n                        Required.\n\
    \                      type: string\n                    volumeHandle:\n     \
    \                 description: |-\n                        VolumeHandle is a unique\
    \ id returned by the CSI driver to identify a volume\n                       \
    \ on the storage system\n                        Required.\n                 \
    \     type: string\n                  required:\n                  - snapshotHandle\n\
    \                  - volumeHandle\n                  type: object\n          \
    \      type: array\n            type: object\n        required:\n        - spec\n\
    \        type: object\n    served: true\n    storage: true\n    subresources:\n\
    \      status: {}\n---\napiVersion: apiextensions.k8s.io/v1\nkind: CustomResourceDefinition\n\
    metadata:\n  annotations:\n    api-approved.kubernetes.io: https://github.com/kubernetes-csi/external-snapshotter/pull/1150\n\
    \    controller-gen.kubebuilder.io/version: v0.15.0\n  name: volumegroupsnapshots.groupsnapshot.storage.k8s.io\n\
    spec:\n  group: groupsnapshot.storage.k8s.io\n  names:\n    kind: VolumeGroupSnapshot\n\
    \    listKind: VolumeGroupSnapshotList\n    plural: volumegroupsnapshots\n   \
    \ shortNames:\n    - vgs\n    singular: volumegroupsnapshot\n  scope: Namespaced\n\
    \  versions:\n  - additionalPrinterColumns:\n    - description: Indicates if all\
    \ the individual snapshots in the group are ready\n        to be used to restore\
    \ a group of volumes.\n      jsonPath: .status.readyToUse\n      name: ReadyToUse\n\
    \      type: boolean\n    - description: The name of the VolumeGroupSnapshotClass\
    \ requested by the VolumeGroupSnapshot.\n      jsonPath: .spec.volumeGroupSnapshotClassName\n\
    \      name: VolumeGroupSnapshotClass\n      type: string\n    - description:\
    \ Name of the VolumeGroupSnapshotContent object to which the VolumeGroupSnapshot\n\
    \        object intends to bind to. Please note that verification of binding actually\n\
    \        requires checking both VolumeGroupSnapshot and VolumeGroupSnapshotContent\n\
    \        to ensure both are pointing at each other. Binding MUST be verified prior\n\
    \        to usage of this object.\n      jsonPath: .status.boundVolumeGroupSnapshotContentName\n\
    \      name: VolumeGroupSnapshotContent\n      type: string\n    - description:\
    \ Timestamp when the point-in-time group snapshot was taken by the\n        underlying\
    \ storage system.\n      jsonPath: .status.creationTime\n      name: CreationTime\n\
    \      type: date\n    - jsonPath: .metadata.creationTimestamp\n      name: Age\n\
    \      type: date\n    name: v1beta1\n    schema:\n      openAPIV3Schema:\n  \
    \      description: |-\n          VolumeGroupSnapshot is a user's request for\
    \ creating either a point-in-time\n          group snapshot or binding to a pre-existing\
    \ group snapshot.\n        properties:\n          apiVersion:\n            description:\
    \ |-\n              APIVersion defines the versioned schema of this representation\
    \ of an object.\n              Servers should convert recognized schemas to the\
    \ latest internal value, and\n              may reject unrecognized values.\n\
    \              More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources\n\
    \            type: string\n          kind:\n            description: |-\n    \
    \          Kind is a string value representing the REST resource this object represents.\n\
    \              Servers may infer this from the endpoint the client submits requests\
    \ to.\n              Cannot be updated.\n              In CamelCase.\n       \
    \       More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds\n\
    \            type: string\n          metadata:\n            type: object\n   \
    \       spec:\n            description: |-\n              Spec defines the desired\
    \ characteristics of a group snapshot requested by a user.\n              Required.\n\
    \            properties:\n              source:\n                description:\
    \ |-\n                  Source specifies where a group snapshot will be created\
    \ from.\n                  This field is immutable after creation.\n         \
    \         Required.\n                properties:\n                  selector:\n\
    \                    description: |-\n                      Selector is a label\
    \ query over persistent volume claims that are to be\n                      grouped\
    \ together for snapshotting.\n                      This labelSelector will be\
    \ used to match the label added to a PVC.\n                      If the label\
    \ is added or removed to a volume after a group snapshot\n                   \
    \   is created, the existing group snapshots won't be modified.\n            \
    \          Once a VolumeGroupSnapshotContent is created and the sidecar starts\
    \ to process\n                      it, the volume list will not change with retries.\n\
    \                    properties:\n                      matchExpressions:\n  \
    \                      description: matchExpressions is a list of label selector\n\
    \                          requirements. The requirements are ANDed.\n       \
    \                 items:\n                          description: |-\n        \
    \                    A label selector requirement is a selector that contains\
    \ values, a key, and an operator that\n                            relates the\
    \ key and values.\n                          properties:\n                   \
    \         key:\n                              description: key is the label key\
    \ that the selector\n                                applies to.\n           \
    \                   type: string\n                            operator:\n    \
    \                          description: |-\n                                operator\
    \ represents a key's relationship to a set of values.\n                      \
    \          Valid operators are In, NotIn, Exists and DoesNotExist.\n         \
    \                     type: string\n                            values:\n    \
    \                          description: |-\n                                values\
    \ is an array of string values. If the operator is In or NotIn,\n            \
    \                    the values array must be non-empty. If the operator is Exists\
    \ or DoesNotExist,\n                                the values array must be empty.\
    \ This array is replaced during a strategic\n                                merge\
    \ patch.\n                              items:\n                             \
    \   type: string\n                              type: array\n                \
    \              x-kubernetes-list-type: atomic\n                          required:\n\
    \                          - key\n                          - operator\n     \
    \                     type: object\n                        type: array\n    \
    \                    x-kubernetes-list-type: atomic\n                      matchLabels:\n\
    \                        additionalProperties:\n                          type:\
    \ string\n                        description: |-\n                          matchLabels\
    \ is a map of {key,value} pairs. A single {key,value} in the matchLabels\n   \
    \                       map is equivalent to an element of matchExpressions, whose\
    \ key field is \"key\", the\n                          operator is \"In\", and\
    \ the values array contains only \"value\". The requirements are ANDed.\n    \
    \                    type: object\n                    type: object\n        \
    \            x-kubernetes-map-type: atomic\n                    x-kubernetes-validations:\n\
    \                    - message: selector is immutable\n                      rule:\
    \ self == oldSelf\n                  volumeGroupSnapshotContentName:\n       \
    \             description: |-\n                      VolumeGroupSnapshotContentName\
    \ specifies the name of a pre-existing VolumeGroupSnapshotContent\n          \
    \            object representing an existing volume group snapshot.\n        \
    \              This field should be set if the volume group snapshot already exists\
    \ and\n                      only needs a representation in Kubernetes.\n    \
    \                  This field is immutable.\n                    type: string\n\
    \                    x-kubernetes-validations:\n                    - message:\
    \ volumeGroupSnapshotContentName is immutable\n                      rule: self\
    \ == oldSelf\n                type: object\n                x-kubernetes-validations:\n\
    \                - message: selector is required once set\n                  rule:\
    \ '!has(oldSelf.selector) || has(self.selector)'\n                - message: volumeGroupSnapshotContentName\
    \ is required once set\n                  rule: '!has(oldSelf.volumeGroupSnapshotContentName)\
    \ || has(self.volumeGroupSnapshotContentName)'\n                - message: exactly\
    \ one of selector and volumeGroupSnapshotContentName\n                    must\
    \ be set\n                  rule: (has(self.selector) && !has(self.volumeGroupSnapshotContentName))\n\
    \                    || (!has(self.selector) && has(self.volumeGroupSnapshotContentName))\n\
    \              volumeGroupSnapshotClassName:\n                description: |-\n\
    \                  VolumeGroupSnapshotClassName is the name of the VolumeGroupSnapshotClass\n\
    \                  requested by the VolumeGroupSnapshot.\n                  VolumeGroupSnapshotClassName\
    \ may be left nil to indicate that the default\n                  class will be\
    \ used.\n                  Empty string is not allowed for this field.\n     \
    \           type: string\n                x-kubernetes-validations:\n        \
    \        - message: volumeGroupSnapshotClassName must not be the empty string\n\
    \                    when set\n                  rule: size(self) > 0\n      \
    \      required:\n            - source\n            type: object\n          status:\n\
    \            description: |-\n              Status represents the current information\
    \ of a group snapshot.\n              Consumers must verify binding between VolumeGroupSnapshot\
    \ and\n              VolumeGroupSnapshotContent objects is successful (by validating\
    \ that both\n              VolumeGroupSnapshot and VolumeGroupSnapshotContent\
    \ point to each other) before\n              using this object.\n            properties:\n\
    \              boundVolumeGroupSnapshotContentName:\n                description:\
    \ |-\n                  BoundVolumeGroupSnapshotContentName is the name of the\
    \ VolumeGroupSnapshotContent\n                  object to which this VolumeGroupSnapshot\
    \ object intends to bind to.\n                  If not specified, it indicates\
    \ that the VolumeGroupSnapshot object has not\n                  been successfully\
    \ bound to a VolumeGroupSnapshotContent object yet.\n                  NOTE: To\
    \ avoid possible security issues, consumers must verify binding between\n    \
    \              VolumeGroupSnapshot and VolumeGroupSnapshotContent objects is successful\n\
    \                  (by validating that both VolumeGroupSnapshot and VolumeGroupSnapshotContent\n\
    \                  point at each other) before using this object.\n          \
    \      type: string\n              creationTime:\n                description:\
    \ |-\n                  CreationTime is the timestamp when the point-in-time group\
    \ snapshot is taken\n                  by the underlying storage system.\n   \
    \               If not specified, it may indicate that the creation time of the\
    \ group snapshot\n                  is unknown.\n                  The format\
    \ of this field is a Unix nanoseconds time encoded as an int64.\n            \
    \      On Unix, the command date +%s%N returns the current time in nanoseconds\n\
    \                  since 1970-01-01 00:00:00 UTC.\n                  This field\
    \ is updated based on the CreationTime field in VolumeGroupSnapshotContentStatus\n\
    \                format: date-time\n                type: string\n           \
    \   error:\n                description: |-\n                  Error is the last\
    \ observed error during group snapshot creation, if any.\n                  This\
    \ field could be helpful to upper level controllers (i.e., application\n     \
    \             controller) to decide whether they should continue on waiting for\
    \ the group\n                  snapshot to be created based on the type of error\
    \ reported.\n                  The snapshot controller will keep retrying when\
    \ an error occurs during the\n                  group snapshot creation. Upon\
    \ success, this error field will be cleared.\n                properties:\n  \
    \                message:\n                    description: |-\n             \
    \         message is a string detailing the encountered error during snapshot\n\
    \                      creation if specified.\n                      NOTE: message\
    \ may be logged, and it should not contain sensitive\n                      information.\n\
    \                    type: string\n                  time:\n                 \
    \   description: time is the timestamp when the error was encountered.\n     \
    \               format: date-time\n                    type: string\n        \
    \        type: object\n              readyToUse:\n                description:\
    \ |-\n                  ReadyToUse indicates if all the individual snapshots in\
    \ the group are ready\n                  to be used to restore a group of volumes.\n\
    \                  ReadyToUse becomes true when ReadyToUse of all individual snapshots\
    \ become true.\n                  If not specified, it means the readiness of\
    \ a group snapshot is unknown.\n                type: boolean\n            type:\
    \ object\n        required:\n        - spec\n        type: object\n    served:\
    \ true\n    storage: true\n    subresources:\n      status: {}\n---\napiVersion:\
    \ apiextensions.k8s.io/v1\nkind: CustomResourceDefinition\nmetadata:\n  annotations:\n\
    \    api-approved.kubernetes.io: https://github.com/kubernetes-csi/external-snapshotter/pull/814\n\
    \    controller-gen.kubebuilder.io/version: v0.15.0\n  name: volumesnapshotclasses.snapshot.storage.k8s.io\n\
    spec:\n  group: snapshot.storage.k8s.io\n  names:\n    kind: VolumeSnapshotClass\n\
    \    listKind: VolumeSnapshotClassList\n    plural: volumesnapshotclasses\n  \
    \  shortNames:\n    - vsclass\n    - vsclasses\n    singular: volumesnapshotclass\n\
    \  scope: Cluster\n  versions:\n  - additionalPrinterColumns:\n    - jsonPath:\
    \ .driver\n      name: Driver\n      type: string\n    - description: Determines\
    \ whether a VolumeSnapshotContent created through the\n        VolumeSnapshotClass\
    \ should be deleted when its bound VolumeSnapshot is deleted.\n      jsonPath:\
    \ .deletionPolicy\n      name: DeletionPolicy\n      type: string\n    - jsonPath:\
    \ .metadata.creationTimestamp\n      name: Age\n      type: date\n    name: v1\n\
    \    schema:\n      openAPIV3Schema:\n        description: |-\n          VolumeSnapshotClass\
    \ specifies parameters that a underlying storage system uses when\n          creating\
    \ a volume snapshot. A specific VolumeSnapshotClass is used by specifying its\n\
    \          name in a VolumeSnapshot object.\n          VolumeSnapshotClasses are\
    \ non-namespaced\n        properties:\n          apiVersion:\n            description:\
    \ |-\n              APIVersion defines the versioned schema of this representation\
    \ of an object.\n              Servers should convert recognized schemas to the\
    \ latest internal value, and\n              may reject unrecognized values.\n\
    \              More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources\n\
    \            type: string\n          deletionPolicy:\n            description:\
    \ |-\n              deletionPolicy determines whether a VolumeSnapshotContent\
    \ created through\n              the VolumeSnapshotClass should be deleted when\
    \ its bound VolumeSnapshot is deleted.\n              Supported values are \"\
    Retain\" and \"Delete\".\n              \"Retain\" means that the VolumeSnapshotContent\
    \ and its physical snapshot on underlying storage system are kept.\n         \
    \     \"Delete\" means that the VolumeSnapshotContent and its physical snapshot\
    \ on underlying storage system are deleted.\n              Required.\n       \
    \     enum:\n            - Delete\n            - Retain\n            type: string\n\
    \          driver:\n            description: |-\n              driver is the name\
    \ of the storage driver that handles this VolumeSnapshotClass.\n             \
    \ Required.\n            type: string\n          kind:\n            description:\
    \ |-\n              Kind is a string value representing the REST resource this\
    \ object represents.\n              Servers may infer this from the endpoint the\
    \ client submits requests to.\n              Cannot be updated.\n            \
    \  In CamelCase.\n              More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds\n\
    \            type: string\n          metadata:\n            type: object\n   \
    \       parameters:\n            additionalProperties:\n              type: string\n\
    \            description: |-\n              parameters is a key-value map with\
    \ storage driver specific parameters for creating snapshots.\n              These\
    \ values are opaque to Kubernetes.\n            type: object\n        required:\n\
    \        - deletionPolicy\n        - driver\n        type: object\n    served:\
    \ true\n    storage: true\n    subresources: {}\n  - additionalPrinterColumns:\n\
    \    - jsonPath: .driver\n      name: Driver\n      type: string\n    - description:\
    \ Determines whether a VolumeSnapshotContent created through the\n        VolumeSnapshotClass\
    \ should be deleted when its bound VolumeSnapshot is deleted.\n      jsonPath:\
    \ .deletionPolicy\n      name: DeletionPolicy\n      type: string\n    - jsonPath:\
    \ .metadata.creationTimestamp\n      name: Age\n      type: date\n    deprecated:\
    \ true\n    deprecationWarning: snapshot.storage.k8s.io/v1beta1 VolumeSnapshotClass\
    \ is deprecated;\n      use snapshot.storage.k8s.io/v1 VolumeSnapshotClass\n \
    \   name: v1beta1\n    schema:\n      openAPIV3Schema:\n        description: VolumeSnapshotClass\
    \ specifies parameters that a underlying storage\n          system uses when creating\
    \ a volume snapshot. A specific VolumeSnapshotClass\n          is used by specifying\
    \ its name in a VolumeSnapshot object. VolumeSnapshotClasses\n          are non-namespaced\n\
    \        properties:\n          apiVersion:\n            description: 'APIVersion\
    \ defines the versioned schema of this representation\n              of an object.\
    \ Servers should convert recognized schemas to the latest\n              internal\
    \ value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'\n\
    \            type: string\n          deletionPolicy:\n            description:\
    \ deletionPolicy determines whether a VolumeSnapshotContent\n              created\
    \ through the VolumeSnapshotClass should be deleted when its bound\n         \
    \     VolumeSnapshot is deleted. Supported values are \"Retain\" and \"Delete\"\
    .\n              \"Retain\" means that the VolumeSnapshotContent and its physical\
    \ snapshot\n              on underlying storage system are kept. \"Delete\" means\
    \ that the VolumeSnapshotContent\n              and its physical snapshot on underlying\
    \ storage system are deleted.\n              Required.\n            enum:\n  \
    \          - Delete\n            - Retain\n            type: string\n        \
    \  driver:\n            description: driver is the name of the storage driver\
    \ that handles this\n              VolumeSnapshotClass. Required.\n          \
    \  type: string\n          kind:\n            description: 'Kind is a string value\
    \ representing the REST resource this\n              object represents. Servers\
    \ may infer this from the endpoint the client\n              submits requests\
    \ to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'\n\
    \            type: string\n          parameters:\n            additionalProperties:\n\
    \              type: string\n            description: parameters is a key-value\
    \ map with storage driver specific\n              parameters for creating snapshots.\
    \ These values are opaque to Kubernetes.\n            type: object\n        required:\n\
    \        - deletionPolicy\n        - driver\n        type: object\n    served:\
    \ false\n    storage: false\n    subresources: {}\nstatus:\n  acceptedNames:\n\
    \    kind: \"\"\n    plural: \"\"\n  conditions: []\n  storedVersions: []\n---\n\
    apiVersion: apiextensions.k8s.io/v1\nkind: CustomResourceDefinition\nmetadata:\n\
    \  annotations:\n    api-approved.kubernetes.io: https://github.com/kubernetes-csi/external-snapshotter/pull/955\n\
    \    controller-gen.kubebuilder.io/version: v0.15.0\n  name: volumesnapshotcontents.snapshot.storage.k8s.io\n\
    spec:\n  group: snapshot.storage.k8s.io\n  names:\n    kind: VolumeSnapshotContent\n\
    \    listKind: VolumeSnapshotContentList\n    plural: volumesnapshotcontents\n\
    \    shortNames:\n    - vsc\n    - vscs\n    singular: volumesnapshotcontent\n\
    \  scope: Cluster\n  versions:\n  - additionalPrinterColumns:\n    - description:\
    \ Indicates if the snapshot is ready to be used to restore a volume.\n      jsonPath:\
    \ .status.readyToUse\n      name: ReadyToUse\n      type: boolean\n    - description:\
    \ Represents the complete size of the snapshot in bytes\n      jsonPath: .status.restoreSize\n\
    \      name: RestoreSize\n      type: integer\n    - description: Determines whether\
    \ this VolumeSnapshotContent and its physical\n        snapshot on the underlying\
    \ storage system should be deleted when its bound\n        VolumeSnapshot is deleted.\n\
    \      jsonPath: .spec.deletionPolicy\n      name: DeletionPolicy\n      type:\
    \ string\n    - description: Name of the CSI driver used to create the physical\
    \ snapshot on\n        the underlying storage system.\n      jsonPath: .spec.driver\n\
    \      name: Driver\n      type: string\n    - description: Name of the VolumeSnapshotClass\
    \ to which this snapshot belongs.\n      jsonPath: .spec.volumeSnapshotClassName\n\
    \      name: VolumeSnapshotClass\n      type: string\n    - description: Name\
    \ of the VolumeSnapshot object to which this VolumeSnapshotContent\n        object\
    \ is bound.\n      jsonPath: .spec.volumeSnapshotRef.name\n      name: VolumeSnapshot\n\
    \      type: string\n    - description: Namespace of the VolumeSnapshot object\
    \ to which this VolumeSnapshotContent\n        object is bound.\n      jsonPath:\
    \ .spec.volumeSnapshotRef.namespace\n      name: VolumeSnapshotNamespace\n   \
    \   type: string\n    - jsonPath: .metadata.creationTimestamp\n      name: Age\n\
    \      type: date\n    name: v1\n    schema:\n      openAPIV3Schema:\n       \
    \ description: |-\n          VolumeSnapshotContent represents the actual \"on-disk\"\
    \ snapshot object in the\n          underlying storage system\n        properties:\n\
    \          apiVersion:\n            description: |-\n              APIVersion\
    \ defines the versioned schema of this representation of an object.\n        \
    \      Servers should convert recognized schemas to the latest internal value,\
    \ and\n              may reject unrecognized values.\n              More info:\
    \ https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources\n\
    \            type: string\n          kind:\n            description: |-\n    \
    \          Kind is a string value representing the REST resource this object represents.\n\
    \              Servers may infer this from the endpoint the client submits requests\
    \ to.\n              Cannot be updated.\n              In CamelCase.\n       \
    \       More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds\n\
    \            type: string\n          metadata:\n            type: object\n   \
    \       spec:\n            description: |-\n              spec defines properties\
    \ of a VolumeSnapshotContent created by the underlying storage system.\n     \
    \         Required.\n            properties:\n              deletionPolicy:\n\
    \                description: |-\n                  deletionPolicy determines\
    \ whether this VolumeSnapshotContent and its physical snapshot on\n          \
    \        the underlying storage system should be deleted when its bound VolumeSnapshot\
    \ is deleted.\n                  Supported values are \"Retain\" and \"Delete\"\
    .\n                  \"Retain\" means that the VolumeSnapshotContent and its physical\
    \ snapshot on underlying storage system are kept.\n                  \"Delete\"\
    \ means that the VolumeSnapshotContent and its physical snapshot on underlying\
    \ storage system are deleted.\n                  For dynamically provisioned snapshots,\
    \ this field will automatically be filled in by the\n                  CSI snapshotter\
    \ sidecar with the \"DeletionPolicy\" field defined in the corresponding\n   \
    \               VolumeSnapshotClass.\n                  For pre-existing snapshots,\
    \ users MUST specify this field when creating the\n                   VolumeSnapshotContent\
    \ object.\n                  Required.\n                enum:\n              \
    \  - Delete\n                - Retain\n                type: string\n        \
    \      driver:\n                description: |-\n                  driver is the\
    \ name of the CSI driver used to create the physical snapshot on\n           \
    \       the underlying storage system.\n                  This MUST be the same\
    \ as the name returned by the CSI GetPluginName() call for\n                 \
    \ that driver.\n                  Required.\n                type: string\n  \
    \            source:\n                description: |-\n                  source\
    \ specifies whether the snapshot is (or should be) dynamically provisioned\n \
    \                 or already exists, and just requires a Kubernetes object representation.\n\
    \                  This field is immutable after creation.\n                 \
    \ Required.\n                properties:\n                  snapshotHandle:\n\
    \                    description: |-\n                      snapshotHandle specifies\
    \ the CSI \"snapshot_id\" of a pre-existing snapshot on\n                    \
    \  the underlying storage system for which a Kubernetes object representation\n\
    \                      was (or should be) created.\n                      This\
    \ field is immutable.\n                    type: string\n                    x-kubernetes-validations:\n\
    \                    - message: snapshotHandle is immutable\n                \
    \      rule: self == oldSelf\n                  volumeHandle:\n              \
    \      description: |-\n                      volumeHandle specifies the CSI \"\
    volume_id\" of the volume from which a snapshot\n                      should\
    \ be dynamically taken from.\n                      This field is immutable.\n\
    \                    type: string\n                    x-kubernetes-validations:\n\
    \                    - message: volumeHandle is immutable\n                  \
    \    rule: self == oldSelf\n                type: object\n                x-kubernetes-validations:\n\
    \                - message: volumeHandle is required once set\n              \
    \    rule: '!has(oldSelf.volumeHandle) || has(self.volumeHandle)'\n          \
    \      - message: snapshotHandle is required once set\n                  rule:\
    \ '!has(oldSelf.snapshotHandle) || has(self.snapshotHandle)'\n               \
    \ - message: exactly one of volumeHandle and snapshotHandle must be\n        \
    \            set\n                  rule: (has(self.volumeHandle) && !has(self.snapshotHandle))\
    \ || (!has(self.volumeHandle)\n                    && has(self.snapshotHandle))\n\
    \              sourceVolumeMode:\n                description: |-\n          \
    \        SourceVolumeMode is the mode of the volume whose snapshot is taken.\n\
    \                  Can be either Filesystem or Block.\n                  If\
    \ not specified, it indicates the source volume's mode is unknown.\n         \
    \         This field is immutable.\n                  This field is an alpha field.\n\
    \                type: string\n                x-kubernetes-validations:\n   \
    \             - message: sourceVolumeMode is immutable\n                  rule:\
    \ self == oldSelf\n              volumeSnapshotClassName:\n                description:\
    \ |-\n                  name of the VolumeSnapshotClass from which this snapshot\
    \ was (or will be)\n                  created.\n                  Note that after\
    \ provisioning, the VolumeSnapshotClass may be deleted or\n                  recreated\
    \ with different set of values, and as such, should not be referenced\n      \
    \            post-snapshot creation.\n                type: string\n         \
    \     volumeSnapshotRef:\n                description: |-\n                  volumeSnapshotRef\
    \ specifies the VolumeSnapshot object to which this\n                  VolumeSnapshotContent\
    \ object is bound.\n                  VolumeSnapshot.Spec.VolumeSnapshotContentName\
    \ field must reference to\n                  this VolumeSnapshotContent's name\
    \ for the bidirectional binding to be valid.\n                  For a pre-existing\
    \ VolumeSnapshotContent object, name and namespace of the\n                  VolumeSnapshot\
    \ object MUST be provided for binding to happen.\n                  This field\
    \ is immutable after creation.\n                  Required.\n                properties:\n\
    \                  apiVersion:\n                    description: API version of\
    \ the referent.\n                    type: string\n                  fieldPath:\n\
    \                    description: |-\n                      If referring to a\
    \ piece of an object instead of an entire object, this string\n              \
    \        should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2].\n\
    \                      For example, if the object reference is to a container\
    \ within a pod, this would take on a value like:\n                      \"spec.containers{name}\"\
    \ (where \"name\" refers to the name of the container that triggered\n       \
    \               the event) or if no container name is specified \"spec.containers[2]\"\
    \ (container with\n                      index 2 in this pod). This syntax is\
    \ chosen only to have some well-defined way of\n                      referencing\
    \ a part of an object.\n                      TODO: this design is not final and\
    \ this field is subject to change in the future.\n                    type: string\n\
    \                  kind:\n                    description: |-\n              \
    \        Kind of the referent.\n                      More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds\n\
    \                    type: string\n                  name:\n                 \
    \   description: |-\n                      Name of the referent.\n           \
    \           More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names\n\
    \                    type: string\n                  namespace:\n            \
    \        description: |-\n                      Namespace of the referent.\n \
    \                     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/\n\
    \                    type: string\n                  resourceVersion:\n      \
    \              description: |-\n                      Specific resourceVersion\
    \ to which this reference is made, if any.\n                      More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency\n\
    \                    type: string\n                  uid:\n                  \
    \  description: |-\n                      UID of the referent.\n             \
    \         More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids\n\
    \                    type: string\n                type: object\n            \
    \    x-kubernetes-map-type: atomic\n                x-kubernetes-validations:\n\
    \                - message: both spec.volumeSnapshotRef.name and spec.volumeSnapshotRef.namespace\n\
    \                    must be set\n                  rule: has(self.name) && has(self.__namespace__)\n\
    \            required:\n            - deletionPolicy\n            - driver\n \
    \           - source\n            - volumeSnapshotRef\n            type: object\n\
    \            x-kubernetes-validations:\n            - message: sourceVolumeMode\
    \ is required once set\n              rule: '!has(oldSelf.sourceVolumeMode) ||\
    \ has(self.sourceVolumeMode)'\n          status:\n            description: status\
    \ represents the current information of a snapshot.\n            properties:\n\
    \              creationTime:\n                description: |-\n              \
    \    creationTime is the timestamp when the point-in-time snapshot is taken\n\
    \                  by the underlying storage system.\n                  In dynamic\
    \ snapshot creation case, this field will be filled in by the\n              \
    \    CSI snapshotter sidecar with the \"creation_time\" value returned from CSI\n\
    \                  \"CreateSnapshot\" gRPC call.\n                  For a pre-existing\
    \ snapshot, this field will be filled with the \"creation_time\"\n           \
    \       value returned from the CSI \"ListSnapshots\" gRPC call if the driver\
    \ supports it.\n                  If not specified, it indicates the creation\
    \ time is unknown.\n                  The format of this field is a Unix nanoseconds\
    \ time encoded as an int64.\n                  On Unix, the command `date +%s%N`\
    \ returns the current time in nanoseconds\n                  since 1970-01-01\
    \ 00:00:00 UTC.\n                format: int64\n                type: integer\n\
    \              error:\n                description: |-\n                  error\
    \ is the last observed error during snapshot creation, if any.\n             \
    \     Upon success after retry, this error field will be cleared.\n          \
    \      properties:\n                  message:\n                    description:\
    \ |-\n                      message is a string detailing the encountered error\
    \ during snapshot\n                      creation if specified.\n            \
    \          NOTE: message may be logged, and it should not contain sensitive\n\
    \                      information.\n                    type: string\n      \
    \            time:\n                    description: time is the timestamp when\
    \ the error was encountered.\n                    format: date-time\n        \
    \            type: string\n                type: object\n              readyToUse:\n\
    \                description: |-\n                  readyToUse indicates if a\
    \ snapshot is ready to be used to restore a volume.\n                  In dynamic\
    \ snapshot creation case, this field will be filled in by the\n              \
    \    CSI snapshotter sidecar with the \"ready_to_use\" value returned from CSI\n\
    \                  \"CreateSnapshot\" gRPC call.\n                  For a pre-existing\
    \ snapshot, this field will be filled with the \"ready_to_use\"\n            \
    \      value returned from the CSI \"ListSnapshots\" gRPC call if the driver supports\
    \ it,\n                  otherwise, this field will be set to \"True\".\n    \
    \              If not specified, it means the readiness of a snapshot is unknown.\n\
    \                type: boolean\n              restoreSize:\n                description:\
    \ |-\n                  restoreSize represents the complete size of the snapshot\
    \ in bytes.\n                  In dynamic snapshot creation case, this field will\
    \ be filled in by the\n                  CSI snapshotter sidecar with the \"size_bytes\"\
    \ value returned from CSI\n                  \"CreateSnapshot\" gRPC call.\n \
    \                 For a pre-existing snapshot, this field will be filled with\
    \ the \"size_bytes\"\n                  value returned from the CSI \"ListSnapshots\"\
    \ gRPC call if the driver supports it.\n                  When restoring a volume\
    \ from this snapshot, the size of the volume MUST NOT\n                  be smaller\
    \ than the restoreSize if it is specified, otherwise the restoration will fail.\n\
    \                  If not specified, it indicates that the size is unknown.\n\
    \                format: int64\n                minimum: 0\n                type:\
    \ integer\n              snapshotHandle:\n                description: |-\n  \
    \                snapshotHandle is the CSI \"snapshot_id\" of a snapshot on the\
    \ underlying storage system.\n                  If not specified, it indicates\
    \ that dynamic snapshot creation has either failed\n                  or it is\
    \ still in progress.\n                type: string\n              volumeGroupSnapshotHandle:\n\
    \                description: |-\n                  VolumeGroupSnapshotHandle\
    \ is the CSI \"group_snapshot_id\" of a group snapshot\n                  on the\
    \ underlying storage system.\n                type: string\n            type:\
    \ object\n        required:\n        - spec\n        type: object\n    served:\
    \ true\n    storage: true\n    subresources:\n      status: {}\n  - additionalPrinterColumns:\n\
    \    - description: Indicates if the snapshot is ready to be used to restore a\
    \ volume.\n      jsonPath: .status.readyToUse\n      name: ReadyToUse\n      type:\
    \ boolean\n    - description: Represents the complete size of the snapshot in\
    \ bytes\n      jsonPath: .status.restoreSize\n      name: RestoreSize\n      type:\
    \ integer\n    - description: Determines whether this VolumeSnapshotContent and\
    \ its physical\n        snapshot on the underlying storage system should be deleted\
    \ when its bound\n        VolumeSnapshot is deleted.\n      jsonPath: .spec.deletionPolicy\n\
    \      name: DeletionPolicy\n      type: string\n    - description: Name of the\
    \ CSI driver used to create the physical snapshot on\n        the underlying storage\
    \ system.\n      jsonPath: .spec.driver\n      name: Driver\n      type: string\n\
    \    - description: Name of the VolumeSnapshotClass to which this snapshot belongs.\n\
    \      jsonPath: .spec.volumeSnapshotClassName\n      name: VolumeSnapshotClass\n\
    \      type: string\n    - description: Name of the VolumeSnapshot object to which\
    \ this VolumeSnapshotContent\n        object is bound.\n      jsonPath: .spec.volumeSnapshotRef.name\n\
    \      name: VolumeSnapshot\n      type: string\n    - description: Namespace\
    \ of the VolumeSnapshot object to which this VolumeSnapshotContent\n        object\
    \ is bound.\n      jsonPath: .spec.volumeSnapshotRef.namespace\n      name: VolumeSnapshotNamespace\n\
    \      type: string\n    - jsonPath: .metadata.creationTimestamp\n      name:\
    \ Age\n      type: date\n    deprecated: true\n    deprecationWarning: snapshot.storage.k8s.io/v1beta1\
    \ VolumeSnapshotContent is deprecated;\n      use snapshot.storage.k8s.io/v1 VolumeSnapshotContent\n\
    \    name: v1beta1\n    schema:\n      openAPIV3Schema:\n        description:\
    \ VolumeSnapshotContent represents the actual \"on-disk\" snapshot\n         \
    \ object in the underlying storage system\n        properties:\n          apiVersion:\n\
    \            description: 'APIVersion defines the versioned schema of this representation\n\
    \              of an object. Servers should convert recognized schemas to the\
    \ latest\n              internal value, and may reject unrecognized values. More\
    \ info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'\n\
    \            type: string\n          kind:\n            description: 'Kind is\
    \ a string value representing the REST resource this\n              object represents.\
    \ Servers may infer this from the endpoint the client\n              submits requests\
    \ to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'\n\
    \            type: string\n          spec:\n            description: spec defines\
    \ properties of a VolumeSnapshotContent created\n              by the underlying\
    \ storage system. Required.\n            properties:\n              deletionPolicy:\n\
    \                description: deletionPolicy determines whether this VolumeSnapshotContent\n\
    \                  and its physical snapshot on the underlying storage system\
    \ should\n                  be deleted when its bound VolumeSnapshot is deleted.\
    \ Supported values\n                  are \"Retain\" and \"Delete\". \"Retain\"\
    \ means that the VolumeSnapshotContent\n                  and its physical snapshot\
    \ on underlying storage system are kept.\n                  \"Delete\" means that\
    \ the VolumeSnapshotContent and its physical snapshot\n                  on underlying\
    \ storage system are deleted. For dynamically provisioned\n                  snapshots,\
    \ this field will automatically be filled in by the CSI\n                  snapshotter\
    \ sidecar with the \"DeletionPolicy\" field defined in the\n                 \
    \ corresponding VolumeSnapshotClass. For pre-existing snapshots, users\n     \
    \             MUST specify this field when creating the  VolumeSnapshotContent\n\
    \                  object. Required.\n                enum:\n                -\
    \ Delete\n                - Retain\n                type: string\n           \
    \   driver:\n                description: driver is the name of the CSI driver\
    \ used to create the\n                  physical snapshot on the underlying storage\
    \ system. This MUST be\n                  the same as the name returned by the\
    \ CSI GetPluginName() call for\n                  that driver. Required.\n   \
    \             type: string\n              source:\n                description:\
    \ source specifies whether the snapshot is (or should be)\n                  dynamically\
    \ provisioned or already exists, and just requires a Kubernetes\n            \
    \      object representation. This field is immutable after creation. Required.\n\
    \                properties:\n                  snapshotHandle:\n            \
    \        description: snapshotHandle specifies the CSI \"snapshot_id\" of\n  \
    \                    a pre-existing snapshot on the underlying storage system\
    \ for\n                      which a Kubernetes object representation was (or\
    \ should be)\n                      created. This field is immutable.\n      \
    \              type: string\n                  volumeHandle:\n               \
    \     description: volumeHandle specifies the CSI \"volume_id\" of the\n     \
    \                 volume from which a snapshot should be dynamically taken from.\n\
    \                      This field is immutable.\n                    type: string\n\
    \                type: object\n              volumeSnapshotClassName:\n      \
    \          description: name of the VolumeSnapshotClass from which this snapshot\n\
    \                  was (or will be) created. Note that after provisioning, the\
    \ VolumeSnapshotClass\n                  may be deleted or recreated with different\
    \ set of values, and as\n                  such, should not be referenced post-snapshot\
    \ creation.\n                type: string\n              volumeSnapshotRef:\n\
    \                description: volumeSnapshotRef specifies the VolumeSnapshot object\n\
    \                  to which this VolumeSnapshotContent object is bound. VolumeSnapshot.Spec.VolumeSnapshotContentName\n\
    \                  field must reference to this VolumeSnapshotContent's name for\
    \ the\n                  bidirectional binding to be valid. For a pre-existing\
    \ VolumeSnapshotContent\n                  object, name and namespace of the VolumeSnapshot\
    \ object MUST be\n                  provided for binding to happen. This field\
    \ is immutable after creation.\n                  Required.\n                properties:\n\
    \                  apiVersion:\n                    description: API version of\
    \ the referent.\n                    type: string\n                  fieldPath:\n\
    \                    description: 'If referring to a piece of an object instead\
    \ of\n                      an entire object, this string should contain a valid\
    \ JSON/Go\n                      field access statement, such as desiredState.manifest.containers[2].\n\
    \                      For example, if the object reference is to a container\
    \ within\n                      a pod, this would take on a value like: \"spec.containers{name}\"\
    \n                      (where \"name\" refers to the name of the container that\
    \ triggered\n                      the event) or if no container name is specified\
    \ \"spec.containers[2]\"\n                      (container with index 2 in this\
    \ pod). This syntax is chosen\n                      only to have some well-defined\
    \ way of referencing a part of\n                      an object. TODO: this design\
    \ is not final and this field is\n                      subject to change in the\
    \ future.'\n                    type: string\n                  kind:\n      \
    \              description: 'Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'\n\
    \                    type: string\n                  name:\n                 \
    \   description: 'Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names'\n\
    \                    type: string\n                  namespace:\n            \
    \        description: 'Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/'\n\
    \                    type: string\n                  resourceVersion:\n      \
    \              description: 'Specific resourceVersion to which this reference\n\
    \                      is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency'\n\
    \                    type: string\n                  uid:\n                  \
    \  description: 'UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids'\n\
    \                    type: string\n                type: object\n            required:\n\
    \            - deletionPolicy\n            - driver\n            - source\n  \
    \          - volumeSnapshotRef\n            type: object\n          status:\n\
    \            description: status represents the current information of a snapshot.\n\
    \            properties:\n              creationTime:\n                description:\
    \ creationTime is the timestamp when the point-in-time\n                  snapshot\
    \ is taken by the underlying storage system. In dynamic snapshot\n           \
    \       creation case, this field will be filled in by the CSI snapshotter\n \
    \                 sidecar with the \"creation_time\" value returned from CSI \"\
    CreateSnapshot\"\n                  gRPC call. For a pre-existing snapshot, this\
    \ field will be filled\n                  with the \"creation_time\" value returned\
    \ from the CSI \"ListSnapshots\"\n                  gRPC call if the driver supports\
    \ it. If not specified, it indicates\n                  the creation time is unknown.\
    \ The format of this field is a Unix\n                  nanoseconds time encoded\
    \ as an int64. On Unix, the command `date\n                  +%s%N` returns the\
    \ current time in nanoseconds since 1970-01-01\n                  00:00:00 UTC.\n\
    \                format: int64\n                type: integer\n              error:\n\
    \                description: error is the last observed error during snapshot\
    \ creation,\n                  if any. Upon success after retry, this error field\
    \ will be cleared.\n                properties:\n                  message:\n\
    \                    description: 'message is a string detailing the encountered\
    \ error\n                      during snapshot creation if specified. NOTE: message\
    \ may be\n                      logged, and it should not contain sensitive information.'\n\
    \                    type: string\n                  time:\n                 \
    \   description: time is the timestamp when the error was encountered.\n     \
    \               format: date-time\n                    type: string\n        \
    \        type: object\n              readyToUse:\n                description:\
    \ readyToUse indicates if a snapshot is ready to be used\n                  to\
    \ restore a volume. In dynamic snapshot creation case, this field\n          \
    \        will be filled in by the CSI snapshotter sidecar with the \"ready_to_use\"\
    \n                  value returned from CSI \"CreateSnapshot\" gRPC call. For\
    \ a pre-existing\n                  snapshot, this field will be filled with the\
    \ \"ready_to_use\" value\n                  returned from the CSI \"ListSnapshots\"\
    \ gRPC call if the driver supports\n                  it, otherwise, this field\
    \ will be set to \"True\". If not specified,\n                  it means the readiness\
    \ of a snapshot is unknown.\n                type: boolean\n              restoreSize:\n\
    \                description: restoreSize represents the complete size of the\
    \ snapshot\n                  in bytes. In dynamic snapshot creation case, this\
    \ field will be\n                  filled in by the CSI snapshotter sidecar with\
    \ the \"size_bytes\" value\n                  returned from CSI \"CreateSnapshot\"\
    \ gRPC call. For a pre-existing\n                  snapshot, this field will be\
    \ filled with the \"size_bytes\" value\n                  returned from the CSI\
    \ \"ListSnapshots\" gRPC call if the driver supports\n                  it. When\
    \ restoring a volume from this snapshot, the size of the\n                  volume\
    \ MUST NOT be smaller than the restoreSize if it is specified,\n             \
    \     otherwise the restoration will fail. If not specified, it indicates\n  \
    \                that the size is unknown.\n                format: int64\n  \
    \              minimum: 0\n                type: integer\n              snapshotHandle:\n\
    \                description: snapshotHandle is the CSI \"snapshot_id\" of a snapshot\n\
    \                  on the underlying storage system. If not specified, it indicates\n\
    \                  that dynamic snapshot creation has either failed or it is still\n\
    \                  in progress.\n                type: string\n            type:\
    \ object\n        required:\n        - spec\n        type: object\n    served:\
    \ false\n    storage: false\n    subresources:\n      status: {}\nstatus:\n  acceptedNames:\n\
    \    kind: \"\"\n    plural: \"\"\n  conditions: []\n  storedVersions: []\n---\n\
    apiVersion: apiextensions.k8s.io/v1\nkind: CustomResourceDefinition\nmetadata:\n\
    \  annotations:\n    api-approved.kubernetes.io: https://github.com/kubernetes-csi/external-snapshotter/pull/814\n\
    \    controller-gen.kubebuilder.io/version: v0.15.0\n  name: volumesnapshots.snapshot.storage.k8s.io\n\
    spec:\n  group: snapshot.storage.k8s.io\n  names:\n    kind: VolumeSnapshot\n\
    \    listKind: VolumeSnapshotList\n    plural: volumesnapshots\n    shortNames:\n\
    \    - vs\n    singular: volumesnapshot\n  scope: Namespaced\n  versions:\n  -\
    \ additionalPrinterColumns:\n    - description: Indicates if the snapshot is ready\
    \ to be used to restore a volume.\n      jsonPath: .status.readyToUse\n      name:\
    \ ReadyToUse\n      type: boolean\n    - description: If a new snapshot needs\
    \ to be created, this contains the name of\n        the source PVC from which\
    \ this snapshot was (or will be) created.\n      jsonPath: .spec.source.persistentVolumeClaimName\n\
    \      name: SourcePVC\n      type: string\n    - description: If a snapshot already\
    \ exists, this contains the name of the existing\n        VolumeSnapshotContent\
    \ object representing the existing snapshot.\n      jsonPath: .spec.source.volumeSnapshotContentName\n\
    \      name: SourceSnapshotContent\n      type: string\n    - description: Represents\
    \ the minimum size of volume required to rehydrate from\n        this snapshot.\n\
    \      jsonPath: .status.restoreSize\n      name: RestoreSize\n      type: string\n\
    \    - description: The name of the VolumeSnapshotClass requested by the VolumeSnapshot.\n\
    \      jsonPath: .spec.volumeSnapshotClassName\n      name: SnapshotClass\n  \
    \    type: string\n    - description: Name of the VolumeSnapshotContent object\
    \ to which the VolumeSnapshot\n        object intends to bind to. Please note\
    \ that verification of binding actually\n        requires checking both VolumeSnapshot\
    \ and VolumeSnapshotContent to ensure\n        both are pointing at each other.\
    \ Binding MUST be verified prior to usage of\n        this object.\n      jsonPath:\
    \ .status.boundVolumeSnapshotContentName\n      name: SnapshotContent\n      type:\
    \ string\n    - description: Timestamp when the point-in-time snapshot was taken\
    \ by the underlying\n        storage system.\n      jsonPath: .status.creationTime\n\
    \      name: CreationTime\n      type: date\n    - jsonPath: .metadata.creationTimestamp\n\
    \      name: Age\n      type: date\n    name: v1\n    schema:\n      openAPIV3Schema:\n\
    \        description: |-\n          VolumeSnapshot is a user's request for either\
    \ creating a point-in-time\n          snapshot of a persistent volume, or binding\
    \ to a pre-existing snapshot.\n        properties:\n          apiVersion:\n  \
    \          description: |-\n              APIVersion defines the versioned schema\
    \ of this representation of an object.\n              Servers should convert recognized\
    \ schemas to the latest internal value, and\n              may reject unrecognized\
    \ values.\n              More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources\n\
    \            type: string\n          kind:\n            description: |-\n    \
    \          Kind is a string value representing the REST resource this object represents.\n\
    \              Servers may infer this from the endpoint the client submits requests\
    \ to.\n              Cannot be updated.\n              In CamelCase.\n       \
    \       More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds\n\
    \            type: string\n          metadata:\n            type: object\n   \
    \       spec:\n            description: |-\n              spec defines the desired\
    \ characteristics of a snapshot requested by a user.\n              More info:\
    \ https://kubernetes.io/docs/concepts/storage/volume-snapshots#volumesnapshots\n\
    \              Required.\n            properties:\n              source:\n   \
    \             description: |-\n                  source specifies where a snapshot\
    \ will be created from.\n                  This field is immutable after creation.\n\
    \                  Required.\n                properties:\n                  persistentVolumeClaimName:\n\
    \                    description: |-\n                      persistentVolumeClaimName\
    \ specifies the name of the PersistentVolumeClaim\n                      object\
    \ representing the volume from which a snapshot should be created.\n         \
    \             This PVC is assumed to be in the same namespace as the VolumeSnapshot\n\
    \                      object.\n                      This field should be set\
    \ if the snapshot does not exists, and needs to be\n                      created.\n\
    \                      This field is immutable.\n                    type: string\n\
    \                    x-kubernetes-validations:\n                    - message:\
    \ persistentVolumeClaimName is immutable\n                      rule: self ==\
    \ oldSelf\n                  volumeSnapshotContentName:\n                    description:\
    \ |-\n                      volumeSnapshotContentName specifies the name of a\
    \ pre-existing VolumeSnapshotContent\n                      object representing\
    \ an existing volume snapshot.\n                      This field should be set\
    \ if the snapshot already exists and only needs a representation in Kubernetes.\n\
    \                      This field is immutable.\n                    type: string\n\
    \                    x-kubernetes-validations:\n                    - message:\
    \ volumeSnapshotContentName is immutable\n                      rule: self ==\
    \ oldSelf\n                type: object\n                x-kubernetes-validations:\n\
    \                - message: persistentVolumeClaimName is required once set\n \
    \                 rule: '!has(oldSelf.persistentVolumeClaimName) || has(self.persistentVolumeClaimName)'\n\
    \                - message: volumeSnapshotContentName is required once set\n \
    \                 rule: '!has(oldSelf.volumeSnapshotContentName) || has(self.volumeSnapshotContentName)'\n\
    \                - message: exactly one of volumeSnapshotContentName and persistentVolumeClaimName\n\
    \                    must be set\n                  rule: (has(self.volumeSnapshotContentName)\
    \ && !has(self.persistentVolumeClaimName))\n                    || (!has(self.volumeSnapshotContentName)\
    \ && has(self.persistentVolumeClaimName))\n              volumeSnapshotClassName:\n\
    \                description: |-\n                  VolumeSnapshotClassName is\
    \ the name of the VolumeSnapshotClass\n                  requested by the VolumeSnapshot.\n\
    \                  VolumeSnapshotClassName may be left nil to indicate that the\
    \ default\n                  SnapshotClass should be used.\n                 \
    \ A given cluster may have multiple default Volume SnapshotClasses: one\n    \
    \              default per CSI Driver. If a VolumeSnapshot does not specify a\
    \ SnapshotClass,\n                  VolumeSnapshotSource will be checked to figure\
    \ out what the associated\n                  CSI Driver is, and the default VolumeSnapshotClass\
    \ associated with that\n                  CSI Driver will be used. If more than\
    \ one VolumeSnapshotClass exist for\n                  a given CSI Driver and\
    \ more than one have been marked as default,\n                  CreateSnapshot\
    \ will fail and generate an event.\n                  Empty string is not allowed\
    \ for this field.\n                type: string\n                x-kubernetes-validations:\n\
    \                - message: volumeSnapshotClassName must not be the empty string\
    \ when\n                    set\n                  rule: size(self) > 0\n    \
    \        required:\n            - source\n            type: object\n         \
    \ status:\n            description: |-\n              status represents the current\
    \ information of a snapshot.\n              Consumers must verify binding between\
    \ VolumeSnapshot and\n              VolumeSnapshotContent objects is successful\
    \ (by validating that both\n              VolumeSnapshot and VolumeSnapshotContent\
    \ point at each other) before\n              using this object.\n            properties:\n\
    \              boundVolumeSnapshotContentName:\n                description: |-\n\
    \                  boundVolumeSnapshotContentName is the name of the VolumeSnapshotContent\n\
    \                  object to which this VolumeSnapshot object intends to bind\
    \ to.\n                  If not specified, it indicates that the VolumeSnapshot\
    \ object has not been\n                  successfully bound to a VolumeSnapshotContent\
    \ object yet.\n                  NOTE: To avoid possible security issues, consumers\
    \ must verify binding between\n                  VolumeSnapshot and VolumeSnapshotContent\
    \ objects is successful (by validating that\n                  both VolumeSnapshot\
    \ and VolumeSnapshotContent point at each other) before using\n              \
    \    this object.\n                type: string\n              creationTime:\n\
    \                description: |-\n                  creationTime is the timestamp\
    \ when the point-in-time snapshot is taken\n                  by the underlying\
    \ storage system.\n                  In dynamic snapshot creation case, this field\
    \ will be filled in by the\n                  snapshot controller with the \"\
    creation_time\" value returned from CSI\n                  \"CreateSnapshot\"\
    \ gRPC call.\n                  For a pre-existing snapshot, this field will be\
    \ filled with the \"creation_time\"\n                  value returned from the\
    \ CSI \"ListSnapshots\" gRPC call if the driver supports it.\n               \
    \   If not specified, it may indicate that the creation time of the snapshot is\
    \ unknown.\n                format: date-time\n                type: string\n\
    \              error:\n                description: |-\n                  error\
    \ is the last observed error during snapshot creation, if any.\n             \
    \     This field could be helpful to upper level controllers(i.e., application\
    \ controller)\n                  to decide whether they should continue on waiting\
    \ for the snapshot to be created\n                  based on the type of error\
    \ reported.\n                  The snapshot controller will keep retrying when\
    \ an error occurs during the\n                  snapshot creation. Upon success,\
    \ this error field will be cleared.\n                properties:\n           \
    \       message:\n                    description: |-\n                      message\
    \ is a string detailing the encountered error during snapshot\n              \
    \        creation if specified.\n                      NOTE: message may be logged,\
    \ and it should not contain sensitive\n                      information.\n  \
    \                  type: string\n                  time:\n                   \
    \ description: time is the timestamp when the error was encountered.\n       \
    \             format: date-time\n                    type: string\n          \
    \      type: object\n              readyToUse:\n                description: |-\n\
    \                  readyToUse indicates if the snapshot is ready to be used to\
    \ restore a volume.\n                  In dynamic snapshot creation case, this\
    \ field will be filled in by the\n                  snapshot controller with the\
    \ \"ready_to_use\" value returned from CSI\n                  \"CreateSnapshot\"\
    \ gRPC call.\n                  For a pre-existing snapshot, this field will be\
    \ filled with the \"ready_to_use\"\n                  value returned from the\
    \ CSI \"ListSnapshots\" gRPC call if the driver supports it,\n               \
    \   otherwise, this field will be set to \"True\".\n                  If not specified,\
    \ it means the readiness of a snapshot is unknown.\n                type: boolean\n\
    \              restoreSize:\n                description: |-\n               \
    \   restoreSize represents the minimum size of volume required to create a volume\n\
    \                  from this snapshot.\n                  In dynamic snapshot\
    \ creation case, this field will be filled in by the\n                  snapshot\
    \ controller with the \"size_bytes\" value returned from CSI\n               \
    \   \"CreateSnapshot\" gRPC call.\n                  For a pre-existing snapshot,\
    \ this field will be filled with the \"size_bytes\"\n                  value returned\
    \ from the CSI \"ListSnapshots\" gRPC call if the driver supports it.\n      \
    \            When restoring a volume from this snapshot, the size of the volume\
    \ MUST NOT\n                  be smaller than the restoreSize if it is specified,\
    \ otherwise the restoration will fail.\n                  If not specified, it\
    \ indicates that the size is unknown.\n                pattern: ^(\\+|-)?(([0-9]+(\\\
    .[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\\
    .[0-9]+))))?$\n                type: string\n                x-kubernetes-int-or-string:\
    \ true\n              volumeGroupSnapshotName:\n                description: |-\n\
    \                  VolumeGroupSnapshotName is the name of the VolumeGroupSnapshot\
    \ of which this\n                  VolumeSnapshot is a part of.\n            \
    \    type: string\n            type: object\n        required:\n        - spec\n\
    \        type: object\n    served: true\n    storage: true\n    subresources:\n\
    \      status: {}\n  - additionalPrinterColumns:\n    - description: Indicates\
    \ if the snapshot is ready to be used to restore a volume.\n      jsonPath: .status.readyToUse\n\
    \      name: ReadyToUse\n      type: boolean\n    - description: If a new snapshot\
    \ needs to be created, this contains the name of\n        the source PVC from\
    \ which this snapshot was (or will be) created.\n      jsonPath: .spec.source.persistentVolumeClaimName\n\
    \      name: SourcePVC\n      type: string\n    - description: If a snapshot already\
    \ exists, this contains the name of the existing\n        VolumeSnapshotContent\
    \ object representing the existing snapshot.\n      jsonPath: .spec.source.volumeSnapshotContentName\n\
    \      name: SourceSnapshotContent\n      type: string\n    - description: Represents\
    \ the minimum size of volume required to rehydrate from\n        this snapshot.\n\
    \      jsonPath: .status.restoreSize\n      name: RestoreSize\n      type: string\n\
    \    - description: The name of the VolumeSnapshotClass requested by the VolumeSnapshot.\n\
    \      jsonPath: .spec.volumeSnapshotClassName\n      name: SnapshotClass\n  \
    \    type: string\n    - description: Name of the VolumeSnapshotContent object\
    \ to which the VolumeSnapshot\n        object intends to bind to. Please note\
    \ that verification of binding actually\n        requires checking both VolumeSnapshot\
    \ and VolumeSnapshotContent to ensure\n        both are pointing at each other.\
    \ Binding MUST be verified prior to usage of\n        this object.\n      jsonPath:\
    \ .status.boundVolumeSnapshotContentName\n      name: SnapshotContent\n      type:\
    \ string\n    - description: Timestamp when the point-in-time snapshot was taken\
    \ by the underlying\n        storage system.\n      jsonPath: .status.creationTime\n\
    \      name: CreationTime\n      type: date\n    - jsonPath: .metadata.creationTimestamp\n\
    \      name: Age\n      type: date\n    deprecated: true\n    deprecationWarning:\
    \ snapshot.storage.k8s.io/v1beta1 VolumeSnapshot is deprecated;\n      use snapshot.storage.k8s.io/v1\
    \ VolumeSnapshot\n    name: v1beta1\n    schema:\n      openAPIV3Schema:\n   \
    \     description: VolumeSnapshot is a user's request for either creating a point-in-time\n\
    \          snapshot of a persistent volume, or binding to a pre-existing snapshot.\n\
    \        properties:\n          apiVersion:\n            description: 'APIVersion\
    \ defines the versioned schema of this representation\n              of an object.\
    \ Servers should convert recognized schemas to the latest\n              internal\
    \ value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'\n\
    \            type: string\n          kind:\n            description: 'Kind is\
    \ a string value representing the REST resource this\n              object represents.\
    \ Servers may infer this from the endpoint the client\n              submits requests\
    \ to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'\n\
    \            type: string\n          spec:\n            description: 'spec defines\
    \ the desired characteristics of a snapshot requested\n              by a user.\
    \ More info: https://kubernetes.io/docs/concepts/storage/volume-snapshots#volumesnapshots\n\
    \              Required.'\n            properties:\n              source:\n  \
    \              description: source specifies where a snapshot will be created\
    \ from.\n                  This field is immutable after creation. Required.\n\
    \                properties:\n                  persistentVolumeClaimName:\n \
    \                   description: persistentVolumeClaimName specifies the name\
    \ of the\n                      PersistentVolumeClaim object representing the\
    \ volume from which\n                      a snapshot should be created. This\
    \ PVC is assumed to be in the\n                      same namespace as the VolumeSnapshot\
    \ object. This field should\n                      be set if the snapshot does\
    \ not exists, and needs to be created.\n                      This field is immutable.\n\
    \                    type: string\n                  volumeSnapshotContentName:\n\
    \                    description: volumeSnapshotContentName specifies the name\
    \ of a\n                      pre-existing VolumeSnapshotContent object representing\
    \ an existing\n                      volume snapshot. This field should be set\
    \ if the snapshot already\n                      exists and only needs a representation\
    \ in Kubernetes. This field\n                      is immutable.\n           \
    \         type: string\n                type: object\n              volumeSnapshotClassName:\n\
    \                description: 'VolumeSnapshotClassName is the name of the VolumeSnapshotClass\n\
    \                  requested by the VolumeSnapshot. VolumeSnapshotClassName may\
    \ be\n                  left nil to indicate that the default SnapshotClass should\
    \ be used.\n                  A given cluster may have multiple default Volume\
    \ SnapshotClasses:\n                  one default per CSI Driver. If a VolumeSnapshot\
    \ does not specify\n                  a SnapshotClass, VolumeSnapshotSource will\
    \ be checked to figure\n                  out what the associated CSI Driver is,\
    \ and the default VolumeSnapshotClass\n                  associated with that\
    \ CSI Driver will be used. If more than one VolumeSnapshotClass\n            \
    \      exist for a given CSI Driver and more than one have been marked\n     \
    \             as default, CreateSnapshot will fail and generate an event. Empty\n\
    \                  string is not allowed for this field.'\n                type:\
    \ string\n            required:\n            - source\n            type: object\n\
    \          status:\n            description: status represents the current information\
    \ of a snapshot.\n              Consumers must verify binding between VolumeSnapshot\
    \ and VolumeSnapshotContent\n              objects is successful (by validating\
    \ that both VolumeSnapshot and VolumeSnapshotContent\n              point at each\
    \ other) before using this object.\n            properties:\n              boundVolumeSnapshotContentName:\n\
    \                description: 'boundVolumeSnapshotContentName is the name of the\
    \ VolumeSnapshotContent\n                  object to which this VolumeSnapshot\
    \ object intends to bind to. If\n                  not specified, it indicates\
    \ that the VolumeSnapshot object has not\n                  been successfully\
    \ bound to a VolumeSnapshotContent object yet. NOTE:\n                  To avoid\
    \ possible security issues, consumers must verify binding\n                  between\
    \ VolumeSnapshot and VolumeSnapshotContent objects is successful\n           \
    \       (by validating that both VolumeSnapshot and VolumeSnapshotContent\n  \
    \                point at each other) before using this object.'\n           \
    \     type: string\n              creationTime:\n                description:\
    \ creationTime is the timestamp when the point-in-time\n                  snapshot\
    \ is taken by the underlying storage system. In dynamic snapshot\n           \
    \       creation case, this field will be filled in by the snapshot controller\n\
    \                  with the \"creation_time\" value returned from CSI \"CreateSnapshot\"\
    \n                  gRPC call. For a pre-existing snapshot, this field will be\
    \ filled\n                  with the \"creation_time\" value returned from the\
    \ CSI \"ListSnapshots\"\n                  gRPC call if the driver supports it.\
    \ If not specified, it may indicate\n                  that the creation time\
    \ of the snapshot is unknown.\n                format: date-time\n           \
    \     type: string\n              error:\n                description: error is\
    \ the last observed error during snapshot creation,\n                  if any.\
    \ This field could be helpful to upper level controllers(i.e.,\n             \
    \     application controller) to decide whether they should continue on\n    \
    \              waiting for the snapshot to be created based on the type of error\n\
    \                  reported. The snapshot controller will keep retrying when an\
    \ error\n                  occurs during the snapshot creation. Upon success,\
    \ this error field\n                  will be cleared.\n                properties:\n\
    \                  message:\n                    description: 'message is a string\
    \ detailing the encountered error\n                      during snapshot creation\
    \ if specified. NOTE: message may be\n                      logged, and it should\
    \ not contain sensitive information.'\n                    type: string\n    \
    \              time:\n                    description: time is the timestamp when\
    \ the error was encountered.\n                    format: date-time\n        \
    \            type: string\n                type: object\n              readyToUse:\n\
    \                description: readyToUse indicates if the snapshot is ready to\
    \ be used\n                  to restore a volume. In dynamic snapshot creation\
    \ case, this field\n                  will be filled in by the snapshot controller\
    \ with the \"ready_to_use\"\n                  value returned from CSI \"CreateSnapshot\"\
    \ gRPC call. For a pre-existing\n                  snapshot, this field will be\
    \ filled with the \"ready_to_use\" value\n                  returned from the\
    \ CSI \"ListSnapshots\" gRPC call if the driver supports\n                  it,\
    \ otherwise, this field will be set to \"True\". If not specified,\n         \
    \         it means the readiness of a snapshot is unknown.\n                type:\
    \ boolean\n              restoreSize:\n                description: restoreSize\
    \ represents the minimum size of volume required\n                  to create\
    \ a volume from this snapshot. In dynamic snapshot creation\n                \
    \  case, this field will be filled in by the snapshot controller with\n      \
    \            the \"size_bytes\" value returned from CSI \"CreateSnapshot\" gRPC\
    \ call.\n                  For a pre-existing snapshot, this field will be filled\
    \ with the\n                  \"size_bytes\" value returned from the CSI \"ListSnapshots\"\
    \ gRPC call\n                  if the driver supports it. When restoring a volume\
    \ from this snapshot,\n                  the size of the volume MUST NOT be smaller\
    \ than the restoreSize\n                  if it is specified, otherwise the restoration\
    \ will fail. If not\n                  specified, it indicates that the size is\
    \ unknown.\n                pattern: ^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\\
    +|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$\n                type: string\n  \
    \              x-kubernetes-int-or-string: true\n            type: object\n  \
    \      required:\n        - spec\n        type: object\n    served: false\n  \
    \  storage: false\n    subresources:\n      status: {}\nstatus:\n  acceptedNames:\n\
    \    kind: \"\"\n    plural: \"\"\n  conditions: []\n  storedVersions: []\n---\n\
    apiVersion: v1\nkind: ServiceAccount\nmetadata:\n  labels:\n    app.kubernetes.io/instance:\
    \ snapshot-controller\n    app.kubernetes.io/managed-by: Helm\n    app.kubernetes.io/name:\
    \ snapshot-controller\n    app.kubernetes.io/version: v8.2.1\n    helm.sh/chart:\
    \ snapshot-controller-4.0.2\n  name: snapshot-controller\n  namespace: kube-system\n\
    ---\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name:\
    \ snapshot-controller\n  namespace: kube-system\nrules:\n- apiGroups:\n  - coordination.k8s.io\n\
    \  resources:\n  - leases\n  verbs:\n  - get\n  - watch\n  - list\n  - delete\n\
    \  - update\n  - create\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind:\
    \ ClusterRole\nmetadata:\n  name: snapshot-controller\nrules:\n- apiGroups:\n\
    \  - \"\"\n  resources:\n  - persistentvolumes\n  verbs:\n  - get\n  - list\n\
    \  - watch\n- apiGroups:\n  - \"\"\n  resources:\n  - persistentvolumeclaims\n\
    \  verbs:\n  - get\n  - list\n  - watch\n  - update\n- apiGroups:\n  - \"\"\n\
    \  resources:\n  - events\n  verbs:\n  - list\n  - watch\n  - create\n  - update\n\
    \  - patch\n- apiGroups:\n  - snapshot.storage.k8s.io\n  resources:\n  - volumesnapshotclasses\n\
    \  verbs:\n  - get\n  - list\n  - watch\n- apiGroups:\n  - snapshot.storage.k8s.io\n\
    \  resources:\n  - volumesnapshotcontents\n  verbs:\n  - create\n  - get\n  -\
    \ list\n  - watch\n  - update\n  - delete\n  - patch\n- apiGroups:\n  - snapshot.storage.k8s.io\n\
    \  resources:\n  - volumesnapshotcontents/status\n  verbs:\n  - patch\n- apiGroups:\n\
    \  - snapshot.storage.k8s.io\n  resources:\n  - volumesnapshots\n  verbs:\n  -\
    \ create\n  - get\n  - list\n  - watch\n  - update\n  - patch\n  - delete\n- apiGroups:\n\
    \  - snapshot.storage.k8s.io\n  resources:\n  - volumesnapshots/status\n  verbs:\n\
    \  - update\n  - patch\n- apiGroups:\n  - groupsnapshot.storage.k8s.io\n  resources:\n\
    \  - volumegroupsnapshotclasses\n  verbs:\n  - get\n  - list\n  - watch\n- apiGroups:\n\
    \  - groupsnapshot.storage.k8s.io\n  resources:\n  - volumegroupsnapshotcontents\n\
    \  verbs:\n  - create\n  - get\n  - list\n  - watch\n  - update\n  - delete\n\
    \  - patch\n- apiGroups:\n  - groupsnapshot.storage.k8s.io\n  resources:\n  -\
    \ volumegroupsnapshotcontents/status\n  verbs:\n  - patch\n- apiGroups:\n  - groupsnapshot.storage.k8s.io\n\
    \  resources:\n  - volumegroupsnapshots\n  verbs:\n  - get\n  - list\n  - watch\n\
    \  - update\n  - patch\n- apiGroups:\n  - groupsnapshot.storage.k8s.io\n  resources:\n\
    \  - volumegroupsnapshots/status\n  verbs:\n  - update\n  - patch\n---\napiVersion:\
    \ rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: snapshot-controller\n\
    \  namespace: kube-system\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n \
    \ kind: Role\n  name: snapshot-controller\nsubjects:\n- kind: ServiceAccount\n\
    \  name: snapshot-controller\n  namespace: kube-system\n---\napiVersion: rbac.authorization.k8s.io/v1\n\
    kind: ClusterRoleBinding\nmetadata:\n  name: snapshot-controller\nroleRef:\n \
    \ apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: snapshot-controller\n\
    subjects:\n- kind: ServiceAccount\n  name: snapshot-controller\n  namespace: kube-system\n\
    ---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  labels:\n    app.kubernetes.io/instance:\
    \ snapshot-controller\n    app.kubernetes.io/managed-by: Helm\n    app.kubernetes.io/name:\
    \ snapshot-controller\n    app.kubernetes.io/version: v8.2.1\n    helm.sh/chart:\
    \ snapshot-controller-4.0.2\n  name: snapshot-controller\n  namespace: kube-system\n\
    spec:\n  replicas: 1\n  revisionHistoryLimit: 10\n  selector:\n    matchLabels:\n\
    \      app.kubernetes.io/instance: snapshot-controller\n      app.kubernetes.io/name:\
    \ snapshot-controller\n  template:\n    metadata:\n      labels:\n        app.kubernetes.io/instance:\
    \ snapshot-controller\n        app.kubernetes.io/name: snapshot-controller\n \
    \   spec:\n      containers:\n      - args:\n        - --http-endpoint=:8080\n\
    \        - --leader-election=true\n        - --leader-election-namespace=$(NAMESPACE)\n\
    \        env:\n        - name: NAMESPACE\n          valueFrom:\n            fieldRef:\n\
    \              fieldPath: metadata.namespace\n        image: registry.k8s.io/sig-storage/snapshot-controller:v8.2.1\n\
    \        imagePullPolicy: IfNotPresent\n        livenessProbe:\n          httpGet:\n\
    \            path: /healthz/leader-election\n            port: http\n        \
    \    scheme: HTTP\n        name: snapshot-controller\n        ports:\n       \
    \ - containerPort: 8080\n          name: http\n          protocol: TCP\n     \
    \   readinessProbe:\n          httpGet:\n            path: /healthz/leader-election\n\
    \            port: http\n            scheme: HTTP\n        resources: {}\n   \
    \     securityContext:\n          capabilities:\n            drop:\n         \
    \   - ALL\n          readOnlyRootFilesystem: true\n          runAsNonRoot: true\n\
    \          runAsUser: 1000\n      dnsPolicy: ClusterFirst\n      hostNetwork:\
    \ false\n      priorityClassName: system-cluster-critical\n      securityContext:\
    \ {}\n      serviceAccountName: snapshot-controller\n      tolerations:\n    \
    \  - key: CriticalAddonsOnly\n        operator: Exists\n      - effect: NoExecute\n\
    \        operator: Exists\n        tolerationSeconds: 300\n      - effect: NoSchedule\n\
    \        key: node-role.kubernetes.io/control-plane\n        operator: Exists\n"
kind: ConfigMap
metadata:
  creationTimestamp: null
  labels:
    cluster.x-k8s.io/provider: runtime-extension-caren
    clusterctl.cluster.x-k8s.io: ''
  name: snapshot-controller
  namespace: cluster-api
---
apiVersion: v1
data:
  aws-ccm: 'ChartName: aws-cloud-controller-manager

    ChartVersion: 0.0.8

    RepositoryURL: ''oci://helm-repository.caren-system.svc/charts''

    '
  aws-ebs-csi: 'ChartName: aws-ebs-csi-driver

    ChartVersion: 2.44.0

    RepositoryURL: ''oci://helm-repository.caren-system.svc/charts''

    '
  cilium: 'ChartName: cilium

    ChartVersion: 1.17.4

    RepositoryURL: ''oci://helm-repository.caren-system.svc/charts''

    '
  cluster-autoscaler: 'ChartName: cluster-autoscaler

    ChartVersion: 9.48.0

    RepositoryURL: ''oci://helm-repository.caren-system.svc/charts''

    '
  cncf-distribution-registry: 'ChartName: docker-registry

    ChartVersion: 2.3.5

    RepositoryURL: ''oci://helm-repository.caren-system.svc/charts''

    '
  cosi-controller: 'ChartName: cosi

    ChartVersion: 0.0.1-alpha.5

    RepositoryURL: ''oci://helm-repository.caren-system.svc/charts''

    '
  local-path-provisioner-csi: 'ChartName: local-path-provisioner

    ChartVersion: 0.0.31

    RepositoryURL: ''oci://helm-repository.caren-system.svc/charts''

    '
  metallb: 'ChartName: metallb

    ChartVersion: 0.15.2

    RepositoryURL: ''oci://helm-repository.caren-system.svc/charts''

    '
  nfd: 'ChartName: node-feature-discovery

    ChartVersion: 0.17.3

    RepositoryURL: ''oci://helm-repository.caren-system.svc/charts''

    '
  nutanix-ccm: 'ChartName: nutanix-cloud-provider

    ChartVersion: 0.5.2

    RepositoryURL: ''oci://helm-repository.caren-system.svc/charts''

    '
  nutanix-storage-csi: 'ChartName: nutanix-csi-storage

    ChartVersion: 3.3.4

    RepositoryURL: ''oci://helm-repository.caren-system.svc/charts''

    '
  registry-syncer: 'ChartName: registry-syncer

    ChartVersion: 0.1.0

    RepositoryURL: ''oci://helm-repository.caren-system.svc/charts''

    '
  snapshot-controller: 'ChartName: snapshot-controller

    ChartVersion: 4.0.2

    RepositoryURL: ''oci://helm-repository.caren-system.svc/charts''

    '
  tigera-operator: 'ChartName: tigera-operator

    ChartVersion: v3.29.4

    RepositoryURL: ''oci://helm-repository.caren-system.svc/charts''

    '
kind: ConfigMap
metadata:
  creationTimestamp: null
  labels:
    cluster.x-k8s.io/provider: runtime-extension-caren
    clusterctl.cluster.x-k8s.io: ''
  name: default-helm-addons-config
  namespace: cluster-api
---
apiVersion: v1
data:
  values.yaml: "priorityClass: system-node-critical\n\nmaster:\n  extraLabelNs:\n\
    \    - nvidia.com\n    - beta.amd.com\n    - amd.com\n  tolerations:\n    - key:\
    \ \"node-role.kubernetes.io/control-plane\"\n      operator: \"Equal\"\n     \
    \ value: \"\"\n      effect: \"NoSchedule\"\n  affinity:\n    nodeAffinity:\n\
    \      preferredDuringSchedulingIgnoredDuringExecution:\n        - weight: 1\n\
    \          preference:\n            matchExpressions:\n              - key: \"\
    node-role.kubernetes.io/control-plane\"\n                operator: In\n      \
    \          values: [\"\"]\n\nworker: ### <NFD-WORKER-CONF-START-DO-NOT-REMOVE>\n\
    \  config:\n    sources:\n      pci:\n        deviceLabelFields:\n          -\
    \ \"class\"\n          - \"vendor\"\n  tolerations:\n    - effect: NoSchedule\n\
    \      operator: Exists\n\ngc:\n  tolerations:\n    - effect: NoSchedule\n   \
    \   key: node-role.kubernetes.io/control-plane"
kind: ConfigMap
metadata:
  labels:
    cluster.x-k8s.io/provider: runtime-extension-caren
    clusterctl.cluster.x-k8s.io: ''
  name: default-nfd-helm-values-template
  namespace: cluster-api
---
apiVersion: v1
data:
  node-feature-discovery.yaml: "apiVersion: v1\nkind: Namespace\nmetadata:\n  labels:\n\
    \    pod-security.kubernetes.io/enforce: privileged\n    pod-security.kubernetes.io/enforce-version:\
    \ latest\n  name: node-feature-discovery\n---\napiVersion: apiextensions.k8s.io/v1\n\
    kind: CustomResourceDefinition\nmetadata:\n  annotations:\n    controller-gen.kubebuilder.io/version:\
    \ v0.16.3\n  name: nodefeatures.nfd.k8s-sigs.io\nspec:\n  group: nfd.k8s-sigs.io\n\
    \  names:\n    kind: NodeFeature\n    listKind: NodeFeatureList\n    plural: nodefeatures\n\
    \    singular: nodefeature\n  scope: Namespaced\n  versions:\n  - name: v1alpha1\n\
    \    schema:\n      openAPIV3Schema:\n        description: |-\n          NodeFeature\
    \ resource holds the features discovered for one node in the\n          cluster.\n\
    \        properties:\n          apiVersion:\n            description: |-\n   \
    \           APIVersion defines the versioned schema of this representation of\
    \ an object.\n              Servers should convert recognized schemas to the latest\
    \ internal value, and\n              may reject unrecognized values.\n       \
    \       More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources\n\
    \            type: string\n          kind:\n            description: |-\n    \
    \          Kind is a string value representing the REST resource this object represents.\n\
    \              Servers may infer this from the endpoint the client submits requests\
    \ to.\n              Cannot be updated.\n              In CamelCase.\n       \
    \       More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds\n\
    \            type: string\n          metadata:\n            type: object\n   \
    \       spec:\n            description: Specification of the NodeFeature, containing\
    \ features discovered\n              for a node.\n            properties:\n  \
    \            features:\n                description: Features is the full \"raw\"\
    \ features data that has been\n                  discovered.\n               \
    \ properties:\n                  attributes:\n                    additionalProperties:\n\
    \                      description: AttributeFeatureSet is a set of features having\n\
    \                        string value.\n                      properties:\n  \
    \                      elements:\n                          additionalProperties:\n\
    \                            type: string\n                          description:\
    \ Individual features of the feature set.\n                          type: object\n\
    \                      required:\n                      - elements\n         \
    \             type: object\n                    description: Attributes contains\
    \ all the attribute-type features\n                      of the node.\n      \
    \              type: object\n                  flags:\n                    additionalProperties:\n\
    \                      description: FlagFeatureSet is a set of simple features\
    \ only\n                        containing names without values.\n           \
    \           properties:\n                        elements:\n                 \
    \         additionalProperties:\n                            description: |-\n\
    \                              Nil is a dummy empty struct for protobuf compatibility.\n\
    \                              NOTE: protobuf definitions have been removed but\
    \ this is kept for API compatibility.\n                            type: object\n\
    \                          description: Individual features of the feature set.\n\
    \                          type: object\n                      required:\n   \
    \                   - elements\n                      type: object\n         \
    \           description: Flags contains all the flag-type features of the\n  \
    \                    node.\n                    type: object\n               \
    \   instances:\n                    additionalProperties:\n                  \
    \    description: InstanceFeatureSet is a set of features each of\n          \
    \              which is an instance having multiple attributes.\n            \
    \          properties:\n                        elements:\n                  \
    \        description: Individual features of the feature set.\n              \
    \            items:\n                            description: InstanceFeature\
    \ represents one instance of\n                              a complex features,\
    \ e.g. a device.\n                            properties:\n                  \
    \            attributes:\n                                additionalProperties:\n\
    \                                  type: string\n                            \
    \    description: Attributes of the instance feature.\n                      \
    \          type: object\n                            required:\n             \
    \               - attributes\n                            type: object\n     \
    \                     type: array\n                      required:\n         \
    \             - elements\n                      type: object\n               \
    \     description: Instances contains all the instance-type features\n       \
    \               of the node.\n                    type: object\n             \
    \   type: object\n              labels:\n                additionalProperties:\n\
    \                  type: string\n                description: Labels is the set\
    \ of node labels that are requested to\n                  be created.\n      \
    \          type: object\n            type: object\n        required:\n       \
    \ - spec\n        type: object\n    served: true\n    storage: true\n---\napiVersion:\
    \ apiextensions.k8s.io/v1\nkind: CustomResourceDefinition\nmetadata:\n  annotations:\n\
    \    controller-gen.kubebuilder.io/version: v0.16.3\n  name: nodefeaturegroups.nfd.k8s-sigs.io\n\
    spec:\n  group: nfd.k8s-sigs.io\n  names:\n    kind: NodeFeatureGroup\n    listKind:\
    \ NodeFeatureGroupList\n    plural: nodefeaturegroups\n    shortNames:\n    -\
    \ nfg\n    singular: nodefeaturegroup\n  scope: Namespaced\n  versions:\n  - name:\
    \ v1alpha1\n    schema:\n      openAPIV3Schema:\n        description: NodeFeatureGroup\
    \ resource holds Node pools by featureGroup\n        properties:\n          apiVersion:\n\
    \            description: |-\n              APIVersion defines the versioned schema\
    \ of this representation of an object.\n              Servers should convert recognized\
    \ schemas to the latest internal value, and\n              may reject unrecognized\
    \ values.\n              More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources\n\
    \            type: string\n          kind:\n            description: |-\n    \
    \          Kind is a string value representing the REST resource this object represents.\n\
    \              Servers may infer this from the endpoint the client submits requests\
    \ to.\n              Cannot be updated.\n              In CamelCase.\n       \
    \       More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds\n\
    \            type: string\n          metadata:\n            type: object\n   \
    \       spec:\n            description: Spec defines the rules to be evaluated.\n\
    \            properties:\n              featureGroupRules:\n                description:\
    \ List of rules to evaluate to determine nodes that belong\n                 \
    \ in this group.\n                items:\n                  description: GroupRule\
    \ defines a rule for nodegroup filtering.\n                  properties:\n   \
    \                 matchAny:\n                      description: MatchAny specifies\
    \ a list of matchers one of which\n                        must match.\n     \
    \                 items:\n                        description: MatchAnyElem specifies\
    \ one sub-matcher of MatchAny.\n                        properties:\n        \
    \                  matchFeatures:\n                            description: MatchFeatures\
    \ specifies a set of matcher\n                              terms all of which\
    \ must match.\n                            items:\n                          \
    \    description: |-\n                                FeatureMatcherTerm defines\
    \ requirements against one feature set. All\n                                requirements\
    \ (specified as MatchExpressions) are evaluated against each\n               \
    \                 element in the feature set.\n                              properties:\n\
    \                                feature:\n                                  description:\
    \ Feature is the name of the feature\n                                    set\
    \ to match against.\n                                  type: string\n        \
    \                        matchExpressions:\n                                 \
    \ additionalProperties:\n                                    description: |-\n\
    \                                      MatchExpression specifies an expression\
    \ to evaluate against a set of input\n                                      values.\
    \ It contains an operator that is applied when matching the input and\n      \
    \                                an array of values that the operator evaluates\
    \ the input against.\n                                    properties:\n      \
    \                                op:\n                                       \
    \ description: Op is the operator to be applied.\n                           \
    \             enum:\n                                        - In\n          \
    \                              - NotIn\n                                     \
    \   - InRegexp\n                                        - Exists\n           \
    \                             - DoesNotExist\n                               \
    \         - Gt\n                                        - Lt\n               \
    \                         - GtLt\n                                        - IsTrue\n\
    \                                        - IsFalse\n                         \
    \               type: string\n                                      value:\n \
    \                                       description: |-\n                    \
    \                      Value is the list of values that the operand evaluates\
    \ the input\n                                          against. Value should be\
    \ empty if the operator is Exists, DoesNotExist,\n                           \
    \               IsTrue or IsFalse. Value should contain exactly one element if\
    \ the\n                                          operator is Gt or Lt and exactly\
    \ two elements if the operator is GtLt.\n                                    \
    \      In other cases Value should contain at least one element.\n           \
    \                             items:\n                                       \
    \   type: string\n                                        type: array\n      \
    \                              required:\n                                   \
    \ - op\n                                    type: object\n                   \
    \               description: |-\n                                    MatchExpressions\
    \ is the set of per-element expressions evaluated. These\n                   \
    \                 match against the value of the specified elements.\n       \
    \                           type: object\n                                matchName:\n\
    \                                  description: |-\n                         \
    \           MatchName in an expression that is matched against the name of each\n\
    \                                    element in the feature set.\n           \
    \                       properties:\n                                    op:\n\
    \                                      description: Op is the operator to be applied.\n\
    \                                      enum:\n                               \
    \       - In\n                                      - NotIn\n                \
    \                      - InRegexp\n                                      - Exists\n\
    \                                      - DoesNotExist\n                      \
    \                - Gt\n                                      - Lt\n          \
    \                            - GtLt\n                                      - IsTrue\n\
    \                                      - IsFalse\n                           \
    \           type: string\n                                    value:\n       \
    \                               description: |-\n                            \
    \            Value is the list of values that the operand evaluates the input\n\
    \                                        against. Value should be empty if the\
    \ operator is Exists, DoesNotExist,\n                                        IsTrue\
    \ or IsFalse. Value should contain exactly one element if the\n              \
    \                          operator is Gt or Lt and exactly two elements if the\
    \ operator is GtLt.\n                                        In other cases Value\
    \ should contain at least one element.\n                                     \
    \ items:\n                                        type: string\n             \
    \                         type: array\n                                  required:\n\
    \                                  - op\n                                  type:\
    \ object\n                              required:\n                          \
    \    - feature\n                              type: object\n                 \
    \           type: array\n                        required:\n                 \
    \       - matchFeatures\n                        type: object\n              \
    \        type: array\n                    matchFeatures:\n                   \
    \   description: MatchFeatures specifies a set of matcher terms\n            \
    \            all of which must match.\n                      items:\n        \
    \                description: |-\n                          FeatureMatcherTerm\
    \ defines requirements against one feature set. All\n                        \
    \  requirements (specified as MatchExpressions) are evaluated against each\n \
    \                         element in the feature set.\n                      \
    \  properties:\n                          feature:\n                         \
    \   description: Feature is the name of the feature set to\n                 \
    \             match against.\n                            type: string\n     \
    \                     matchExpressions:\n                            additionalProperties:\n\
    \                              description: |-\n                             \
    \   MatchExpression specifies an expression to evaluate against a set of input\n\
    \                                values. It contains an operator that is applied\
    \ when matching the input and\n                                an array of values\
    \ that the operator evaluates the input against.\n                           \
    \   properties:\n                                op:\n                       \
    \           description: Op is the operator to be applied.\n                 \
    \                 enum:\n                                  - In\n            \
    \                      - NotIn\n                                  - InRegexp\n\
    \                                  - Exists\n                                \
    \  - DoesNotExist\n                                  - Gt\n                  \
    \                - Lt\n                                  - GtLt\n            \
    \                      - IsTrue\n                                  - IsFalse\n\
    \                                  type: string\n                            \
    \    value:\n                                  description: |-\n             \
    \                       Value is the list of values that the operand evaluates\
    \ the input\n                                    against. Value should be empty\
    \ if the operator is Exists, DoesNotExist,\n                                 \
    \   IsTrue or IsFalse. Value should contain exactly one element if the\n     \
    \                               operator is Gt or Lt and exactly two elements\
    \ if the operator is GtLt.\n                                    In other cases\
    \ Value should contain at least one element.\n                               \
    \   items:\n                                    type: string\n               \
    \                   type: array\n                              required:\n   \
    \                           - op\n                              type: object\n\
    \                            description: |-\n                              MatchExpressions\
    \ is the set of per-element expressions evaluated. These\n                   \
    \           match against the value of the specified elements.\n             \
    \               type: object\n                          matchName:\n         \
    \                   description: |-\n                              MatchName in\
    \ an expression that is matched against the name of each\n                   \
    \           element in the feature set.\n                            properties:\n\
    \                              op:\n                                description:\
    \ Op is the operator to be applied.\n                                enum:\n \
    \                               - In\n                                - NotIn\n\
    \                                - InRegexp\n                                -\
    \ Exists\n                                - DoesNotExist\n                   \
    \             - Gt\n                                - Lt\n                   \
    \             - GtLt\n                                - IsTrue\n             \
    \                   - IsFalse\n                                type: string\n\
    \                              value:\n                                description:\
    \ |-\n                                  Value is the list of values that the operand\
    \ evaluates the input\n                                  against. Value should\
    \ be empty if the operator is Exists, DoesNotExist,\n                        \
    \          IsTrue or IsFalse. Value should contain exactly one element if the\n\
    \                                  operator is Gt or Lt and exactly two elements\
    \ if the operator is GtLt.\n                                  In other cases Value\
    \ should contain at least one element.\n                                items:\n\
    \                                  type: string\n                            \
    \    type: array\n                            required:\n                    \
    \        - op\n                            type: object\n                    \
    \    required:\n                        - feature\n                        type:\
    \ object\n                      type: array\n                    name:\n     \
    \                 description: Name of the rule.\n                      type:\
    \ string\n                  required:\n                  - name\n            \
    \      type: object\n                type: array\n            required:\n    \
    \        - featureGroupRules\n            type: object\n          status:\n  \
    \          description: |-\n              Status of the NodeFeatureGroup after\
    \ the most recent evaluation of the\n              specification.\n          \
    \  properties:\n              nodes:\n                description: Nodes is a\
    \ list of FeatureGroupNode in the cluster that\n                  match the featureGroupRules\n\
    \                items:\n                  properties:\n                    name:\n\
    \                      description: Name of the node.\n                      type:\
    \ string\n                  required:\n                  - name\n            \
    \      type: object\n                type: array\n                x-kubernetes-list-map-keys:\n\
    \                - name\n                x-kubernetes-list-type: map\n       \
    \     type: object\n        required:\n        - spec\n        type: object\n\
    \    served: true\n    storage: true\n    subresources:\n      status: {}\n---\n\
    apiVersion: apiextensions.k8s.io/v1\nkind: CustomResourceDefinition\nmetadata:\n\
    \  annotations:\n    controller-gen.kubebuilder.io/version: v0.16.3\n  name: nodefeaturerules.nfd.k8s-sigs.io\n\
    spec:\n  group: nfd.k8s-sigs.io\n  names:\n    kind: NodeFeatureRule\n    listKind:\
    \ NodeFeatureRuleList\n    plural: nodefeaturerules\n    shortNames:\n    - nfr\n\
    \    singular: nodefeaturerule\n  scope: Cluster\n  versions:\n  - name: v1alpha1\n\
    \    schema:\n      openAPIV3Schema:\n        description: |-\n          NodeFeatureRule\
    \ resource specifies a configuration for feature-based\n          customization\
    \ of node objects, such as node labeling.\n        properties:\n          apiVersion:\n\
    \            description: |-\n              APIVersion defines the versioned schema\
    \ of this representation of an object.\n              Servers should convert recognized\
    \ schemas to the latest internal value, and\n              may reject unrecognized\
    \ values.\n              More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources\n\
    \            type: string\n          kind:\n            description: |-\n    \
    \          Kind is a string value representing the REST resource this object represents.\n\
    \              Servers may infer this from the endpoint the client submits requests\
    \ to.\n              Cannot be updated.\n              In CamelCase.\n       \
    \       More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds\n\
    \            type: string\n          metadata:\n            type: object\n   \
    \       spec:\n            description: Spec defines the rules to be evaluated.\n\
    \            properties:\n              rules:\n                description: Rules\
    \ is a list of node customization rules.\n                items:\n           \
    \       description: Rule defines a rule for node customization such as\n    \
    \                labeling.\n                  properties:\n                  \
    \  annotations:\n                      additionalProperties:\n               \
    \         type: string\n                      description: Annotations to create\
    \ if the rule matches.\n                      type: object\n                 \
    \   extendedResources:\n                      additionalProperties:\n        \
    \                type: string\n                      description: ExtendedResources\
    \ to create if the rule matches.\n                      type: object\n       \
    \             labels:\n                      additionalProperties:\n         \
    \               type: string\n                      description: Labels to create\
    \ if the rule matches.\n                      type: object\n                 \
    \   labelsTemplate:\n                      description: |-\n                 \
    \       LabelsTemplate specifies a template to expand for dynamically generating\n\
    \                        multiple labels. Data (after template expansion) must\
    \ be keys with an\n                        optional value (<key>[=<value>]) separated\
    \ by newlines.\n                      type: string\n                    matchAny:\n\
    \                      description: MatchAny specifies a list of matchers one\
    \ of which\n                        must match.\n                      items:\n\
    \                        description: MatchAnyElem specifies one sub-matcher of\
    \ MatchAny.\n                        properties:\n                          matchFeatures:\n\
    \                            description: MatchFeatures specifies a set of matcher\n\
    \                              terms all of which must match.\n              \
    \              items:\n                              description: |-\n       \
    \                         FeatureMatcherTerm defines requirements against one\
    \ feature set. All\n                                requirements (specified as\
    \ MatchExpressions) are evaluated against each\n                             \
    \   element in the feature set.\n                              properties:\n \
    \                               feature:\n                                  description:\
    \ Feature is the name of the feature\n                                    set\
    \ to match against.\n                                  type: string\n        \
    \                        matchExpressions:\n                                 \
    \ additionalProperties:\n                                    description: |-\n\
    \                                      MatchExpression specifies an expression\
    \ to evaluate against a set of input\n                                      values.\
    \ It contains an operator that is applied when matching the input and\n      \
    \                                an array of values that the operator evaluates\
    \ the input against.\n                                    properties:\n      \
    \                                op:\n                                       \
    \ description: Op is the operator to be applied.\n                           \
    \             enum:\n                                        - In\n          \
    \                              - NotIn\n                                     \
    \   - InRegexp\n                                        - Exists\n           \
    \                             - DoesNotExist\n                               \
    \         - Gt\n                                        - Lt\n               \
    \                         - GtLt\n                                        - IsTrue\n\
    \                                        - IsFalse\n                         \
    \               type: string\n                                      value:\n \
    \                                       description: |-\n                    \
    \                      Value is the list of values that the operand evaluates\
    \ the input\n                                          against. Value should be\
    \ empty if the operator is Exists, DoesNotExist,\n                           \
    \               IsTrue or IsFalse. Value should contain exactly one element if\
    \ the\n                                          operator is Gt or Lt and exactly\
    \ two elements if the operator is GtLt.\n                                    \
    \      In other cases Value should contain at least one element.\n           \
    \                             items:\n                                       \
    \   type: string\n                                        type: array\n      \
    \                              required:\n                                   \
    \ - op\n                                    type: object\n                   \
    \               description: |-\n                                    MatchExpressions\
    \ is the set of per-element expressions evaluated. These\n                   \
    \                 match against the value of the specified elements.\n       \
    \                           type: object\n                                matchName:\n\
    \                                  description: |-\n                         \
    \           MatchName in an expression that is matched against the name of each\n\
    \                                    element in the feature set.\n           \
    \                       properties:\n                                    op:\n\
    \                                      description: Op is the operator to be applied.\n\
    \                                      enum:\n                               \
    \       - In\n                                      - NotIn\n                \
    \                      - InRegexp\n                                      - Exists\n\
    \                                      - DoesNotExist\n                      \
    \                - Gt\n                                      - Lt\n          \
    \                            - GtLt\n                                      - IsTrue\n\
    \                                      - IsFalse\n                           \
    \           type: string\n                                    value:\n       \
    \                               description: |-\n                            \
    \            Value is the list of values that the operand evaluates the input\n\
    \                                        against. Value should be empty if the\
    \ operator is Exists, DoesNotExist,\n                                        IsTrue\
    \ or IsFalse. Value should contain exactly one element if the\n              \
    \                          operator is Gt or Lt and exactly two elements if the\
    \ operator is GtLt.\n                                        In other cases Value\
    \ should contain at least one element.\n                                     \
    \ items:\n                                        type: string\n             \
    \                         type: array\n                                  required:\n\
    \                                  - op\n                                  type:\
    \ object\n                              required:\n                          \
    \    - feature\n                              type: object\n                 \
    \           type: array\n                        required:\n                 \
    \       - matchFeatures\n                        type: object\n              \
    \        type: array\n                    matchFeatures:\n                   \
    \   description: MatchFeatures specifies a set of matcher terms\n            \
    \            all of which must match.\n                      items:\n        \
    \                description: |-\n                          FeatureMatcherTerm\
    \ defines requirements against one feature set. All\n                        \
    \  requirements (specified as MatchExpressions) are evaluated against each\n \
    \                         element in the feature set.\n                      \
    \  properties:\n                          feature:\n                         \
    \   description: Feature is the name of the feature set to\n                 \
    \             match against.\n                            type: string\n     \
    \                     matchExpressions:\n                            additionalProperties:\n\
    \                              description: |-\n                             \
    \   MatchExpression specifies an expression to evaluate against a set of input\n\
    \                                values. It contains an operator that is applied\
    \ when matching the input and\n                                an array of values\
    \ that the operator evaluates the input against.\n                           \
    \   properties:\n                                op:\n                       \
    \           description: Op is the operator to be applied.\n                 \
    \                 enum:\n                                  - In\n            \
    \                      - NotIn\n                                  - InRegexp\n\
    \                                  - Exists\n                                \
    \  - DoesNotExist\n                                  - Gt\n                  \
    \                - Lt\n                                  - GtLt\n            \
    \                      - IsTrue\n                                  - IsFalse\n\
    \                                  type: string\n                            \
    \    value:\n                                  description: |-\n             \
    \                       Value is the list of values that the operand evaluates\
    \ the input\n                                    against. Value should be empty\
    \ if the operator is Exists, DoesNotExist,\n                                 \
    \   IsTrue or IsFalse. Value should contain exactly one element if the\n     \
    \                               operator is Gt or Lt and exactly two elements\
    \ if the operator is GtLt.\n                                    In other cases\
    \ Value should contain at least one element.\n                               \
    \   items:\n                                    type: string\n               \
    \                   type: array\n                              required:\n   \
    \                           - op\n                              type: object\n\
    \                            description: |-\n                              MatchExpressions\
    \ is the set of per-element expressions evaluated. These\n                   \
    \           match against the value of the specified elements.\n             \
    \               type: object\n                          matchName:\n         \
    \                   description: |-\n                              MatchName in\
    \ an expression that is matched against the name of each\n                   \
    \           element in the feature set.\n                            properties:\n\
    \                              op:\n                                description:\
    \ Op is the operator to be applied.\n                                enum:\n \
    \                               - In\n                                - NotIn\n\
    \                                - InRegexp\n                                -\
    \ Exists\n                                - DoesNotExist\n                   \
    \             - Gt\n                                - Lt\n                   \
    \             - GtLt\n                                - IsTrue\n             \
    \                   - IsFalse\n                                type: string\n\
    \                              value:\n                                description:\
    \ |-\n                                  Value is the list of values that the operand\
    \ evaluates the input\n                                  against. Value should\
    \ be empty if the operator is Exists, DoesNotExist,\n                        \
    \          IsTrue or IsFalse. Value should contain exactly one element if the\n\
    \                                  operator is Gt or Lt and exactly two elements\
    \ if the operator is GtLt.\n                                  In other cases Value\
    \ should contain at least one element.\n                                items:\n\
    \                                  type: string\n                            \
    \    type: array\n                            required:\n                    \
    \        - op\n                            type: object\n                    \
    \    required:\n                        - feature\n                        type:\
    \ object\n                      type: array\n                    name:\n     \
    \                 description: Name of the rule.\n                      type:\
    \ string\n                    taints:\n                      description: Taints\
    \ to create if the rule matches.\n                      items:\n             \
    \           description: |-\n                          The node this Taint is\
    \ attached to has the \"effect\" on\n                          any pod that does\
    \ not tolerate the Taint.\n                        properties:\n             \
    \             effect:\n                            description: |-\n         \
    \                     Required. The effect of the taint on pods\n            \
    \                  that do not tolerate the taint.\n                         \
    \     Valid effects are NoSchedule, PreferNoSchedule and NoExecute.\n        \
    \                    type: string\n                          key:\n          \
    \                  description: Required. The taint key to be applied to\n   \
    \                           a node.\n                            type: string\n\
    \                          timeAdded:\n                            description:\
    \ |-\n                              TimeAdded represents the time at which the\
    \ taint was added.\n                              It is only written for NoExecute\
    \ taints.\n                            format: date-time\n                   \
    \         type: string\n                          value:\n                   \
    \         description: The taint value corresponding to the taint\n          \
    \                    key.\n                            type: string\n        \
    \                required:\n                        - effect\n               \
    \         - key\n                        type: object\n                      type:\
    \ array\n                    vars:\n                      additionalProperties:\n\
    \                        type: string\n                      description: |-\n\
    \                        Vars is the variables to store if the rule matches. Variables\
    \ do not\n                        directly inflict any changes in the node object.\
    \ However, they can be\n                        referenced from other rules enabling\
    \ more complex rule hierarchies,\n                        without exposing intermediary\
    \ output values as labels.\n                      type: object\n             \
    \       varsTemplate:\n                      description: |-\n               \
    \         VarsTemplate specifies a template to expand for dynamically generating\n\
    \                        multiple variables. Data (after template expansion) must\
    \ be keys with an\n                        optional value (<key>[=<value>]) separated\
    \ by newlines.\n                      type: string\n                  required:\n\
    \                  - name\n                  type: object\n                type:\
    \ array\n            required:\n            - rules\n            type: object\n\
    \        required:\n        - spec\n        type: object\n    served: true\n \
    \   storage: true\n---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  labels:\n\
    \    app.kubernetes.io/instance: node-feature-discovery\n    app.kubernetes.io/managed-by:\
    \ Helm\n    app.kubernetes.io/name: node-feature-discovery\n    app.kubernetes.io/version:\
    \ v0.17.3\n    helm.sh/chart: node-feature-discovery-0.17.3\n  name: node-feature-discovery\n\
    \  namespace: node-feature-discovery\n---\napiVersion: v1\nkind: ServiceAccount\n\
    metadata:\n  labels:\n    app.kubernetes.io/instance: node-feature-discovery\n\
    \    app.kubernetes.io/managed-by: Helm\n    app.kubernetes.io/name: node-feature-discovery\n\
    \    app.kubernetes.io/version: v0.17.3\n    helm.sh/chart: node-feature-discovery-0.17.3\n\
    \  name: node-feature-discovery-gc\n  namespace: node-feature-discovery\n---\n\
    apiVersion: v1\nkind: ServiceAccount\nmetadata:\n  labels:\n    app.kubernetes.io/instance:\
    \ node-feature-discovery\n    app.kubernetes.io/managed-by: Helm\n    app.kubernetes.io/name:\
    \ node-feature-discovery\n    app.kubernetes.io/version: v0.17.3\n    helm.sh/chart:\
    \ node-feature-discovery-0.17.3\n  name: node-feature-discovery-worker\n  namespace:\
    \ node-feature-discovery\n---\napiVersion: v1\ndata:\n  nfd-master.conf: \"null\"\
    \nkind: ConfigMap\nmetadata:\n  labels:\n    app.kubernetes.io/instance: node-feature-discovery\n\
    \    app.kubernetes.io/managed-by: Helm\n    app.kubernetes.io/name: node-feature-discovery\n\
    \    app.kubernetes.io/version: v0.17.3\n    helm.sh/chart: node-feature-discovery-0.17.3\n\
    \  name: node-feature-discovery-master-conf\n  namespace: node-feature-discovery\n\
    ---\napiVersion: v1\ndata:\n  nfd-worker.conf: |-\n    sources:\n      pci:\n\
    \        deviceLabelFields:\n        - class\n        - vendor\nkind: ConfigMap\n\
    metadata:\n  labels:\n    app.kubernetes.io/instance: node-feature-discovery\n\
    \    app.kubernetes.io/managed-by: Helm\n    app.kubernetes.io/name: node-feature-discovery\n\
    \    app.kubernetes.io/version: v0.17.3\n    helm.sh/chart: node-feature-discovery-0.17.3\n\
    \  name: node-feature-discovery-worker-conf\n  namespace: node-feature-discovery\n\
    ---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n\
    \  labels:\n    app.kubernetes.io/instance: node-feature-discovery\n    app.kubernetes.io/managed-by:\
    \ Helm\n    app.kubernetes.io/name: node-feature-discovery\n    app.kubernetes.io/version:\
    \ v0.17.3\n    helm.sh/chart: node-feature-discovery-0.17.3\n  name: node-feature-discovery\n\
    rules:\n- apiGroups:\n  - \"\"\n  resources:\n  - namespaces\n  verbs:\n  - watch\n\
    \  - list\n- apiGroups:\n  - \"\"\n  resources:\n  - nodes\n  - nodes/status\n\
    \  verbs:\n  - get\n  - patch\n  - update\n  - list\n- apiGroups:\n  - nfd.k8s-sigs.io\n\
    \  resources:\n  - nodefeatures\n  - nodefeaturerules\n  - nodefeaturegroups\n\
    \  verbs:\n  - get\n  - list\n  - watch\n- apiGroups:\n  - nfd.k8s-sigs.io\n \
    \ resources:\n  - nodefeaturegroups/status\n  verbs:\n  - patch\n  - update\n\
    - apiGroups:\n  - coordination.k8s.io\n  resources:\n  - leases\n  verbs:\n  -\
    \ create\n- apiGroups:\n  - coordination.k8s.io\n  resourceNames:\n  - nfd-master.nfd.kubernetes.io\n\
    \  resources:\n  - leases\n  verbs:\n  - get\n  - update\n---\napiVersion: rbac.authorization.k8s.io/v1\n\
    kind: ClusterRole\nmetadata:\n  labels:\n    app.kubernetes.io/instance: node-feature-discovery\n\
    \    app.kubernetes.io/managed-by: Helm\n    app.kubernetes.io/name: node-feature-discovery\n\
    \    app.kubernetes.io/version: v0.17.3\n    helm.sh/chart: node-feature-discovery-0.17.3\n\
    \  name: node-feature-discovery-gc\nrules:\n- apiGroups:\n  - \"\"\n  resources:\n\
    \  - nodes\n  verbs:\n  - list\n  - watch\n- apiGroups:\n  - \"\"\n  resources:\n\
    \  - nodes/proxy\n  verbs:\n  - get\n- apiGroups:\n  - topology.node.k8s.io\n\
    \  resources:\n  - noderesourcetopologies\n  verbs:\n  - delete\n  - list\n- apiGroups:\n\
    \  - nfd.k8s-sigs.io\n  resources:\n  - nodefeatures\n  verbs:\n  - delete\n \
    \ - list\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\n\
    metadata:\n  labels:\n    app.kubernetes.io/instance: node-feature-discovery\n\
    \    app.kubernetes.io/managed-by: Helm\n    app.kubernetes.io/name: node-feature-discovery\n\
    \    app.kubernetes.io/version: v0.17.3\n    helm.sh/chart: node-feature-discovery-0.17.3\n\
    \  name: node-feature-discovery\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n\
    \  kind: ClusterRole\n  name: node-feature-discovery\nsubjects:\n- kind: ServiceAccount\n\
    \  name: node-feature-discovery\n  namespace: node-feature-discovery\n---\napiVersion:\
    \ rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  labels:\n\
    \    app.kubernetes.io/instance: node-feature-discovery\n    app.kubernetes.io/managed-by:\
    \ Helm\n    app.kubernetes.io/name: node-feature-discovery\n    app.kubernetes.io/version:\
    \ v0.17.3\n    helm.sh/chart: node-feature-discovery-0.17.3\n  name: node-feature-discovery-gc\n\
    roleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name:\
    \ node-feature-discovery-gc\nsubjects:\n- kind: ServiceAccount\n  name: node-feature-discovery-gc\n\
    \  namespace: node-feature-discovery\n---\napiVersion: rbac.authorization.k8s.io/v1\n\
    kind: Role\nmetadata:\n  labels:\n    app.kubernetes.io/instance: node-feature-discovery\n\
    \    app.kubernetes.io/managed-by: Helm\n    app.kubernetes.io/name: node-feature-discovery\n\
    \    app.kubernetes.io/version: v0.17.3\n    helm.sh/chart: node-feature-discovery-0.17.3\n\
    \  name: node-feature-discovery-worker\n  namespace: node-feature-discovery\n\
    rules:\n- apiGroups:\n  - nfd.k8s-sigs.io\n  resources:\n  - nodefeatures\n  verbs:\n\
    \  - create\n  - get\n  - update\n  - delete\n- apiGroups:\n  - \"\"\n  resources:\n\
    \  - pods\n  verbs:\n  - get\n---\napiVersion: rbac.authorization.k8s.io/v1\n\
    kind: RoleBinding\nmetadata:\n  labels:\n    app.kubernetes.io/instance: node-feature-discovery\n\
    \    app.kubernetes.io/managed-by: Helm\n    app.kubernetes.io/name: node-feature-discovery\n\
    \    app.kubernetes.io/version: v0.17.3\n    helm.sh/chart: node-feature-discovery-0.17.3\n\
    \  name: node-feature-discovery-worker\n  namespace: node-feature-discovery\n\
    roleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: Role\n  name: node-feature-discovery-worker\n\
    subjects:\n- kind: ServiceAccount\n  name: node-feature-discovery-worker\n  namespace:\
    \ node-feature-discovery\n---\napiVersion: apps/v1\nkind: DaemonSet\nmetadata:\n\
    \  labels:\n    app.kubernetes.io/instance: node-feature-discovery\n    app.kubernetes.io/managed-by:\
    \ Helm\n    app.kubernetes.io/name: node-feature-discovery\n    app.kubernetes.io/version:\
    \ v0.17.3\n    helm.sh/chart: node-feature-discovery-0.17.3\n    role: worker\n\
    \  name: node-feature-discovery-worker\n  namespace: node-feature-discovery\n\
    spec:\n  revisionHistoryLimit: null\n  selector:\n    matchLabels:\n      app.kubernetes.io/instance:\
    \ node-feature-discovery\n      app.kubernetes.io/name: node-feature-discovery\n\
    \      role: worker\n  template:\n    metadata:\n      annotations:\n        checksum/config:\
    \ 0bbc91fc0f9c730e974c649d0acae6130cdaea8fdc9871a6db54a6a0b778b3c3\n      labels:\n\
    \        app.kubernetes.io/instance: node-feature-discovery\n        app.kubernetes.io/name:\
    \ node-feature-discovery\n        role: worker\n    spec:\n      containers:\n\
    \      - args:\n        - -feature-gates=NodeFeatureGroupAPI=false\n        -\
    \ -metrics=8081\n        - -grpc-health=8082\n        command:\n        - nfd-worker\n\
    \        env:\n        - name: NODE_NAME\n          valueFrom:\n            fieldRef:\n\
    \              fieldPath: spec.nodeName\n        - name: POD_NAME\n          valueFrom:\n\
    \            fieldRef:\n              fieldPath: metadata.name\n        - name:\
    \ POD_UID\n          valueFrom:\n            fieldRef:\n              fieldPath:\
    \ metadata.uid\n        image: registry.k8s.io/nfd/node-feature-discovery:v0.17.3\n\
    \        imagePullPolicy: IfNotPresent\n        livenessProbe:\n          grpc:\n\
    \            port: 8082\n          initialDelaySeconds: 10\n        name: worker\n\
    \        ports:\n        - containerPort: 8081\n          name: metrics\n    \
    \    - containerPort: 8082\n          name: health\n        readinessProbe:\n\
    \          failureThreshold: 10\n          grpc:\n            port: 8082\n   \
    \       initialDelaySeconds: 5\n        resources:\n          limits:\n      \
    \      memory: 512Mi\n          requests:\n            cpu: 5m\n            memory:\
    \ 64Mi\n        securityContext:\n          allowPrivilegeEscalation: false\n\
    \          capabilities:\n            drop:\n            - ALL\n          readOnlyRootFilesystem:\
    \ true\n          runAsNonRoot: true\n        volumeMounts:\n        - mountPath:\
    \ /host-boot\n          name: host-boot\n          readOnly: true\n        - mountPath:\
    \ /host-etc/os-release\n          name: host-os-release\n          readOnly: true\n\
    \        - mountPath: /host-sys\n          name: host-sys\n          readOnly:\
    \ true\n        - mountPath: /host-usr/lib\n          name: host-usr-lib\n   \
    \       readOnly: true\n        - mountPath: /host-lib\n          name: host-lib\n\
    \          readOnly: true\n        - mountPath: /host-proc/swaps\n          name:\
    \ host-proc-swaps\n          readOnly: true\n        - mountPath: /etc/kubernetes/node-feature-discovery/features.d/\n\
    \          name: features-d\n          readOnly: true\n        - mountPath: /etc/kubernetes/node-feature-discovery\n\
    \          name: nfd-worker-conf\n          readOnly: true\n      dnsPolicy: ClusterFirstWithHostNet\n\
    \      hostNetwork: false\n      securityContext: {}\n      serviceAccountName:\
    \ node-feature-discovery-worker\n      tolerations:\n      - effect: NoSchedule\n\
    \        operator: Exists\n      volumes:\n      - hostPath:\n          path:\
    \ /boot\n        name: host-boot\n      - hostPath:\n          path: /etc/os-release\n\
    \        name: host-os-release\n      - hostPath:\n          path: /sys\n    \
    \    name: host-sys\n      - hostPath:\n          path: /usr/lib\n        name:\
    \ host-usr-lib\n      - hostPath:\n          path: /lib\n        name: host-lib\n\
    \      - hostPath:\n          path: /proc/swaps\n        name: host-proc-swaps\n\
    \      - hostPath:\n          path: /etc/kubernetes/node-feature-discovery/features.d/\n\
    \        name: features-d\n      - configMap:\n          items:\n          - key:\
    \ nfd-worker.conf\n            path: nfd-worker.conf\n          name: node-feature-discovery-worker-conf\n\
    \        name: nfd-worker-conf\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n\
    \  labels:\n    app.kubernetes.io/instance: node-feature-discovery\n    app.kubernetes.io/managed-by:\
    \ Helm\n    app.kubernetes.io/name: node-feature-discovery\n    app.kubernetes.io/version:\
    \ v0.17.3\n    helm.sh/chart: node-feature-discovery-0.17.3\n    role: master\n\
    \  name: node-feature-discovery-master\n  namespace: node-feature-discovery\n\
    spec:\n  replicas: 1\n  revisionHistoryLimit: null\n  selector:\n    matchLabels:\n\
    \      app.kubernetes.io/instance: node-feature-discovery\n      app.kubernetes.io/name:\
    \ node-feature-discovery\n      role: master\n  template:\n    metadata:\n   \
    \   annotations:\n        checksum/config: 8498990861054deb5ed87fd3936a6063af4d6ba2536a05bfb34b5228593e57fc\n\
    \      labels:\n        app.kubernetes.io/instance: node-feature-discovery\n \
    \       app.kubernetes.io/name: node-feature-discovery\n        role: master\n\
    \    spec:\n      affinity:\n        nodeAffinity:\n          preferredDuringSchedulingIgnoredDuringExecution:\n\
    \          - preference:\n              matchExpressions:\n              - key:\
    \ node-role.kubernetes.io/control-plane\n                operator: In\n      \
    \          values:\n                - \"\"\n            weight: 1\n      containers:\n\
    \      - args:\n        - -enable-leader-election\n        - -extra-label-ns=nvidia.com,beta.amd.com,amd.com\n\
    \        - -feature-gates=NodeFeatureGroupAPI=false\n        - -metrics=8081\n\
    \        - -grpc-health=8082\n        command:\n        - nfd-master\n       \
    \ env:\n        - name: NODE_NAME\n          valueFrom:\n            fieldRef:\n\
    \              fieldPath: spec.nodeName\n        image: registry.k8s.io/nfd/node-feature-discovery:v0.17.3\n\
    \        imagePullPolicy: IfNotPresent\n        livenessProbe:\n          grpc:\n\
    \            port: 8082\n        name: master\n        ports:\n        - containerPort:\
    \ 8081\n          name: metrics\n        - containerPort: 8082\n          name:\
    \ health\n        readinessProbe:\n          failureThreshold: 10\n          grpc:\n\
    \            port: 8082\n        resources:\n          limits:\n            memory:\
    \ 4Gi\n          requests:\n            cpu: 100m\n            memory: 128Mi\n\
    \        securityContext:\n          allowPrivilegeEscalation: false\n       \
    \   capabilities:\n            drop:\n            - ALL\n          readOnlyRootFilesystem:\
    \ true\n          runAsNonRoot: true\n        startupProbe:\n          failureThreshold:\
    \ 30\n          grpc:\n            port: 8082\n        volumeMounts:\n       \
    \ - mountPath: /etc/kubernetes/node-feature-discovery\n          name: nfd-master-conf\n\
    \          readOnly: true\n      enableServiceLinks: false\n      hostNetwork:\
    \ false\n      securityContext: {}\n      serviceAccountName: node-feature-discovery\n\
    \      tolerations:\n      - effect: NoSchedule\n        key: node-role.kubernetes.io/control-plane\n\
    \        operator: Equal\n        value: \"\"\n      volumes:\n      - configMap:\n\
    \          items:\n          - key: nfd-master.conf\n            path: nfd-master.conf\n\
    \          name: node-feature-discovery-master-conf\n        name: nfd-master-conf\n\
    ---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  labels:\n    app.kubernetes.io/instance:\
    \ node-feature-discovery\n    app.kubernetes.io/managed-by: Helm\n    app.kubernetes.io/name:\
    \ node-feature-discovery\n    app.kubernetes.io/version: v0.17.3\n    helm.sh/chart:\
    \ node-feature-discovery-0.17.3\n    role: gc\n  name: node-feature-discovery-gc\n\
    \  namespace: node-feature-discovery\nspec:\n  replicas: 1\n  revisionHistoryLimit:\
    \ null\n  selector:\n    matchLabels:\n      app.kubernetes.io/instance: node-feature-discovery\n\
    \      app.kubernetes.io/name: node-feature-discovery\n      role: gc\n  template:\n\
    \    metadata:\n      labels:\n        app.kubernetes.io/instance: node-feature-discovery\n\
    \        app.kubernetes.io/name: node-feature-discovery\n        role: gc\n  \
    \  spec:\n      containers:\n      - args:\n        - -gc-interval=1h\n      \
    \  command:\n        - nfd-gc\n        env:\n        - name: NODE_NAME\n     \
    \     valueFrom:\n            fieldRef:\n              fieldPath: spec.nodeName\n\
    \        image: registry.k8s.io/nfd/node-feature-discovery:v0.17.3\n        imagePullPolicy:\
    \ IfNotPresent\n        name: gc\n        ports:\n        - containerPort: 8081\n\
    \          name: metrics\n        resources:\n          limits:\n            memory:\
    \ 1Gi\n          requests:\n            cpu: 10m\n            memory: 128Mi\n\
    \        securityContext:\n          allowPrivilegeEscalation: false\n       \
    \   capabilities:\n            drop:\n            - ALL\n          readOnlyRootFilesystem:\
    \ true\n          runAsNonRoot: true\n      dnsPolicy: ClusterFirstWithHostNet\n\
    \      hostNetwork: false\n      securityContext: {}\n      serviceAccountName:\
    \ node-feature-discovery-gc\n      tolerations:\n      - effect: NoSchedule\n\
    \        key: node-role.kubernetes.io/control-plane\n"
kind: ConfigMap
metadata:
  creationTimestamp: null
  labels:
    cluster.x-k8s.io/provider: runtime-extension-caren
    clusterctl.cluster.x-k8s.io: ''
  name: node-feature-discovery
  namespace: cluster-api
---
apiVersion: v1
data:
  values.yaml: "initContainers:\n  # The regsync container does not fail when it cannot\
    \ connect to the destination registry.\n  # In the case when it runs as a Job,\
    \ it will prematurely exit.\n  # This init container will wait for the destination\
    \ registry to be ready.\n  - name: wait-for-registry\n    image: ghcr.io/d2iq-labs/kubectl-betterwait:{{\
    \ .KubernetesVersion }}\n    args:\n      - --for=condition=Ready\n      - --timeout=-1s\
    \ # a negative number here means wait forever\n      - --interval=5s # poll every\
    \ 5 seconds to the resources to be created\n      - --namespace={{ .DestinationRegistryHeadlessServiceNamespace\
    \ }}\n      - --kubeconfig=/kubeconfig/admin.conf\n      # Ideally we would wait\
    \ for the Service to be ready, but Kubernetes does not have a condition for that.\n\
    \      - pod/{{ .DestinationRegistryAnyPodName }}\n    volumeMounts:\n      -\
    \ mountPath: /kubeconfig\n        name: kubeconfig\n        readOnly: true\n \
    \ - name: port-forward-registry\n    image: ghcr.io/d2iq-labs/kubectl-betterwait:{{\
    \ .KubernetesVersion }}\n    command:\n      - /bin/kubectl\n    args:\n     \
    \ - port-forward\n      - --address=127.0.0.1\n      - --namespace={{ .DestinationRegistryHeadlessServiceNamespace\
    \ }}\n      - --kubeconfig=/kubeconfig/admin.conf\n      # This will port-forward\
    \ to a single Pod in the Service.\n      - service/{{ .DestinationRegistryHeadlessServiceName\
    \ }}\n      - 5000:{{ .DestinationRegistryHeadlessServicePort }}\n    resources:\n\
    \      requests:\n        cpu: 25m\n        memory: 32Mi\n      limits:\n    \
    \    cpu: 100m\n        memory: 50Mi\n    volumeMounts:\n      - mountPath: /kubeconfig\n\
    \        name: kubeconfig\n        readOnly: true\n    # Kubernetes will treat\
    \ this as a Sidecar container\n    # https://kubernetes.io/docs/concepts/workloads/pods/sidecar-containers/\n\
    \    restartPolicy: Always\n\nextraVolumes:\n  - name: kubeconfig\n    secret:\n\
    \      items:\n        - key: value\n          path: admin.conf\n      secretName:\
    \ {{ .CusterName }}-kubeconfig\n  - name: ca-cert\n    secret:\n      secretName:\
    \ {{ .RegistryCASecretName }}\n\nextraVolumeMounts:\n  # Assume both the source\
    \ and the target registries have the same CA.\n  # Source registry running in\
    \ the cluster.\n  - mountPath: /etc/docker/certs.d/{{ .SourceRegistryAddress }}/\n\
    \    name: ca-cert\n    readOnly: true\n  # Destination registry running in the\
    \ remote cluster being port-forwarded.\n  - mountPath: /etc/docker/certs.d/127.0.0.1:5000/\n\
    \    name: ca-cert\n    readOnly: true\n\ndeployment:\n  config:\n    creds:\n\
    \      - registry: {{ .SourceRegistryAddress }}\n        reqPerSec: 1\n    sync:\n\
    \      - source: {{ .SourceRegistryAddress }}\n        target: 127.0.0.1:5000\n\
    \        type: registry\n        interval: 1m\n\njob:\n  enabled: true\n  config:\n\
    \    sync:\n      - source: {{ .SourceRegistryAddress }}\n        target: 127.0.0.1:5000\n\
    \        type: registry\n        interval: 1m"
kind: ConfigMap
metadata:
  labels:
    cluster.x-k8s.io/provider: runtime-extension-caren
    clusterctl.cluster.x-k8s.io: ''
  name: default-registry-syncer-helm-values-template
  namespace: cluster-api
---
apiVersion: v1
data:
  values.yaml: "replicaCount: {{ .Replicas }}\npersistence:\n  enabled: true\n  size:\
    \ 50Gi\nservice:\n  type: ClusterIP\n  clusterIP: {{ .ServiceIP }}\n  port: 443\n\
    resources:\n  requests:\n    cpu: 100m\n    memory: 256Mi\n  limits:\n    cpu:\
    \ 250m\n    memory: 384Mi\nstatefulSet:\n  enabled: true\n  syncer:\n    interval:\
    \ 2m\n    resources:\n      requests:\n        cpu: 25m\n        memory: 50Mi\n\
    \      limits:\n        cpu: 100m\n        memory: 75Mi\ntlsSecretName: {{ .TLSSecretName\
    \ }}\ntolerations:\n  - key: \"node-role.kubernetes.io/control-plane\"\n    operator:\
    \ Exists\n    effect: \"NoSchedule\"\n\npodLabels:\n  cncf-distribution-registry:\
    \ \"true\" # ensure the labels match with pod AntiAffinity.\n\naffinity:\n  nodeAffinity:\n\
    \    requiredDuringSchedulingIgnoredDuringExecution:\n      nodeSelectorTerms:\n\
    \        - matchExpressions:\n            - key: node-role.kubernetes.io/control-plane\n\
    \              operator: Exists\n  podAntiAffinity:\n    preferredDuringSchedulingIgnoredDuringExecution:\n\
    \      - weight: 100\n        podAffinityTerm:\n          labelSelector:\n   \
    \         matchLabels:\n              cncf-distribution-registry: \"true\"\n \
    \         topologyKey: kubernetes.io/hostname"
kind: ConfigMap
metadata:
  labels:
    cluster.x-k8s.io/provider: runtime-extension-caren
    clusterctl.cluster.x-k8s.io: ''
  name: default-cncf-distribution-registry-helm-values-template
  namespace: cluster-api
---
apiVersion: v1
data:
  values.yaml: "controller:\n  priorityClassName: system-cluster-critical\n  tolerations:\n\
    \    - key: node-role.kubernetes.io/control-plane\n      effect: NoSchedule\n\
    \      operator: Exists\n    - key: CriticalAddonsOnly\n      operator: Exists\n\
    \    - effect: NoExecute\n      operator: Exists\n      tolerationSeconds: 300\n\
    speaker:\n  frr:\n    image:\n      tag: 9.1.3\n  priorityClassName: system-cluster-critical\n\
    \  tolerations:\n    - effect: NoSchedule\n      operator: Exists\n    - key:\
    \ CriticalAddonsOnly\n      operator: Exists\n    - effect: NoExecute\n      operator:\
    \ Exists\n      tolerationSeconds: 300"
kind: ConfigMap
metadata:
  labels:
    cluster.x-k8s.io/provider: runtime-extension-caren
    clusterctl.cluster.x-k8s.io: ''
  name: default-metallb-helm-values-template
  namespace: cluster-api
---
apiVersion: v1
data:
  kube-vip.yaml: "apiVersion: v1\nkind: Pod\nmetadata:\n  name: kube-vip\n  namespace:\
    \ kube-system\nspec:\n  containers:\n    - args:\n        - manager\n      env:\n\
    \        - name: vip_arp\n          value: \"true\"\n        - name: port\n  \
    \        value: '{{ .Port }}'\n        - name: vip_nodename\n          valueFrom:\n\
    \            fieldRef:\n              fieldPath: spec.nodeName\n        - name:\
    \ vip_cidr\n          value: \"32\"\n        - name: dns_mode\n          value:\
    \ first\n        - name: cp_enable\n          value: \"true\"\n        - name:\
    \ cp_namespace\n          value: kube-system\n        - name: vip_leaderelection\n\
    \          value: \"true\"\n        - name: vip_leasename\n          value: plndr-cp-lock\n\
    \        - name: vip_leaseduration\n          value: \"15\"\n        - name: vip_renewdeadline\n\
    \          value: \"10\"\n        - name: vip_retryperiod\n          value: \"\
    2\"\n        - name: address\n          value: '{{ .Address }}'\n        - name:\
    \ prometheus_server\n      image: ghcr.io/kube-vip/kube-vip:v0.8.9\n      imagePullPolicy:\
    \ IfNotPresent\n      name: kube-vip\n      resources: {}\n      securityContext:\n\
    \        capabilities:\n          add:\n            - NET_ADMIN\n            -\
    \ NET_RAW\n      volumeMounts:\n        - mountPath: /etc/kubernetes/admin.conf\n\
    \          name: kubeconfig\n  hostAliases:\n    - hostnames:\n        - kubernetes\n\
    \      ip: 127.0.0.1\n  hostNetwork: true\n  volumes:\n    - hostPath:\n     \
    \   path: /etc/kubernetes/admin.conf\n      name: kubeconfig\n"
kind: ConfigMap
metadata:
  creationTimestamp: null
  labels:
    cluster.x-k8s.io/provider: runtime-extension-caren
    clusterctl.cluster.x-k8s.io: ''
  name: default-kube-vip-template
  namespace: cluster-api
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  finalizers:
    - kubernetes.io/pvc-protection
  labels:
    cluster.x-k8s.io/provider: runtime-extension-caren
    clusterctl.cluster.x-k8s.io: ''
  name: helm-charts-pvc
  namespace: cluster-api
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 2Gi
  volumeMode: Filesystem
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  labels:
    cluster.x-k8s.io/provider: runtime-extension-caren
    clusterctl.cluster.x-k8s.io: ''
  name: cluster-api-runtime-extensions-nutanix-manager-role
rules:
  - apiGroups:
      - ''
    resources:
      - configmaps
    verbs:
      - create
      - delete
      - get
      - list
      - patch
      - update
      - watch
  - apiGroups:
      - ''
    resources:
      - namespaces
      - nodes
    verbs:
      - get
      - list
      - watch
  - apiGroups:
      - ''
    resources:
      - secrets
    verbs:
      - create
      - get
      - list
      - patch
      - update
      - watch
  - apiGroups:
      - addons.cluster.x-k8s.io
    resources:
      - clusterresourcesets
      - helmchartproxies
    verbs:
      - create
      - delete
      - get
      - list
      - patch
      - update
      - watch
  - apiGroups:
      - bootstrap.cluster.x-k8s.io
      - controlplane.cluster.x-k8s.io
      - infrastructure.cluster.x-k8s.io
    resources:
      - '*'
    verbs:
      - create
      - get
      - list
      - watch
  - apiGroups:
      - cluster.x-k8s.io
    resources:
      - clusterclasses
    verbs:
      - create
      - get
      - list
      - watch
  - apiGroups:
      - cluster.x-k8s.io
    resources:
      - clusters
      - machines
    verbs:
      - get
      - list
      - watch
  - apiGroups:
      - cluster.x-k8s.io
    resources:
      - clusters/status
    verbs:
      - get
  - apiGroups:
      - cluster.x-k8s.io
    resources:
      - machinedeployments
    verbs:
      - get
      - list
      - patch
      - update
      - watch
  - apiGroups:
      - controlplane.cluster.x-k8s.io
    resources:
      - kubeadmcontrolplanes
    verbs:
      - get
      - list
      - patch
      - update
      - watch
  - apiGroups:
      - storage.k8s.io
    resources:
      - storageclasses
    verbs:
      - create
      - get
      - list
      - patch
      - update
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  creationTimestamp: null
  labels:
    app.kubernetes.io/instance: cluster-api-runtime-extensions-nutanix
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: cluster-api-runtime-extensions-nutanix
    app.kubernetes.io/version: v0.33.1
    cluster.x-k8s.io/provider: runtime-extension-caren
    clusterctl.cluster.x-k8s.io: ''
    helm.sh/chart: cluster-api-runtime-extensions-nutanix-v0.33.1
  name: cluster-api-runtime-extensions-nutanix
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cluster-api-runtime-extensions-nutanix-manager-role
subjects:
  - kind: ServiceAccount
    name: cluster-api-runtime-extensions-nutanix
    namespace: cluster-api
---
apiVersion: v1
kind: Service
metadata:
  annotations: null
  labels:
    app.kubernetes.io/instance: cluster-api-runtime-extensions-nutanix
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: cluster-api-runtime-extensions-nutanix
    app.kubernetes.io/version: v0.33.1
    cluster.x-k8s.io/provider: runtime-extension-caren
    clusterctl.cluster.x-k8s.io: ''
    helm.sh/chart: cluster-api-runtime-extensions-nutanix-v0.33.1
  name: cluster-api-runtime-extensions-nutanix-admission
  namespace: cluster-api
spec:
  ports:
    - name: https
      port: 443
      protocol: TCP
      targetPort: admission
  selector:
    app.kubernetes.io/instance: cluster-api-runtime-extensions-nutanix
    app.kubernetes.io/name: cluster-api-runtime-extensions-nutanix
  type: ClusterIP
---
apiVersion: v1
kind: Service
metadata:
  labels:
    cluster.x-k8s.io/provider: runtime-extension-caren
    clusterctl.cluster.x-k8s.io: ''
  name: helm-repository
  namespace: cluster-api
spec:
  ports:
    - port: 443
      targetPort: 5000
  selector:
    app: helm-repository
  type: ClusterIP
---
apiVersion: v1
kind: Service
metadata:
  annotations: null
  labels:
    app.kubernetes.io/instance: cluster-api-runtime-extensions-nutanix
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: cluster-api-runtime-extensions-nutanix
    app.kubernetes.io/version: v0.33.1
    cluster.x-k8s.io/provider: runtime-extension-caren
    clusterctl.cluster.x-k8s.io: ''
    helm.sh/chart: cluster-api-runtime-extensions-nutanix-v0.33.1
  name: cluster-api-runtime-extensions-nutanix-runtimehooks
  namespace: cluster-api
spec:
  ports:
    - name: https
      port: 443
      protocol: TCP
      targetPort: runtimehooks
  selector:
    app.kubernetes.io/instance: cluster-api-runtime-extensions-nutanix
    app.kubernetes.io/name: cluster-api-runtime-extensions-nutanix
  type: ClusterIP
---
apiVersion: apps/v1
kind: Deployment
metadata:
  creationTimestamp: null
  labels:
    app.kubernetes.io/instance: cluster-api-runtime-extensions-nutanix
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: cluster-api-runtime-extensions-nutanix
    app.kubernetes.io/version: v0.33.1
    cluster.x-k8s.io/provider: runtime-extension-caren
    clusterctl.cluster.x-k8s.io: ''
    helm.sh/chart: cluster-api-runtime-extensions-nutanix-v0.33.1
  name: cluster-api-runtime-extensions-nutanix
  namespace: cluster-api
spec:
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/instance: cluster-api-runtime-extensions-nutanix
      app.kubernetes.io/name: cluster-api-runtime-extensions-nutanix
  strategy: {}
  template:
    metadata:
      creationTimestamp: null
      labels:
        app.kubernetes.io/instance: cluster-api-runtime-extensions-nutanix
        app.kubernetes.io/name: cluster-api-runtime-extensions-nutanix
    spec:
      containers:
        - args:
            - --webhook-cert-dir=/runtimehooks-certs/
            - --defaults-namespace=$(POD_NAMESPACE)
            - --namespacesync-enabled=true
            - --namespacesync-source-namespace=caren-system
            - --namespacesync-target-namespace-label-key=caren.nutanix.com/namespace-sync
            - --enforce-clusterautoscaler-limits-enabled=true
            - --failure-domain-rollout-enabled=true
            - --failure-domain-rollout-concurrency=10
            - --helm-addons-configmap=default-helm-addons-config
            - --cni.cilium.helm-addon.default-values-template-configmap-name=default-cilium-cni-helm-values-template
            - --nfd.helm-addon.default-values-template-configmap-name=default-nfd-helm-values-template
            - --csi.aws-ebs.helm-addon.default-values-template-configmap-name=default-aws-ebs-csi-helm-values-template
            - --csi.nutanix.helm-addon.default-values-template-configmap-name=default-nutanix-csi-helm-values-template
            - --csi.local-path.helm-addon.default-values-template-configmap-name=default-local-path-provisioner-csi-helm-values-template
            - --csi.snapshot-controller.helm-addon.default-values-template-configmap-name=default-snapshot-controller-helm-values-template
            - --ccm.aws.helm-addon.default-values-template-configmap-name=default-aws-ccm-helm-values-template
            - --cosi.controller.helm-addon.default-values-template-configmap-name=default-cosi-controller-helm-values-template
            - --ccm.aws.aws-ccm-versions=1.30=v1.30.8
            - --ccm.aws.aws-ccm-versions=1.31=v1.31.5
            - --ccm.aws.aws-ccm-versions=1.32=v1.32.1
            - --ccm.aws.aws-ccm-versions=1.33=v1.33.0
            - --admission-webhook-cert-dir=/admission-certs/
          env:
            - name: POD_NAMESPACE
              valueFrom:
                fieldRef:
                  fieldPath: metadata.namespace
          image: ghcr.io/nutanix-cloud-native/cluster-api-runtime-extensions-nutanix:v0.33.1
          imagePullPolicy: IfNotPresent
          livenessProbe:
            httpGet:
              path: /healthz
              port: probes
              scheme: HTTP
          name: manager
          ports:
            - containerPort: 9443
              name: runtimehooks
              protocol: TCP
            - containerPort: 9444
              name: admission
              protocol: TCP
            - containerPort: 8080
              name: metrics
              protocol: TCP
            - containerPort: 8081
              name: probes
              protocol: TCP
          readinessProbe:
            httpGet:
              path: /readyz
              port: probes
              scheme: HTTP
            periodSeconds: 1
          resources:
            limits:
              cpu: 100m
              memory: 256Mi
            requests:
              cpu: 100m
              memory: 128Mi
          volumeMounts:
            - mountPath: /runtimehooks-certs
              name: runtimehooks-cert
              readOnly: true
            - mountPath: /admission-certs
              name: admission-cert
              readOnly: true
      priorityClassName: system-cluster-critical
      securityContext:
        runAsUser: 65532
      serviceAccountName: cluster-api-runtime-extensions-nutanix
      terminationGracePeriodSeconds: 10
      tolerations:
        - effect: NoSchedule
          key: node-role.kubernetes.io/control-plane
          operator: Equal
      volumes:
        - name: runtimehooks-cert
          secret:
            defaultMode: 420
            secretName: cluster-api-runtime-extensions-nutanix-runtimehooks-tls
        - name: admission-cert
          secret:
            defaultMode: 420
            secretName: cluster-api-runtime-extensions-nutanix-admission-tls
status: {}
---
apiVersion: apps/v1
kind: Deployment
metadata:
  creationTimestamp: null
  labels:
    app: helm-repository
    cluster.x-k8s.io/provider: runtime-extension-caren
    clusterctl.cluster.x-k8s.io: ''
  name: helm-repository
  namespace: cluster-api
spec:
  replicas: 1
  selector:
    matchLabels:
      app: helm-repository
  strategy:
    type: Recreate
  template:
    metadata:
      creationTimestamp: null
      labels:
        app: helm-repository
    spec:
      containers:
        - args:
            - serve
            - bundle
            - --bundle=/helm-charts/bundles/helm-charts-*.tar
            - --listen-port=5000
            - --listen-address=0.0.0.0
            - --tls-private-key-file=/certs/tls.key
            - --tls-cert-file=/certs/tls.crt
          image: ghcr.io/mesosphere/mindthegap:v1.22.1
          imagePullPolicy: IfNotPresent
          livenessProbe:
            tcpSocket:
              port: serve
          name: manager
          ports:
            - containerPort: 5000
              name: serve
              protocol: TCP
          readinessProbe:
            periodSeconds: 1
            tcpSocket:
              port: serve
          resources: {}
          volumeMounts:
            - mountPath: /certs
              name: certs-vol
              readOnly: true
            - mountPath: /helm-charts
              name: charts-volume
              readOnly: true
      initContainers:
        - command:
            - /bin/cp
            - --recursive
            - --no-target-directory
            - --verbose
            - /charts/
            - /helm-charts/bundles/
          image: ghcr.io/nutanix-cloud-native/cluster-api-runtime-extensions-helm-chart-bundle-initializer:v0.33.1
          imagePullPolicy: IfNotPresent
          name: copy-charts
          resources: {}
          volumeMounts:
            - mountPath: /helm-charts
              name: charts-volume
      priorityClassName: system-cluster-critical
      securityContext:
        fsGroup: 65532
        runAsGroup: 65532
        runAsUser: 65532
      volumes:
        - name: certs-vol
          secret:
            secretName: helm-repository-tls
        - name: charts-volume
          persistentVolumeClaim:
            claimName: helm-charts-pvc
status: {}
---
apiVersion: runtime.cluster.x-k8s.io/v1alpha1
kind: ExtensionConfig
metadata:
  annotations:
    caren.nutanix.com/version: v0.33.1
    runtime.cluster.x-k8s.io/inject-ca-from-secret: caren-system/cluster-api-runtime-extensions-nutanix-runtimehooks-tls
  labels:
    cluster.x-k8s.io/provider: runtime-extension-caren
    clusterctl.cluster.x-k8s.io: ''
  name: cluster-api-runtime-extensions-nutanix
  namespace: cluster-api
spec:
  clientConfig:
    service:
      name: cluster-api-runtime-extensions-nutanix-runtimehooks
      namespace: caren-system
      port: 443
---
apiVersion: admissionregistration.k8s.io/v1
kind: MutatingWebhookConfiguration
metadata:
  annotations:
    cert-manager.io/inject-ca-from: cluster-api/cluster-api-runtime-extensions-nutanix-admission-tls
  creationTimestamp: null
  labels:
    cluster.x-k8s.io/provider: runtime-extension-caren
    clusterctl.cluster.x-k8s.io: ''
  name: cluster-api-runtime-extensions-nutanix-mutating-webhook-configuration
webhooks:
  - admissionReviewVersions:
      - v1
    clientConfig:
      service:
        name: cluster-api-runtime-extensions-nutanix-admission
        namespace: cluster-api
        path: /mutate-v1beta1-addons
    failurePolicy: Fail
    name: addons-defaulter.caren.nutanix.com
    rules:
      - apiGroups:
          - cluster.x-k8s.io
        apiVersions:
          - '*'
        operations:
          - CREATE
        resources:
          - clusters
    sideEffects: None
  - admissionReviewVersions:
      - v1
    clientConfig:
      service:
        name: cluster-api-runtime-extensions-nutanix-admission
        namespace: cluster-api
        path: /mutate-v1beta1-cluster
    failurePolicy: Fail
    name: cluster-defaulter.caren.nutanix.com
    rules:
      - apiGroups:
          - cluster.x-k8s.io
        apiVersions:
          - '*'
        operations:
          - CREATE
          - UPDATE
        resources:
          - clusters
    sideEffects: None
---
apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingWebhookConfiguration
metadata:
  annotations:
    cert-manager.io/inject-ca-from: cluster-api/cluster-api-runtime-extensions-nutanix-admission-tls
  creationTimestamp: null
  labels:
    cluster.x-k8s.io/provider: runtime-extension-caren
    clusterctl.cluster.x-k8s.io: ''
  name: cluster-api-runtime-extensions-nutanix-validating-webhook-configuration
webhooks:
  - admissionReviewVersions:
      - v1
    clientConfig:
      service:
        name: cluster-api-runtime-extensions-nutanix-admission
        namespace: cluster-api
        path: /validate-v1beta1-cluster
    failurePolicy: Fail
    name: cluster-validator.caren.nutanix.com
    rules:
      - apiGroups:
          - cluster.x-k8s.io
        apiVersions:
          - '*'
        operations:
          - CREATE
          - UPDATE
        resources:
          - clusters
    sideEffects: None
  - admissionReviewVersions:
      - v1
    clientConfig:
      service:
        name: cluster-api-runtime-extensions-nutanix-admission
        namespace: cluster-api
        path: /preflight-v1beta1-cluster
    failurePolicy: Fail
    name: preflight.cluster.caren.nutanix.com
    rules:
      - apiGroups:
          - cluster.x-k8s.io
        apiVersions:
          - '*'
        operations:
          - CREATE
        resources:
          - clusters
    sideEffects: None
    timeoutSeconds: 30
